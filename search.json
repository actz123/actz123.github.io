[{"title":"01背包","url":"/2024/02/22/01%E8%83%8C%E5%8C%85/","content":"\n","categories":["蓝桥杯","第四章：动态规划","背包问题"],"tags":["蓝桥杯备赛"]},{"title":"DFS-剪枝","url":"/2024/02/22/DFS-%E5%89%AA%E6%9E%9D/","content":"\n","categories":["蓝桥杯","第三章：搜索"],"tags":["蓝桥杯备赛"]},{"title":"DFS-基础","url":"/2024/02/22/DFS-%E5%9F%BA%E7%A1%80/","content":"\n","categories":["蓝桥杯","第三章：搜索"],"tags":["蓝桥杯备赛"]},{"title":"DFS-回溯","url":"/2024/02/22/DFS-%E5%9B%9E%E6%BA%AF/","content":"\n","categories":["蓝桥杯","第三章：搜索"],"tags":["蓝桥杯备赛"]},{"title":"LCS","url":"/2024/02/22/LCS/","content":"\n","categories":["蓝桥杯","第四章：动态规划","动态规划基础"],"tags":["蓝桥杯备赛"]},{"title":"LIS","url":"/2024/02/22/LIS/","content":"\n","categories":["蓝桥杯","第四章：动态规划","动态规划基础"],"tags":["蓝桥杯备赛"]},{"title":"Python开发环境与基础知识","url":"/2024/02/21/Python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"\n\n\n\n\n\n\n\n\n\n","categories":["蓝桥杯","第一章：语言基础","编程基础"],"tags":["蓝桥杯备赛"]},{"title":"Python输入输出","url":"/2024/02/21/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","content":"\n\n\n\n","categories":["蓝桥杯","第一章：语言基础","编程基础"],"tags":["蓝桥杯备赛"]},{"title":"collections","url":"/2024/02/21/collections/","content":"\n","categories":["蓝桥杯","第一章：语言基础","函数"],"tags":["蓝桥杯备赛"]},{"title":"for语句","url":"/2024/02/21/for%E8%AF%AD%E5%8F%A5/","content":"\n","categories":["蓝桥杯","第一章：语言基础","循环结构"],"tags":["蓝桥杯备赛"]},{"title":"functool","url":"/2024/02/21/functool/","content":"\n","categories":["蓝桥杯","第一章：语言基础","函数"],"tags":["蓝桥杯备赛"]},{"title":"heapq","url":"/2024/02/21/heapq/","content":"\n","categories":["蓝桥杯","第一章：语言基础","函数"],"tags":["蓝桥杯备赛"]},{"title":"Hello World","url":"/2024/02/20/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"itertools","url":"/2024/02/21/itertools/","content":"\n","categories":["蓝桥杯","第一章：语言基础","函数"],"tags":["蓝桥杯备赛"]},{"title":"math","url":"/2024/02/21/math/","content":"\n","categories":["蓝桥杯","第一章：语言基础","函数"],"tags":["蓝桥杯备赛"]},{"title":"while语句","url":"/2024/02/21/while%E8%AF%AD%E5%8F%A5/","content":"\n","categories":["蓝桥杯","第一章：语言基础","循环结构"],"tags":["蓝桥杯备赛"]},{"title":"if语句","url":"/2024/02/21/if%E8%AF%AD%E5%8F%A5/","content":"\n\n\n\n\n\n\n\n\n\n\n","categories":["蓝桥杯","第一章：语言基础","选择结构"],"tags":["蓝桥杯备赛"]},{"title":"二分","url":"/2024/02/21/%E4%BA%8C%E5%88%86/","content":"\n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"二分查找","url":"/2024/02/21/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","content":"\n","categories":["蓝桥杯","第一章：语言基础","实践应用"],"tags":["蓝桥杯备赛"]},{"title":"二维DP","url":"/2024/02/22/%E4%BA%8C%E7%BB%B4DP/","content":"\n","categories":["蓝桥杯","第四章：动态规划","动态规划基础"],"tags":["蓝桥杯备赛"]},{"title":"二维费用背包&分组背包","url":"/2024/02/22/%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/","content":"\n","categories":["蓝桥杯","第四章：动态规划","背包问题"],"tags":["蓝桥杯备赛"]},{"title":"位运算","url":"/2024/02/21/%E4%BD%8D%E8%BF%90%E7%AE%97/","content":"\n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"倍增","url":"/2024/02/21/%E5%80%8D%E5%A2%9E/","content":"\n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"冒泡排序","url":"/2024/02/21/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","content":"\n","categories":["蓝桥杯","第二章：基础算法","排序"],"tags":["蓝桥杯备赛"]},{"title":"函数定义与使用","url":"/2024/02/21/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/","content":"\n","categories":["蓝桥杯","第一章：语言基础","函数"],"tags":["蓝桥杯备赛"]},{"title":"列表和元组","url":"/2024/02/21/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/","content":"\n","categories":["蓝桥杯","第一章：语言基础","基础数据结构"],"tags":["蓝桥杯备赛"]},{"title":"单调队列优多重背包","url":"/2024/02/22/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/","content":"\n","categories":["蓝桥杯","第四章：动态规划","背包问题"],"tags":["蓝桥杯备赛"]},{"title":"前缀和","url":"/2024/02/21/%E5%89%8D%E7%BC%80%E5%92%8C/","content":"\n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"基础算法","url":"/2024/02/21/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/","content":"\n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"双指针","url":"/2024/02/21/%E5%8F%8C%E6%8C%87%E9%92%88/","content":"  \n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"字典","url":"/2024/02/21/%E5%AD%97%E5%85%B8/","content":"\t\n","categories":["蓝桥杯","第一章：语言基础","基础数据结构"],"tags":["蓝桥杯备赛"]},{"title":"字符串","url":"/2024/02/21/%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"\n","categories":["蓝桥杯","第一章：语言基础","基础数据结构"],"tags":["蓝桥杯备赛"]},{"title":"差分","url":"/2024/02/21/%E5%B7%AE%E5%88%86/","content":"\n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"常用库函数","url":"/2024/02/21/%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0/","content":"\n","categories":["蓝桥杯","第一章：语言基础","类的定义和使用"],"tags":["蓝桥杯备赛"]},{"title":"完全背包","url":"/2024/02/22/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/","content":"\n","categories":["蓝桥杯","第四章：动态规划","背包问题"],"tags":["蓝桥杯备赛"]},{"title":"归并排序","url":"/2024/02/21/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","content":"\n","categories":["蓝桥杯","第二章：基础算法","排序"],"tags":["蓝桥杯备赛"]},{"title":"常量、变量与运算符","url":"/2024/02/21/%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/","content":"\n\n\n\n\n\n\n\n","categories":["蓝桥杯","第一章：语言基础","编程基础"],"tags":["蓝桥杯备赛"]},{"title":"循环嵌套","url":"/2024/02/21/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/","content":"\n","categories":["蓝桥杯","第一章：语言基础","循环结构"],"tags":["蓝桥杯备赛"]},{"title":"手算与思维题","url":"/2024/02/22/%E6%89%8B%E7%AE%97%E4%B8%8E%E6%80%9D%E7%BB%B4%E9%A2%98/","content":"手算与思维题课程伊始，我们先要讲一下蓝桥杯相关的注意事项。\n比赛流程赛程：\n省赛\n决赛\n\n省赛一等奖参加决赛\n比赛时长 44 小时\n竞赛形式：\n个人赛，一人一机，全程机考\n答题过程中无法访问互联网\n不允许携带任何电子、纸质资料\n\n参赛选手机器环境\nX86 兼容机器，内存不小于 1G，硬盘不小于 60G 操作系统：Windows7、Windows8 或 Windows10。\nC&#x2F;C++ 开发环境：Dev-cpp 5.4.0 C&#x2F;C++ API 帮助文档\nJava 开发环境：JDK 1.8 Eclipse-java-2020-06 API 帮助文档\nPython 环境：Python 3.8.6 IDLE（Python 自带编辑器）\n\n题型\n结果填空 把答案直接通过网页提交，不要书写多余的内容。填空题每题 55 分。\n程序设计 每道题目多个测试数据，20%∼40%20%∼40% 是弱测试数据，其他是强测试数据。 题量大、时间紧张，难题往往不会做或来不及用高效算法编码，此时可以用暴力方法编程得 20%∼40%20%∼40% 的分数。 程序设计题每题 10% 25%10% 25% 分。\n\n评分方式评分：全部使用机器自动评分\n对于结果填空题，题目保证只有唯一解，选手的结果只有和解完全相同才得分，出现格式错误或有多余内容时不得分。\n对于编程大题，评测系统将使用多个评测数据来测试程序。每个评测数据有对应的分数。选手所提交的程序将分别用每个评测数据作为输入来运行。对于某个评测数据，如果选手程序的输出与正确答案是匹配的，则选手获得该评测数据的分数。\n知识点梳理（1）思维题（杂题）：不需要算法和数据结构，只需要逻辑、推理的题目，难度可难可易。考察思维能力和编码能力，只能通过大量做题来提高。\n（2）BFS 搜索和 DFS 搜索：也就是暴力搜索。这是非常基本的算法，是基础中的基础。\n（3）动态规划：线性 DP，以及一些 DP 应用，例如状态压缩 DP、树形 DP 等。\n（4）简单数学和简单数论。\n（5）简单的字符串处理、输入输出，简单图论。\n（6）基本算法：例如排序、排列、二分、倍增、差分、贪心。\n（7）基本数据结构：队列、栈、链表、二叉树等。\n技巧：手算\n应用场合：填空题\n手算的目的：减少做题时间，省下时间做编程题。\n\n手段：\n\n不编码，或者只做部分编码\n用推理获得答案\n用软件工具帮助计算\n\n方法：\n\n巧用编辑器\n心算手数\n巧用 Excel\n巧用 Python\n\n例题1. 门牌制作 2020 年第十一届蓝桥杯省赛，填空题问题描述： 从 11 到 20202020 的所有数字中，共有多少个 22？\n\n先编码连续打印出 11 ∼∼ 20202020 这 20202020 个数字\n然后粘贴到任何一个编辑器中\n选查询或替换功能，查找或替换字符 “22”，共 624624 次，就是答案。\n\n简单直接，不用思考\n2. 迷宫 2017 年第八届蓝桥杯省赛，填空题问题描述： 给出一个迷宫，问迷宫内的人有多少能走出来。迷宫如右图所示：每个位置上有一个人，共 100100 人。每个位置有指示牌，L 表示向左走，R 表示向右走，U 表示向上走，D 表示向下走。\nUDDLUULRULUURLLLRRRURRUURLDLRDRUDDDDUUUUURUDLLRRUUDURLRLDLRLULLURLLRDURDLULLRDDDUUDDUDUDLLULRDLUURRR\n\n\n正解：DFS 搜索，编码 10 分钟。\n技巧：直接用手画图标记 3-5 分钟。\n\n3. 迷宫 2017 年第八届蓝桥杯省赛，填空题问题描述： 整个 20 世纪（19011901 年 11 月 11 日至 20002000 年 1212 月 3131 日之间），一共有多少个星期一？\n思路： 用 Excel，在一个格子里输入日期 19011901 年 11 月 11 日，另一个格子输入 20002000 年 1212 月 3131 日，然后两个格子相减得 3652436524 天，除以 77 得 5217.75217.7 周。\n再看 19011901 年 11 月 11 日是星期几。\n用 Excel 点 19011901 年 11 月 11 日这一格的“设置单元格式-数字-日期-星期三”，点击“确定”，得“星期二”，即 19011901 年 11 月 11 日是星期二，3652436524 是 52175217 周多几天，最后几天没有星期一，说明答案就是 52175217。\n也可以直接利用 Excel“单元格格式”对话框得出 20002000 年 1212 月 3131 日刚好是星期天，从星期二至星期天之间没有星期一。\n巧用 Python填空题遇到字符、大数字、日期问题，Python 是首选。\n•即使参加 C&#x2F;C++、Java 组比赛，也要学一些 Python，以方便手算，或用来做对比测试。\n•这几种语言的编译器，在比赛机器上都有。\n•写 Python 代码既简单又快，代码长度一般比 C&#x2F;C++、Java 短很多。例如 30 行的 C++代码，用 Python 写只需要 20 行。\n3. 迷宫 2017 年第八届蓝桥杯省赛，填空题\n问题描述： 整个 20 世纪(1901 年 1 月 1 日至 2000 年 12 月 31 日之间)，一共有多少个星期一？\n直接用 Python datetime 库求解，第 4 行可以输出某个日期是星期几。\nfrom datetime import*dt1=datetime(1901,1,1)dt2=datetime(2000,12,31)print(dt1.weekday())# 周一为0，周二为1...td=dt2-dt1print(td.days//7)\n\n相对应的使用 C++同样可以完成，但是编码复杂：\n#include &lt;iostream&gt;using namespace std;int res;//先判断润年bool is_r(int n)&#123;     if((n % 4 == 0 &amp;&amp; n % 100 != 0) || n % 400 == 0)         return true;     return false;&#125;int main()&#123;    for(int i = 1901;i &lt;= 2000;i ++)        if(is_r(i)) res += 366;        else res += 365;    int x = res / 7;    cout &lt;&lt; x &lt;&lt; endl;    return 0;&#125;\n\n4. 乘积尾零 2018 年第九届蓝桥杯省赛\n【问题描述】 给出 100100 个整数（这里省略题目给的 100100 个数），问它们乘积的末尾有多少个零。\n最简单题解：\n\n直接连乘：几千位的大数\n然后统计末尾的 00\n\n\n但是 C++ 装不下这么大的数字，所以要进行处理：\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int cnt2=0,cnt5=0;    for (int i=1;i&lt;=10;i++)   &#123;        for (int j=1;j&lt;=10;j++)     &#123;            int x;            cin&gt;&gt;x;            while (x%2==0) cnt2++,x/=2;            while (x%5==0) cnt5++,x/=5;        &#125;    &#125;    cout&lt;&lt;min(cnt2,cnt5)&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n\n发现编码时间变长了，如果填空题且 Java 学的好一点的，可以直接 Python 编程出结果。\n思维题\n不需要涉及某种算法的题目。\n只要学过编程语言，就能够解答。\n主要考核学生的思维、逻辑和编码能力，强调脑筋急转弯的解决方式。\n这类题目包括模拟题、构造题、思维题以及找规律题，统称为“思维题（杂题）”。\n每年蓝桥杯都会设置这类题目，而且可能有多道，是考试中的重要得分点。\n杂题涵盖了各种难度，有些可能相对简单，而另一些可能相对较难。\n\n5. 付账问题 2018 年第九届蓝桥杯省赛，lanqiaoOJ 题号 174\n【题目描述】\n现在有 n 个人出去吃饭，他们总共消费了 S 元。其中第 i 个人带了 a**i元。幸运的是，所有人带的钱的总数是足够付账的，但现在问题来了：每个人分别要出多少钱呢？\n为了公平起见，我们希望在总付钱量恰好为 S 的前提下，最后每个人付的钱的标准差最小。这里我们约定，每个人支付的钱数可以是任意非负实数，即可以不是 1 分钱的整数倍。你需要输出最小的标准差是多少。\n标准差的介绍：标准差是多个数与它们平均数差值的平方平均数，一般用于刻画这些数之间的”偏差有多大”。形式化地说，设第 i 个人付的钱为 b**i 元，那么标准差为 :\n1Σ&#x3D;1(−1Σ&#x3D;1)2n1Σi&#x3D;1n(b**i−n1Σi&#x3D;1nbi)2\n解决思路：\n如果每个人携带的钱足够多，每个人平均支付相同的金额，即 &#x3D;&#x3D;avgb**i&#x3D;n**S&#x3D;avg，那么标准差 X 为 00。\n然而，总会有人的钱不够，这时我们考虑两种情况：\n（1）第 i 个人携带的钱不足以达到平均数 avgavg，那么他只能支付他所携带的全部钱 a**i。\n（2）第 i 个人携带的钱超过平均数 avgavg，那么他可以支付多一些。\n解决步骤：\n（1）对 a**i 进行从小到大的排序；\n（2）前一部分人的钱不足以支付平均数，因此他们每个人支付所有携带的钱；\n（3）从总支付数中减去前一部分人支付的钱，得到剩余金额 ′S′，以及后一部分人的平均支付数 avg′avg′。\n（4）后一部分人携带的钱较多，他们可以支付多一些。这部分人又可以分为两类：\n\n（i）相对富裕但仍然不足以支付 avg′avg′ 的人，他们需要支付所有携带的钱；\n（ii）非常富裕的人，无论如何摊分，他们都有余额。\n\n由于前面一部分人不足以支付 avgavg，因此后面足够支付 avg′avg′ 的人不能只支付 avgavg。相反，他们应该尽可能地每个人支付相同的金额。\n因为有人支付不足，总有人支付过多，由于是标准差（方差的平方根），因此每个人支付的金额差距越小越好。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int M = 5e5;long long a[M];int main()&#123;    int n;  long long s;    scanf(&quot;%d %lld&quot;,&amp;n,&amp;s);    for(int i=1;i&lt;=n;i++)  scanf(&quot;%lld&quot;,&amp;a[i]);    sort(a+1,a+n+1);       //排序，从小到大    double avg = 1.0*s/n;  //平均值    double sum = 0.0;    for(int i=1;i&lt;=n;i++)&#123;        if(a[i]*(n+1-i) &lt; s)&#123;//需要把钱全拿出的人：//（1）钱不够平均数的，（2）钱够平均数，但也不是很多的            sum += (a[i]-avg)*(a[i]-avg);            s -= a[i];            //更新剩余钱数        &#125;        else&#123;      //不用把钱全拿出的人：非常有钱，不管怎么平均都够            double cur_avg = 1.0*s/(n+1-i);    //更新平均出钱数            sum += (cur_avg-avg)*(cur_avg-avg)*(n+1-i);            break;        &#125;    &#125;    printf(&quot;%.4lf&quot;,sqrt(sum/n));    return 0;&#125;from math import *n, s = map(int,input().split())a = list(map(int,input().split()))a.sort()avg = s/nsum = 0for i in range(n):     if a[i]*(n-i) &lt; s:          sum += pow(a[i]-avg,2)          s -= a[i]     else:          cur_avg = s/(n-i);      #更新平均出钱数          sum += pow(cur_avg-avg,2)*(n-i)          breakprint(&quot;&#123;:.4f&#125;&quot;.format(sqrt(sum/(n))))import java.io.FileNotFoundException;import java.util.Arrays;import java.util.Scanner;public class Main &#123;public static void main(String args[]) &#123;        int n;        long S;        double ans=0,avg;        Scanner input=new Scanner(System.in);        n=input.nextInt();        S=input.nextLong();        long a[]=new long[n];        for(int i=0;i&lt;n;i++)                    a[i]=input.nextLong();        Arrays.sort(a);        avg=(double)S/n;        for(int i=0;i&lt;n;i++) &#123;            if(S&lt;=(n-i)*a[i]) &#123;                ans += (n-i)*Math.pow((double)S/(n-i)-avg,2);                break;            &#125;            ans += Math.pow(a[i]-avg,2);            S -= a[i];        &#125;        System.out.printf(&quot;%.4f\\n&quot;,Math.sqrt(ans/n));    &#125;&#125;\n","categories":["蓝桥杯冲刺营","1.手算和思维题"],"tags":["蓝桥杯备赛"]},{"title":"快速排序","url":"/2024/02/21/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","content":"\n","categories":["蓝桥杯","第二章：基础算法","排序"],"tags":["蓝桥杯备赛"]},{"title":"插入排序","url":"/2024/02/21/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","content":"\n","categories":["蓝桥杯","第二章：基础算法","排序"],"tags":["蓝桥杯备赛"]},{"title":"日期和时间","url":"/2024/02/21/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/","content":"\n","categories":["蓝桥杯","第一章：语言基础","基础数据结构"],"tags":["蓝桥杯备赛"]},{"title":"条件表达式和逻辑表达式","url":"/2024/02/21/%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"\n\n","categories":["蓝桥杯","第一章：语言基础","选择结构"],"tags":["蓝桥杯备赛"]},{"title":"构造","url":"/2024/02/21/%E6%9E%84%E9%80%A0/","content":"\n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"搜索算法","url":"/2024/02/22/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/","content":"深度优先搜索Depth First Search 即 DFS，意为深度优先搜索，是所有的搜索手段之一。它是从某个状态开始，不断进行状态转移，直到不能转移后，向后回退，一直到遍历完所有的状态。\n本章题目难度较大，请大家仔细研读讲解和代码。\n知识点1.DFS 算法设计原理与实现方法 2.经典题型精讲\n深度优先搜索基本概念作为搜索算法的一种，DFS 主要是用于解决 NP 完全问题。但是，深度优先搜索算法的时间复杂度较高，深度优先搜索是 (!)O(n!) 的阶乘级算法，它的效率非常低，在数据规模变大时，此算法就难以解决当前的问题了。\n所以搜索算法使用于状态节点较小规模的问题。\nDFS 的设计步骤按照定义设计：\n\n确定该题目的状态（包括边界）\n找到状态转移方式\n找到问题的出口，计数或者某个状态\n设计搜索\n\n伪代码：\nint check(参数)&#123;    if(满足条件)        return 1;    return 0;&#125;bool pd(参数)&#123;    相应操作&#125;void dfs(int step)&#123;        判断边界pd()        &#123;            不在边界内，即回溯        &#125;        尝试每一种可能        &#123;               满足check条件               标记               继续下一步dfs(step+1)               恢复初始状态（回溯的时候要用到）        &#125;&#125;\n\nDFS 题目讲解状态搜索代表： N 皇后问题题目链接\n难度: 简单\n标签: DFS\n题目描述:\n在 ×N×N 的方格棋盘放置了 N 个皇后，使得它们不相互攻击（即任意 22 个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成 4545 角的斜线上。你的任务是，对于给定的 N，求出有多少种合法的放置方法。\n输入描述:\n输入中有一个正整数 ≤10N≤10，表示棋盘和皇后的数量\n输出描述:\n为一个正整数，表示对应输入行的皇后的不同放置数量。\n输入输出样例:\n示例:\n输入:\n5\n\n输出:\n10\n\n运行限制:\n最大运行时间：1s最大运行内存: 256M\n\n解题思路:\n下面是用递归的深度优先搜索求解 n 皇后问题的算法描述：\n这里用一个 ×N×N 的矩阵来表示棋盘，但是我们不需要定义这样的数组，只要心中有 ×N×N 的期盼即可。\n\n算法开始：\n当前行设为第一行，当前列设为第一列，从第一行第一列开始搜索，即只能让皇后从第一行放到第 n 行。\n这样在每次判断是否满足情况时我们不用去判断是否皇后在相同行。\n我们只用判断之前的 11 到 −1a−1 个皇后的位置和当前第 a 个皇后的位置是否属于同一列或者斜线，判断是否同一列。\n\n判断边界：\n在当前行，当前列的位置上判断是否满足条件(即保证经过这一点的行,列与斜线上都没有两个皇后)，若不满足，跳到第 55 步，即不符合边界条件。\n首先说一下，什么叫不符合边界条件，不只是跳出了搜索范围，剪枝也可以从这里开始，比如这里不满足条件，向下继续搜索也不会再有结果。\n这可以理解为超出边界的剪枝，我们的边界只得可能存在解的范围，这里已经超出有解的范围，必然要被踢出。\n判断条件：\n我们用数组 []&#x3D;x[a]&#x3D;i 来表示第 a 个皇后的位置在第 a 行第 i 列，我们不用考虑是否在同一行的问题你，我们只用判断之前的 11 到 −1a−1 个皇后的位置和当前第 a 个皇后的位置是否属于同一列或者斜线。\n判断是否属于同一列： 就判断 []x[a] 是否等于 []x[i]; 判断是否属于同一斜线：等同于判断行之差是否等于列之差也，即 ([]−[])≠(−)abs(x[k]−x[i])&#x3D;abs(k−i)。\n\n搜索过程：\n调用 Check 函数。\n如果 边界条件，就继续调用放下一个皇后的位置\n\nCheck 函数:\n如果当搜索到第 +1N+1 行的时候，即代表前 N 行已经搜索完了，所以这个时候正好求出了一个解，记录加一。\n\n在当前位置上不满足条件的情形，进行回溯。\n\n\nC++ 语言描述:\n#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int x[15] = &#123;0&#125;;int sum,n;int PD(int k)&#123;    for(int i=1; i&lt;k; i++)    &#123;        if(abs(k-i)==abs(x[k]-x[i]))            return 0;        else if (x[k]==x[i])            return 0;        //即判断是否符合条件来放,i表示皇后所在的行数，x[i]表示所在的列数，        //所以前面那个条件用来判断两个皇后是否在对角线上,后面用来判断是否在同一列上。        //行数不需要判断，因为他们本身的i就代表的是行数    &#125;    return 1;&#125;bool check(int a)&#123;    if(a&gt;n)        sum++;    else        return 0;    return 1;&#125;void DFS(int a)&#123;    if(check(a))        return ;    else        for(int i=1; i&lt;=n; i++)        &#123;            x[a]=i;                //第a个皇后放的列数            if(PD(a))                    //判断是否能放这步                DFS(a+1);                    //能的话进行下一个皇后的放置            else continue ;                    //不能就下一列        &#125;&#125;int main()&#123;    cin&gt;&gt;n;    //表示几个皇后    DFS(1);    //每次都从第一个皇后开始    cout&lt;&lt;sum&lt;&lt;endl;    return 0;&#125;\n\nPython 语言描述：\n x = [0] * 15n = 0sum = 0def pd(k):    for i in range(1, k):        if abs(k - i) == abs(x[k] - x[i]):            return 0        elif x[k] == x[i]:            return 0        # 即判断是否符合条件来放,i表示皇后所在的行数，x[i]表示所在的列数，        # 所以前面那个条件用来判断两个皇后是否在对角线上,后面用来判断是否在同一列上。        # 行数不需要判断，因为他们本身的i就代表的是行数    return 1def check(a):    if a &gt; n:        global sum        sum += 1    else:        return False    return Truedef DFS(a):    if check(a):        return    else:        for i in range(1, n + 1):            x[a] = i            # 第a个皇后放的列数            if pd(a):                # 判断是否能放这步                DFS(a + 1)                # 能的话进行下一个皇后的放置            else:                continue                #   不能就下一列if __name__ == &#x27;__main__&#x27;:    n = int(input())    # 不能就下一列    DFS(1)    # 每次都从第一个皇后开始    print(sum)\n\nJava 语言描述:\nimport java.util.Scanner;import static java.lang.Math.abs;public class Main &#123;    static int x[] = new int[15];    static int sum, n;    static boolean PD(int k) &#123;        for (int i = 1; i &lt; k; i++) &#123;            if (abs(k - i) == abs(x[k] - x[i]))                return false;            else if (x[k] == x[i])                return false;            //即判断是否符合条件来放,i表示皇后所在的行数，x[i]表示所在的列数，            //所以前面那个条件用来判断两个皇后是否在对角线上,后面用来判断是否在同一列上。            //行数不需要判断，因为他们本身的i就代表的是行数        &#125;        return true;    &#125;    static boolean check(int a) &#123;        if (a &gt; n)            sum++;        else            return false;        return true;    &#125;    static void DFS(int a) &#123;        if (check(a))            return;        else            for (int i = 1; i &lt;= n; i++) &#123;                x[a] = i;                //第a个皇后放的列数                if (PD(a))                    //判断是否能放这步                    DFS(a + 1);                    //能的话进行下一个皇后的放置                else continue;                //不能就下一列            &#125;    &#125;    public static void main(String[] args) &#123;        Scanner in = new Scanner(System.in);        n = in.nextInt();        //表示几个皇后        DFS(1);        //每次都从第一个皇后开始        System.out.println(sum);    &#125;&#125;\n\n图的路径搜索代表-路径之谜题目链接\n难度: 中等\n标签: DFS, 2016, 国赛\n题目描述:\n小明冒充 X 星球的骑士，进入了一个奇怪的城堡。\n城堡里边什么都没有，只有方形石头铺成的地面。\n假设城堡地面是 ×n×n 个方格。如下图所示。\n\n按习俗，骑士要从西北角走到东南角。可以横向或纵向移动，但不能斜着走，也不能跳跃。每走到一个新方格，就要向正北方和正西方各射一箭。（城堡的西墙和北墙内各有 n 个靶子）同一个方格只允许经过一次。但不必走完所有的方格。如果只给出靶子上箭的数目，你能推断出骑士的行走路线吗？有时是可以的，比如上图中的例子。\n本题的要求就是已知箭靶数字，求骑士的行走路径（测试数据保证路径唯一）\n输入:\n第一行一个整数 N (0≤≤200≤N≤20)，表示地面有 ×N×N 个方格。\n第二行 N 个整数，空格分开，表示北边的箭靶上的数字（自西向东）\n第三行 N 个整数，空格分开，表示西边的箭靶上的数字（自北向南）\n输出：\n输出一行若干个整数，表示骑士路径。\n为了方便表示，我们约定每个小格子用一个数字代表，从西北角开始编号: 0,1,2,3 ⋯⋯\n输入输出样例：\n输入\n42 4 3 44 3 3 3\n\n比如，上图中的方块编号为：\n\n\n\n箭靶\n2\n4\n3\n4\n\n\n\n4\n0\n1\n2\n3\n\n\n3\n4\n5\n6\n7\n\n\n3\n8\n9\n10\n11\n\n\n3\n12\n13\n14\n15\n\n\n输出\n0 4 5 1 2 3 7 11 10 9 13 14 15\n\n运行限制:\n最大运行时间：1s最大运行内存: 128M\n\n解题思路:\n这里用一个 ×N×N 的矩阵来表示城堡的位置，横向、纵向标号 1−1−N。\n我们采用逆推法，既然原题目是走到哪里射一支箭，那我们就走到那里之后拔一支箭，如果最后得到所有的靶子上都没有箭了，由于题目的路径唯一，那就证明我们找到了题目所要求的路径。\n\n算法开始：\n当前行设为第一行，当前列设为第一列，从第一行第一列开始搜索。\n然后从左上角初始位置，按照题目意思进行寻路。\n\n判断边界：\n在当前行，当前列的位置上判断是否满足条件，若不满足，跳到第 55 步，即不符合边界条件。 判断条件如下：\n\n[][]fla**g[x][y]&#x3D;&#x3D;1 标记数组已经被标记,已被走过，不能再走，超出边界\n&lt;1x&lt;1 从左侧走出方格。\n\nx&gt;n 从右侧走出方格。\n\n\n&lt;1y&lt;1 从上侧走出方格。\n\ny&gt;n 从下侧走出方格。\n\n\n[]&lt;&#x3D;0col[x]&lt;&#x3D;0 没走到右下角，箭用完了。\n[]&lt;&#x3D;0rol[y]&lt;&#x3D;0 没走到右下角，箭用完了\n\n\n搜索过程：\n调用 Check 函数。 如果边界条件满足，就继续调用搜索，找到下一步的位置\n\ncheck(参数):\n如果当搜索到 &#x3D;,&#x3D;x&#x3D;n,y&#x3D;n 时，且靶子上的箭都没了，按就找到了答案。\n按照题目输出即可。\n\n在当前位置上不满足条件的情形，进行回溯，并还原现场\n\n\nC++ 语言描述:\n#include &lt;bits/stdc++.h&gt;using namespace std;struct PII&#123;    int first;    int second;&#125;;const int N = 30;int rol[N];int col[N];int n;//格子数 长宽从1到nbool flag[N][N]; //用来标记是否走过vector&lt;PII&gt; res;//---------图的路径搜索常用方向移动表示-------int dx[4]= &#123;0,1,-1,0&#125;;int dy[4]= &#123;1,0,0,-1&#125;;// 两两组合形成上下左右四个方向//      1------------------&gt; x//      |//      |//      |//      |//      |//      |//      |//      ↓//      y// dx[0]=0 dy[0]=1 那么代表向下的方向// dx[1]=1 dy[1]=0 那么代表向右的方向// dx[2]=-1 dy[0]=0 那么代表向左的方向// dx[3]=0 dy[1]=-1 那么代表向上的方向//--------------------------------------------bool  check(int x, int y) //判断走过的路径的箭靶数是否与目标相同&#123;    if(x==n &amp;&amp; y==n)    &#123;        for(int i=1; i&lt;=n; i++)        &#123;            if(col[i]!=0)            &#123;                return false;            &#125;            //如果箭靶上的数目不为0，根据逆推，我们通过当前路径得不到箭靶上的结果        &#125;        for(int i=1; i&lt;=n; i++)        &#123;            if(rol[i]!=0)            &#123;                return false;            &#125;            //如果箭靶上的数目不为0，根据逆推，我们通过当前路径得不到箭靶上的结果        &#125;        for(int i=0; i&lt;res.size(); i++)        &#123;            int x=res[i].first;            //x 轴坐标            int y=res[i].second;            //y 轴坐标            int sum=n*(x-1)+y-1 ;            // 通过计算的到为题目要求的坐标系            cout &lt;&lt;sum&lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;        return false;        // 成功终止    &#125;    return true; //继续搜索    //关于终止还是继续我们交给判定即可&#125;bool pd(int x2,int y2) //边界判断&#123;    if(flag[x2][y2]==1)        return 0;    //已被走过，不能再走，超出边界    else if(x2&lt;1)        return 0;    //从左侧走出方格    else if(x2&gt;n)        return 0;    //从右侧走出方格    else if(y2&lt;1)        return 0;    //从上侧走出方格    else if(y2&gt;n)        return 0;    //从下侧走出方格    else if(col[x2]&lt;=0)        return 0;    //没走到右下角，箭用完了    else if(rol[y2]&lt;=0)        return 0;    //没走到右下角，箭用完了    else return 1;    //符合边界条件，可以继续执行搜索&#125;void dfs(int x,int y)&#123;    if(!check(x,y))    &#123;        return ;        //包含不符合规则的地方，回溯，用于剪枝    &#125;    else    &#123;        for(int i=0; i&lt;4; i++)        &#123;            int xt=dx[i]+x;            int yt=dy[i]+y;            if(!pd(xt,yt))            &#123;                continue ;                //不符合要求继续换方向搜索            &#125;            else            &#123;                //因为要进行位置转移，我们给它起个名字，叫作案现场                //比如向下移动                flag[xt][yt]=true;                col[xt]--;                rol[yt]--;                res.push_back(&#123;xt,yt&#125;);                dfs(xt,yt);                //搜索回溯后，因为没有找到正确答案，所以要回复作案现场，返回到搜索之前                res.pop_back();                flag[xt][yt]=false;                col[xt]++;                rol[yt]++;            &#125;        &#125;    &#125;&#125;int main()&#123;    cin &gt;&gt; n;    for(int i=1; i&lt;=n; i++)        cin &gt;&gt; rol[i];    for(int i=1; i&lt;=n; i++)        cin &gt;&gt; col[i];    flag[1][1]=true;    col[1]--;    rol[1]--;    res.push_back(&#123;1,1&#125;);    dfs(1,1);    return 0;&#125;\n\nPython 语言描述:\nn = 0flag = [[0 for i in range(26)] for i in range(27)]resX = [0 for i in range(1000)]resY = [0 for i in range(1000)]resCount = 0# ---------图的路径搜索常用方向移动表示-------dx = [0, 1, -1, 0]dy = [1, 0, 0, -1]# 两两组合形成上下左右四个方向#      1------------------&gt; x#      |#      |#      |#      |#      |#      |#      |#      ↓#      y# dx[0]=0 dy[0]=1 那么代表向下的方向# dx[1]=1 dy[1]=0 那么代表向右的方向# dx[2]=-1 dy[0]=0 那么代表向左的方向# dx[3]=0 dy[1]=-1 那么代表向上的方向# --------------------------------------------def check(x, y):    global n    if x == n &amp; y == n:        # print(&quot;check point1&quot;)        for i in range(1, n + 1):            if (col[i] != 0):                return False                # 如果箭靶上的数目不为0，根据逆推，我们通过当前路径得不到箭靶上的结果        for i in range(1, n + 1):            if (rol[i] != 0):                return False        for i in range(0, resCount):            x2 = resX[i]            # x 轴坐标            y2 = resY[i]            # y 轴坐标            sum = n * (x2 - 1) + y2 - 1            # 通过计算的到为题目要求的坐标系            print(sum, end=&quot; &quot;)        return False        # 成功终止    else:        return True  # 继续搜索        # 关于终止还是继续我们交给判定即可def pd(x2, y2):    global n    # print(&quot;x2 :&quot;, x2,&quot;y2 :&quot;, y2, &quot; n &quot;, n)    if flag[x2][y2] == 1:        # print(&quot;checkPoint3&quot;)        return False        # 已被走过，不能再走，超出边界    elif x2 &lt; 1:        # print(&quot;checkPoint5&quot;)        return False    # 从左侧走出方格    elif x2 &gt; n:        # print(&quot;checkPoint6&quot;)        return False    # 从右侧走出方格    elif col[x2] &lt;= 0:        # print(&quot;checkPoint8&quot;)        return False    # 没走到右下角，箭用完了    elif y2 &lt; 1:        # print(&quot;checkPoint7&quot;)        return False    # 从上侧走出方格    elif y2 &gt; n:        # print(&quot;y2 :&quot;,y2,&quot; n &quot;,n)        return False    # 从下侧走出方格    elif rol[y2] &lt;= 0:        # print(&quot;checkPoint9&quot;)        return False    # 没走到右下角，箭用完了    else:        return True# 符合边界条件，可以继续执行搜索def dfs(x, y):    if not check(x, y):        return    # 包含不符合规则的地方，回溯，用于剪枝    else:        for i in range(0, 4):            xt = dx[i] + x            yt = dy[i] + y            # print(xt, yt)            if not pd(xt, yt):                # print(&quot;CheckPoint&quot;, xt, yt)                continue                # 不符合要求继续换方向搜索            else:                # 因为要进行位置转移，我们给它起个名字，叫作案现场                # 比如向下移动                col[xt] -= 1                rol[yt] -= 1                flag[xt][yt] = 1                global resCount                resX[resCount] = xt                resY[resCount] = yt                resCount += 1                # print(&quot;---------123-------&quot;)                # print(flag)                # print(&quot;----------------&quot;)                dfs(xt, yt)                # 搜索回溯后，因为没有找到正确答案，所以要回复作案现场，返回到搜索之前                resCount -= 1                flag[xt][yt] = 0                # print(&quot;--------321--------&quot;)                # print(flag)                # print(&quot;----------------&quot;)                col[xt] += 1                rol[yt] += 1if __name__ == &#x27;__main__&#x27;:    n = int(input())    # print(&quot;----------------&quot;)    # print(flag)    # print(&quot;----------------&quot;)    rol = input().split()    rol = list(map(int, rol))    rol = [0] + rol    col = input().split()    col = list(map(int, col))    col = [0] + col    flag[1][1] = 1    # print(&quot;----------------&quot;)    # print(flag)    # print(&quot;----------------&quot;)    col[1] -= 1    rol[1] -= 1    resX[resCount] = 1    resY[resCount] = 1    resCount += 1    dfs(1, 1)\n\n然而需要注意的是上面代码会超时，我们要对其进行优化，因为同样的计算 Python 运行时间相比 C++ 要长很多，这里给 C++ 和 Python 相同的时间，确实是难为 Python 了。 因为上面是为了给大家系统的将一个框架，而这道题目的时间复杂度相对较高，Python 的运行时间是 C++ 10 倍甚至几十倍，这个题目，同样的复杂度，Python 给的时间是不好通过这个题目的，我优化了十几遍，确实通过不了。\nJava 语言描述:\nimport java.util.Scanner;import java.util.Vector;import static java.lang.Math.abs;public class Main &#123;    static final int N = 30;    static int rol[]=new int [N];    static int col[]=new int [N];    static int n;//格子数 长宽从1到n    static  boolean flag[][]=new boolean[N][N]; //用来标记是否走过    static int resX[]=new int [1000];    static int resY[]=new int [1000];    static int resCount=0;//---------图的路径搜索常用方向移动表示-------    static int dx[]= &#123;0,1,-1,0&#125;;    static  int dy[]= &#123;1,0,0,-1&#125;;// 两两组合形成上下左右四个方向//      1------------------&gt; x//      |//      |//      |//      |//      |//      |//      |//      ↓//      y// dx[0]=0 dy[0]=1 那么代表向下的方向// dx[1]=1 dy[1]=0 那么代表向右的方向// dx[2]=-1 dy[0]=0 那么代表向左的方向// dx[3]=0 dy[1]=-1 那么代表向上的方向//--------------------------------------------    static boolean  check(int x, int y) //判断走过的路径的箭靶数是否与目标相同    &#123;        if(x==n &amp;&amp; y==n)        &#123;            for(int i=1; i&lt;=n; i++)            &#123;                if(col[i]!=0)                &#123;                    return false;                &#125;                //如果箭靶上的数目不为0，根据逆推，我们通过当前路径得不到箭靶上的结果            &#125;            for(int i=1; i&lt;=n; i++)            &#123;                if(rol[i]!=0)                &#123;                    return false;                &#125;                //如果箭靶上的数目不为0，根据逆推，我们通过当前路径得不到箭靶上的结果            &#125;            for(int i=0; i&lt;resCount; i++)            &#123;                int x2= resX[i];                //x 轴坐标                int y2=resY[i];                //y 轴坐标                int sum=n*(x2-1)+y2-1 ;                // 通过计算的到为题目要求的坐标系                System.out.print(sum+&quot; &quot;);            &#125;            System.out.println();            return false;            // 成功终止        &#125;        return true; //继续搜索        //关于终止还是继续我们交给判定即可    &#125;    static boolean pd(int x2,int y2) //边界判断    &#123;        if(flag[x2][y2] )            return false;            //已被走过，不能再走，超出边界        else if(x2&lt;1)            return false;            //从左侧走出方格        else if(x2&gt;n)            return false;            //从右侧走出方格        else if(y2&lt;1)            return false;            //从上侧走出方格        else if(y2&gt;n)            return false;            //从下侧走出方格        else if(col[x2]&lt;=0)            return false;            //没走到右下角，箭用完了        else if(rol[y2]&lt;=0)            return false;            //没走到右下角，箭用完了        else return true;        //符合边界条件，可以继续执行搜索    &#125;    static void dfs(int x,int y)    &#123;        if(!check(x,y))        &#123;            return ;            //包含不符合规则的地方，回溯，用于剪枝        &#125;        else        &#123;            for(int i=0; i&lt;4; i++)            &#123;                int xt=dx[i]+x;                int yt=dy[i]+y;                if(!pd(xt,yt))                &#123;                    continue ;                    //不符合要求继续换方向搜索                &#125;                else                &#123;                    //因为要进行位置转移，我们给它起个名字，叫作案现场                    //比如向下移动                    flag[xt][yt]=true;                    col[xt]--;                    rol[yt]--;                    resX[resCount]=xt;                    resY[resCount++]=yt;                    dfs(xt,yt);                    //搜索回溯后，因为没有找到正确答案，所以要回复作案现场，返回到搜索之前                    resCount--;                    flag[xt][yt]=false;                    col[xt]++;                    rol[yt]++;                &#125;            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        Scanner in = new Scanner(System.in);        n = in.nextInt();        for(int i=1; i&lt;=n; i++)            rol[i]=in.nextInt();        for(int i=1; i&lt;=n; i++)             col[i]=in.nextInt();        flag[1][1]=true;        col[1]--;        rol[1]--;        resX[resCount]=1;        resY[resCount++]=1;        dfs(1,1);    &#125;&#125;\n\n最大数字给定一个正整数 N 。你可以对 N 的任意一位数字执行任意次以下 22 种操 作：\n\n将该位数字加 11 。如果该位数字已经是 99 , 加 11 之后变成 00 。\n将该位数字减 11 。如果该位数字已经是 00 , 减 11 之后变成 99 。\n\n你现在总共可以执行 11 号操作不超过 A 次, 22 号操作不超过 B 次。 请问你最大可以将 N 变成多少?\n解题思路:\n看上去 N 的范围貌似很大，达到了 1e17 的范围，但其实我们最多只需要考虑这最多 17 位数，所以可以想到爆搜得到答案。\n一个数的大小是从左到右依次判断，所以我们从最左边开始枚举，我们无需关注后面的数，要利用自己的 1 号操作和 2 号操作 保证当前这个数位的数一定要尽可能最大\n然后分别考虑两种操作，首先两种操作不可能混用，因为它们是抵消的效果，所以要么对这个数全使用 1 操作，要么 2 操作。假设某个数位的值为 x,首先考虑 1 号操作，使用后可以让该数位变大，出于贪心考虑，我们想让它变成 9，那么需要进行 9-x 次 1 号操作，当然可能此时 1 号操作并不足以让我们将 x 变成 9，但我们还是使用剩余的全部的次数将其变大，所以每次考虑 1 号操作应该使用的操作数 t 应该为 t=min(n,9-x),此时 x 将变为 x+t，然后进行下一位的判断。\n其次我们考虑 2 号操作，这个的判断比较简单，它是让某个值减小，唯一能让某个数变大的机会就是将其减到 0 后再减就会变成 9。那么这样操作需要的次数就是 x+1，如果操作次数不够，那我们宁愿不使用，因为这只会让这个数位变得更小。\n在深搜 dfs 的过程中，参数记录遍历到第几个数位以及此时累计的和，当搜索完所有数位后，将此时的和与答案进行一个取 max，最后的值则为答案。\nC++ 语言描述：\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;char c[20];LL ans=0;//n:1号操作剩余次数  m:2号操作剩余次数int n,m;void dfs(int i,LL v)&#123;    int x=c[i]-&#x27;0&#x27;;    if(c[i])&#123;        //应该使用的操作次数        int t=min(n,9-x);        n-=t;        dfs(i+1,v*10+x+t);        //回溯        n+=t;        //考虑操作2是否能够使用        if(m&gt;x)&#123;            m-=x+1;            dfs(i+1,v*10+9);            //回溯            m+=x+1;        &#125;    &#125;else&#123;        //答案取max        ans=max(ans,v);    &#125;&#125;int main()&#123;    scanf(&quot;%s%d%d&quot;,c,&amp;n,&amp;m);    dfs(0,0);    printf(&quot;%lld\\n&quot;,ans);    return 0;&#125;\n\nJava 语言描述:\nimport java.io.*;public class Main &#123;    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));    static String t;    static int a, b, m;    static long ans = 0;    // i 表示考虑到第i位  v表示当前的值是多少    static void dfs(int i, long v) &#123;        if (i == m) &#123;            ans = Math.max(ans, v);            return;        &#125;        int c = t.charAt(i) - &#x27;0&#x27;;        //考虑第一种使用        int g = Math.min(a, 9 - c);        a -= g;        dfs(i + 1, v * 10 + c + g);        //回溯        a += g;        //考虑第二种使用   我一定要减到9  只有b&gt;c 才能减到9        if (b &gt; c) &#123;            b -= c + 1;            dfs(i + 1, v * 10 + 9);            //回溯            b += c + 1;        &#125;    &#125;    public static void main(String[] args) throws IOException &#123;        String[] s = br.readLine().trim().split(&quot; &quot;);        t = s[0];        m = t.length();        a = Integer.parseInt(s[1]);        b = Integer.parseInt(s[2]);        dfs(0, 0);        out.println(ans);        out.flush();    &#125;&#125;\n\nPython 语言描述:\nimport syst = &quot;&quot;a = 0b = 0m = 0ans = 0def dfs(i, v):    global ans, a, b, t    if i == m:        ans = max(ans, v)        return    c = int(t[i])    # 考虑第一种使用    g = min(a, 9 - c)    a -= g    dfs(i + 1, v * 10 + c + g)    # 回溯    a += g    # 考虑第二种使用   我一定要减到9  只有b&gt;c 才能减到9    if b &gt; c:        b -= c + 1        dfs(i + 1, v * 10 + 9)        # 回溯        b += c + 1def main():    global ans, a, b, t, m    line = sys.stdin.readline().strip()    s = line.split()    t = s[0]    m = len(t)    a = int(s[1])    b = int(s[2])    dfs(0, 0)    print(ans)if __name__ == &quot;__main__&quot;:    main()\n\n实验总结DFS 是一种非常重要的回溯算法，它是通过递归设计转移状态，再加上边界判断，与结果检查，构成的基本搜索框架。\nDFS 最重要的就是设计回溯，所谓回溯就是还原现场，保证在执行另一分支的时候能够确保所有的改变只受当前状态的影响，所以在一条路走不通时就要修改。特殊的修改可以达到特殊的回溯效果，回溯时剪枝，回溯时调整路线，都是可以的。\nDFS 是算法学习的基础工具，很重要，必须要学会。\n\nshow: step version: 1.0 enable_checker: true\n\n广度优先搜索BFS，其英文全称是 Breadth First Search，意为广度优先搜索，是所有的搜索手段之一。它是从某个状态开始，将所有节点加入一个先进先出的队列，然后一层一层进行状态转移，并且展开节点。\n本章题目难度较大，请大家仔细研读讲解和代码。\n知识点1.BFS 算法设计原理与实现方法 2.经典题型精讲\n广度优先搜索基本概念作为搜索算法的一种，BFS 相较于 DFS 而言，BFS 是一层一层展开的，那么对于有多个终态时，最先找到的一定是最短的。\n广度优先搜索算法的设计步骤按照定义设计：\n\n确定该题目的状态（包括边界）\n找到状态转移方式\n找到问题的出口，计数或者某个状态\n设计搜索\n\n会发现我们前期要找到的参数基本一致，所以在一般情况下 BFS 和 DFS 可以相互转换。\n伪代码：\nint check(参数)&#123;    if(满足条件)        return 1;    return 0;&#125;bool pd(参数)&#123;    相应操作&#125;void bfs()&#123;    1. 把根节点放入队列尾端    2. 每次从队列中取出一个节点    3. Check 判断是不是答案，如果是结束算法 return;    4. 把当前取出的节点扩展，如果扩展后的节点经Pd()后符合要求，就放入队列，不符合就不放。    5. 转到步骤2，循环执行&#125;如果所有节点被扩展完了，没有找到答案就无解。\n\n长草题目链接\n难度: 简单\n标签: 模拟, BFS, 2020, 省模拟赛\n题目描述:\n小明有一块空地，他将这块空地划分为 n 行 m 列的小块，每行和每列的长度都为 1。\n小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。\n这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，\n这四小块空地都将变为有草的小块。请告诉小明，k 个月后空地上哪些地方有草。\n输入描述:\n输入的第一行包含两个整数 ,n,m。\n接下来 n 行，每行包含 m 个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 g，表示种了草。\n接下来包含一个整数 k。 其中，2≤,≤1000，1≤≤10002≤n,m≤1000，1≤k≤1000。\n输出描述:\n输出 n 行，每行包含 m 个字母，表示 k 个月后空地的状态。如果为小数点，表示为空地，如果字母为 g，表示长了草。\n输入输出样例:\n示例:\n输入:\n4 5.g..........g.......2\n\n输出:\ngggg.gggg.ggggg.ggg.\n\n运行限制:\n最大运行时间：1s最大运行内存: 256M\n\n解题思路:\n这个题目简直就是为了广度优先搜索设置模板题，由于这个题目时输出广度优先搜索 K 次扩展后的终态，那我们就不用设置 Check 函数。\n这里用一个 ×N×M 的矩阵来表示草地。\n\n算法开始：\n将字母为 g 的草地的位置加入队列，然后向下执行\n\n判断边界：\n判断是否已经长了草，判断是否超出边界范围\n\n搜索过程：\n不断从队列取出一个节点，进行上下左右的扩展，执行 2 判断边界，符合就放入队列，不符合就跳过。\n执行 K 次扩展，输出草地状态。\n\ncheck(参数)：\n这里不需要进行 Check\n\n\nC++ 语言描述:\n#include &lt;bits/stdc++.h&gt;using namespace std;const int M = 1005;struct PII&#123;    int first;    int second;&#125;;// C++ 有个数据类型叫 pair 上面的就可以定义为 pair&lt;int,int&gt; 用起来比较方便。PII tempPair;//临时结点char Map[M][M];//---------图的路径搜索常用方向移动表示-------int dx[4]= &#123;0,1,-1,0&#125;;int dy[4]= &#123;1,0,0,-1&#125;;// 两两组合形成上下左右四个方向//      1------------------&gt; x//      |//      |//      |//      |//      |//      |//      |//      ↓//      y// dx[0]=0 dy[0]=1 那么代表向下的方向// dx[1]=1 dy[1]=0 那么代表向右的方向// dx[2]=-1 dy[0]=0 那么代表向左的方向// dx[3]=0 dy[1]=-1 那么代表向上的方向int n;// n 行int m;// m 列int k;// k 次queue&lt;PII &gt; q; //广度优先搜索所用的队列int len;//记录节点数量方便后续k的计算bool pd(int x, int y)&#123;    if(x&lt;1)        return 0;    // /x 轴坐标 左侧越界    else if(x&gt;n)        return 0;    //x 轴坐标 右侧越界    else  if(y&lt;1)        return 0;    //y 轴坐标 上侧越界    else if(y&gt;m)        return 0;    //y 轴坐标 下侧越界    else if(Map[x][y]==&#x27;g&#x27;)        return 0;    //已经长草了    else return 1;    // 在范围内，且没长草&#125;void BFS()&#123;    //BFS    while(!q.empty()&amp;&amp;k&gt;0)    &#123;        tempPair = q.front();        q.pop();        //这两步是取出队首的节点        int x = tempPair.first;//横坐标        int y = tempPair.second;//纵坐标        for(int i=0; i&lt;4; i++)        &#123;            int nowx = x+dx[i]; //扩展后的横坐标            int nowy = y+dy[i]; //扩展后的纵坐标            if(pd(nowx,nowy))            &#123;                q.push(&#123;nowx,nowy&#125;);                Map[nowx][nowy]=&#x27;g&#x27;;            &#125;            //符合要求执行扩展，不符合要求，忽略即可。        &#125;        len--; //没取出一个节点len  -1        if(len==0)        &#123;            //当len =0 时，代表当前层扩展完了，那么就代表第一个月扩展完了            k--; // 所以k--            len = q.size(); // 当前层扩展完了，那就该扩展下一层了，所以len又被赋值为下一层的节点数目的值        &#125;    &#125;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1; i&lt;=n; i++)    &#123;        for(int j=1; j&lt;=m; j++)        &#123;            cin&gt;&gt;Map[i][j];            if(Map[i][j]==&#x27;g&#x27;)            &#123;                tempPair.first=i;                tempPair.second=j;               // cout&lt;&lt;i&lt;&lt;&quot;&quot;&lt;&lt;j&lt;&lt;endl;                q.push(tempPair);//将初始有树的结点加入队列            &#125;        &#125;    &#125;    len = q.size();//记录第一层的节点数量方便后续k的计算    cin&gt;&gt;k;    BFS();    for(int i=1; i&lt;=n; i++)    &#123;        for(int j=1; j&lt;=m; j++)        &#123;            cout&lt;&lt;Map[i][j];        &#125;        cout&lt;&lt;endl;    &#125;    return 0;&#125;\n\nPython 语言描述:\n# 请在此输入您的代码from queue import Queuedx = [0, 1, -1, 0]dy = [1, 0, 0, -1]# 两两组合形成上下左右四个方向#      1------------------&gt; x#      |#      |#      |#      |#      |#      |#      |#      ↓#      y# dx[0]=0 dy[0]=1 那么代表向下的方向# dx[1]=1 dy[1]=0 那么代表向右的方向# dx[2]=-1 dy[0]=0 那么代表向左的方向# dx[3]=0 dy[1]=-1 那么代表向上的方向Map = []q = Queue()n = 0m = 0k = 0length = 0def pd(x, y):    global n, m, Map    if x &lt; 0:        return False    # x 轴坐标左侧越界    elif x &gt;= n:        return False    # x 轴坐标右侧越界    elif y &lt; 0:        return False    # y轴坐标上侧越界    elif y &gt;= m:        return False    # y 轴坐标下侧越界    elif Map[x][y] == &#x27;g&#x27;:        return False    # 已经长草了    else:        return True    # 在范围内，且没长草def BFS():    global k, q, n, m, Map, length    while k &gt; 0 &amp; (not q.empty()):        tempPair = q.get()        x = tempPair[0]  # 横坐标        y = tempPair[1]  # 纵坐标        nowx=x+1        if (pd(nowx, y)):            q.put((nowx, y))            Map[nowx][y] = &#x27;g&#x27;        nowx=x-1        if (pd(nowx, y)):            q.put((nowx, y))            Map[nowx][y] = &#x27;g&#x27;        nowy=y+1        if (pd(x, nowy)):            q.put((nowx, nowy))            Map[x][nowy] = &#x27;g&#x27;        nowy=y-1        if (pd(x, nowy)):            q.put((nowx, nowy))            Map[x][nowy] = &#x27;g&#x27;        length -= 1        if length == 0:            k -= 1            length = q.qsize()if __name__ == &#x27;__main__&#x27;:    n, m = map(int, input().split())    Map = [[0 for _ in range(m)] for _ in range(n)]  # Python 动态开数组会减少运行时间    for i in range(n):        input_ = input()        for j in range(m):            Map[i][j] = input_[j]            if Map[i][j] == &#x27;g&#x27;:                q.put((i, j))    k = int(input())    length = q.qsize()    BFS()    for i in range(n):        str_temp = &#x27;&#x27;        for j in range(m):            str_temp += Map[i][j]        print(str_temp)\n\n重点:\nPython 的 Queue 非常耗费时间，强烈建议大家使用 list 进行模拟\n下面是用 List 模拟，使用 Queue 耗时 3000 ms , 使用 list 模拟仅消耗 54 ms 所以大家使用 Python 编写代码的时候还是使用 List 尽量避免 Queue 的使用。\n# 请在此输入您的代码from queue import Queuedx = [0, 1, -1, 0]dy = [1, 0, 0, -1]# 两两组合形成上下左右四个方向#      1------------------&gt; x#      |#      |#      |#      |#      |#      |#      |#      ↓#      y# dx[0]=0 dy[0]=1 那么代表向下的方向# dx[1]=1 dy[1]=0 那么代表向右的方向# dx[2]=-1 dy[0]=0 那么代表向左的方向# dx[3]=0 dy[1]=-1 那么代表向上的方向Map = []q = []qfront = 0qend = 0n = 0m = 0k = 0length = 0def pd(x, y):    if x &lt; 0:        return False    # x 轴坐标左侧越界    elif x &gt;= n:        return False    # x 轴坐标右侧越界    elif y &lt; 0:        return False    # y轴坐标上侧越界    elif y &gt;= m:        return False    # y 轴坐标下侧越界    elif Map[x][y] == &#x27;g&#x27;:        return False    # 已经长草了    else:        return True    # 在范围内，且没长草def BFS():    global k, q, n, m, Map, length, qend, qfront    # print(&quot;K Length&quot;, k, length)    while k &gt; 0 and length &gt; 0:        tempPair = q[qfront]        qfront += 1        x = tempPair[0]  # 横坐标        y = tempPair[1]  # 纵坐标        for i in range(4):            nowx = x + dx[i]  # 扩展后的横坐标            nowy = y + dy[i]  # 扩展后的纵坐标            if (pd(nowx, nowy)):                q.append((nowx,nowy))                qend += 1                Map[nowx][nowy] = &#x27;g&#x27;        length -= 1        if length == 0:            k -= 1            length = qend - qfrontif __name__ == &#x27;__main__&#x27;:    n, m = map(int, input().split())    Map = [[0 for _ in range(m)] for _ in range(n)]  # Python 动态开数组会减少运行时间    for i in range(n):        input_ = input()        for j in range(m):            Map[i][j] = input_[j]            if Map[i][j] == &#x27;g&#x27;:                q.append((i,j))                qend += 1    k = int(input())    length = qend - qfront    BFS()    for i in range(n):        str_temp = &#x27;&#x27;        for j in range(m):            str_temp += Map[i][j]        print(str_temp)\n\nJava 语言描述:\nimport java.util.*;import java.util.concurrent.LinkedBlockingQueue;import static java.lang.Math.abs;public class Main &#123;    static final int M = 1005;    static class PII    &#123;        public int first;        public int second;    &#125;;    static String Map[]=new String[M];//---------图的路径搜索常用方向移动表示-------    static int dx[]= &#123;0,1,-1,0&#125;;    static  int dy[]= &#123;1,0,0,-1&#125;;// 两两组合形成上下左右四个方向//      1------------------&gt; x//      |//      |//      |//      |//      |//      |//      |//      ↓//      y// dx[0]=0 dy[0]=1 那么代表向下的方向// dx[1]=1 dy[1]=0 那么代表向右的方向// dx[2]=-1 dy[0]=0 那么代表向左的方向// dx[3]=0 dy[1]=-1 那么代表向上的方向    static int n;// n 行    static int m;// m 列    static int k;// k 次    static Queue&lt;PII &gt; q= new LinkedBlockingQueue&lt;&gt;();    //广度优先搜索所用的队列    static int len;//记录节点数量方便后续k的计算    static boolean pd(int x, int y)    &#123;        if(x&lt;1)            return false;            // /x 轴坐标 左侧越界        else if(x&gt;n)            return false;            //x 轴坐标 右侧越界        else  if(y&lt;1)            return false;            //y 轴坐标 上侧越界        else if(y&gt;m)            return false;            //y 轴坐标 下侧越界        else if(Map[x].charAt(y)==&#x27;g&#x27;)            return false;            //已经长草了        else return true;        // 在范围内，且没长草    &#125;    static void BFS()    &#123;        //BFS        while(q.size()!=0&amp;&amp;k&gt;0)        &#123;            PII tempPair= q.peek();            q.poll();            //这两步是取出队首的节点//            System.out.println(q.size());            int x = tempPair.first;//横坐标            int y = tempPair.second;//纵坐标            for(int i=0; i&lt;4; i++)            &#123;                int nowx = x+dx[i]; //扩展后的横坐标                int nowy = y+dy[i]; //扩展后的纵坐标                if(pd(nowx,nowy))                &#123;                    PII tempPair2=new PII();//临时结点                    tempPair2.first=nowx;                    tempPair2.second=nowy;                    q.add(tempPair2);                    StringBuilder strBuilder = new StringBuilder(Map[nowx]);                    strBuilder.setCharAt(nowy, &#x27;g&#x27;);                    Map[nowx]=strBuilder.toString();                &#125;                //符合要求执行扩展，不符合要求，忽略即可。            &#125;            len--; //没取出一个节点len  -1            if(len==0)            &#123;                //当len =0 时，代表当前层扩展完了，那么就代表第一个月扩展完了                k--; // 所以k--                len = q.size(); // 当前层扩展完了，那就该扩展下一层了，所以len又被赋值为下一层的节点数目的值            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        Scanner in = new Scanner(System.in);        n = in.nextInt();        m = in.nextInt();        for(int i=1; i&lt;=n; i++)        &#123;            Map[i]=new String(&quot; &quot; +in.next());            for(int j=1; j&lt;=m; j++)            &#123;                char temChar = Map[i].charAt(j);                if(temChar==&#x27;g&#x27;)                &#123;                    PII tempPair=new PII();//临时结点                    tempPair.first=i;                    tempPair.second=j;                    q.offer(tempPair);//将初始有草的结点加入队列                &#125;            &#125;        &#125;        len = q.size();//记录第一层的节点数量方便后续k的计算        k= in.nextInt();        BFS();        for(int i=1; i&lt;=n; i++)        &#123;            System.out.println(Map[i]);        &#125;    &#125;&#125;\n\n走迷宫题目链接\n难度: 简单\n标签: BFS\n题目描述:\n给定一个 ×N×M 的网格迷宫 G。G 的每个格子要么是道路，要么是障碍物（道路用 11 表示，障碍物用 00 表示）。\n已知迷宫的入口位置为 (1,1)(x1,y1)，出口位置为 (2,2)(x2,y2)。问从入口走到出口，最少要走多少个格子。\n输入:\n输入第 11 行包含两个正整数 ,N,M，分别表示迷宫的大小。\n接下来输入一个 ×N×M 的矩阵。若 ,&#x3D;1G**i,j&#x3D;1 表示其为道路，否则表示其为障碍物。\n最后一行输入四个整数 1,1,2,2x1,y1,x2,y2，表示入口的位置和出口的位置。\n1≤,≤1021≤N,M≤102，0≤,≤10≤G**i,j≤1，1≤1,2≤1≤x1,x2≤N，1≤1,2≤1≤y1,y2≤M。\n输出：\n输出仅一行，包含一个整数表示答案。\n若无法从入口到出口，则输出 −1−1。\n输入输出样例：\n输入\n5 51 0 1 1 01 1 0 1 10 1 0 1 11 1 1 1 11 0 0 0 11 1 5 5\n\n输出\n8\n\n运行限制:\n最大运行时间：1s最大运行内存: 128M\n\n解题思路:\n\n算法开始：\n我们以起点开始做 BFS ，将入口压入栈开始执行 BFS 算法\n\n判断边界：\n在当前行，当前列的位置上判断是否满足条件，若不满足，跳到第 5 步，即不符合边界条件。 判断条件如下：\n\n[][]vis[x][y] &gt;&#x3D; 1 标记数组已经被标记，已被走过，不能再走，超出边界\n&lt;1x&lt;1 从左侧走出方格\n\nx&gt;n 从右侧走出方格\n\n\n&lt;1y&lt;1 从上侧走出方格\n\ny&gt;n 从下侧走出方格\n\n\n[][]map[x][y] !&#x3D; 1 没有路不能走\n\n\n搜索过程：\n调用 Check 函数。\n如果边界条件满足，就继续调用搜索，找到下一步的位置\n每次找到下一个位置的时候，令其 [][]Vis[nextx][nexty] &#x3D; 当前 +1Vis+1\n这样既能用 vis 数组标记又能使用 vis 数组存步数，从 11 开始，即开始节点是 11 ，所以最后要减去 11 。\n\ncheck(参数)：\n如果当搜索到 &#x3D;终点x&#x3D;终点x, &#x3D;终点y&#x3D;终点y 时，就找到了终点，此时他的 Vis 数组就存储了他的步数，但是是从 11 开始的。\n\n\nC++ 语言描述:\n#include &lt;bits/stdc++.h&gt;using namespace std;int vis[150][150]; //用于存储是否访问过，并且存储长度char G[150][150]; //用于存储题目给出的地图int n,m,ans=0;int dx[4] = &#123;0,0,-1,1&#125;;int dy[4] = &#123;1,-1,0,0&#125;;//上下左右移动，不会的看前面的代码struct node&#123;    int x;    int y;&#125;;node Start,End;bool pd(int x,int y)&#123;    if(x&lt;1)        return 0;    //从左侧走出方格    else if(x&gt;n)        return 0;    //从右侧走出方格    else if(y&lt;1)        return 0;    //从上侧走出方格    else if(y&gt;m)        return 0;    //从下侧走出方格    else if( vis[x][y]!=0)        //已经访问了        return 0;    else if(G[x][y]!=&#x27;1&#x27;) return 0;    //不是路不能走    else return 1;&#125;bool  check(int x, int y)&#123;    if(x == End.x&amp;&amp; y == End.y)   //找到终点，把距离给他    &#123;        ans  =  vis[x][ y];        return 1;    &#125;    else    return 0;&#125;void bfs()&#123;    queue&lt;node&gt;q;    node now,next;    q.push(Start);     //将起点压人队列中    vis[Start.x][Start.y] = 1;    while(!q.empty())    &#123;        now = q.front();        if(check(now.x,now.y))            return ;        q.pop();     //将队列最前面的弹出。        for(int i=0; i&lt;4; i++)  //四个方向        &#123;            int nextx = now.x + dx[i];            int nexty = now.y + dy[i];            if(pd(nextx,nexty))  //判断是否符合条件            &#123;                next.x=nextx;                next.y=nexty;                q.push(next);                vis[nextx][nexty] = vis[now.x][now.y]+1; //步数+1            &#125;        &#125;    &#125;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    //memset(vis,0,sizeof(vis));    for(int i=1; i&lt;=n; i++)    &#123;        for(int j=1; j&lt;=m; j++)        &#123;            cin&gt;&gt;G[i][j];        &#125;    &#125;    cin&gt;&gt;Start.x&gt;&gt;Start.y&gt;&gt;End.x&gt;&gt;End.y;    ans = 0;    bfs();    cout&lt;&lt;ans-1&lt;&lt;endl;    return 0;&#125;\n\nPython 语言描述:\ndx = [0, 1, -1, 0]dy = [1, 0, 0, -1]G = []Vis = []# --------队列模拟-----------q = []                   # |                         # |qfront = 0               # |                         # |qend = 0                 # |# --------队列模拟-----------n = 0m = 0ans = 0startX=0startY=0endX=0endY=0def pd(x, y):    if x &lt; 1:        return False    # x 轴坐标左侧越界    elif x &gt; n:        return False    # x 轴坐标右侧越界    elif y &lt; 1:        return False    # y轴坐标上侧越界    elif y &gt; m:        return False    # y 轴坐标下侧越界    elif Vis[x][y]!=0:        return False    #已经访问了    elif G[x][y] != &#x27;1&#x27;:        return False    # 已经访问了    else:        return True    # 在范围内，且没长草def check( x,  y):    global ans    if x == endX and y == endY :  #找到终点，把距离给他        ans  =  Vis[x][y];        return True;    else   :        return False;def BFS():    global qend ,qfront    q.append((startX,startY))    qend+=1    Vis[startX][startY]=1    while qend-qfront!=0:        tempPair = q[qfront]        qfront+=1        x = tempPair[0]  # 横坐标        y = tempPair[1]  # 纵坐标        if check(x,y):            return        for i in range(4):            nowx = x + dx[i]  # 扩展后的横坐标            nowy = y + dy[i]  # 扩展后的纵坐标            if (pd(nowx, nowy)):                q.append((nowx,nowy))                qend+=1                Vis[nowx][nowy] = Vis[x][ y] + 1if __name__ == &#x27;__main__&#x27;:    n, m = map(int, input().split())    G = [[0 for _ in range(m+10)] for _ in range(n+10)]  # Python 动态开数组会减少运行时间    Vis = [[0 for _ in range(m+10)] for _ in range(n+10)]  # Python 动态开数组会减少运行时间    for i in range(n):        input_ = input().split()        for j in range(m):            G[i+1][j+1] = input_[j]    startX ,startY , endX ,endY = map(int, input().split())    BFS()    print(ans-1)\n\nJava 语言描述:\nimport java.util.*;import java.util.concurrent.LinkedBlockingQueue;import static java.lang.Math.abs;public class Main &#123;    static final int M = 1005;    static class node &#123;        public int x;        public int y;        public node(int x, int y) &#123;            this.x = x;            this.y = y;        &#125;    &#125;    static int n, m, ans = 0;    static int vis[][] = new int[150][150]; //用于存储是否访问过，并且存储长度    static int G[][] = new int[150][150];  //用于存储题目给出的地图    static node Start, End;//---------图的路径搜索常用方向移动表示-------    static int dx[] = &#123;0, 1, -1, 0&#125;;    static int dy[] = &#123;1, 0, 0, -1&#125;;    static Queue&lt;node&gt; q = new LinkedBlockingQueue&lt;&gt;();    //广度优先搜索所用的队列    static boolean pd(int x, int y) &#123;        if (x &lt; 1)            return false;            // /x 轴坐标 左侧越界        else if (x &gt; n)            return false;            //x 轴坐标 右侧越界        else if (y &lt; 1)            return false;            //y 轴坐标 上侧越界        else if (y &gt; m)            return false;            //y 轴坐标 下侧越界        else if (vis[x][y] != 0)            //已经访问了            return false;        else if (G[x][y] != 1)            //不能走            return false;        else return true;        // 在范围内，且没长草    &#125;    static boolean check(int x, int y) &#123;        if (x == End.x &amp;&amp; y == End.y)   //找到终点，把距离给他        &#123;            ans = vis[x][y];            return true;        &#125; else return false;    &#125;    static void BFS() &#123;        q.add(Start);        vis[Start.x][Start.y] = 1;        node now, next;        while (q.size() != 0) &#123;            now = q.peek();            if (check(now.x, now.y))                return;            q.poll();            //这两步是取出队首的节点            for (int i = 0; i &lt; 4; i++)  //四个方向            &#123;                int nextx = now.x + dx[i];                int nexty = now.y + dy[i];                if (pd(nextx, nexty))  //判断是否符合条件                &#123;                    next = new node(nextx, nexty);                    q.add(next);                    vis[nextx][nexty] = vis[now.x][now.y] + 1; //步数+1                &#125;            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        Scanner in = new Scanner(System.in);        n = in.nextInt();        m = in.nextInt();        for (int i = 1; i &lt;= n; i++) &#123;            for (int j = 1; j &lt;= m; j++) &#123;                G[i][j] = in.nextInt();            &#125;        &#125;        int startX = in.nextInt();        int startY = in.nextInt();        int endX = in.nextInt();        int endY = in.nextInt();        Start=new node(startX,startY);        End=new node(endX,endY);        BFS();        System.out.println(ans-1);    &#125;&#125;\n\n迷宫下图给出了一个迷宫的平面图，其中标记为 11 的为障碍，标记为 00 的为可以通行的地方。\n010000000100001001110000\n\n迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这个它的上、下、左、右四个方向之一。\n对于上面的迷宫，从入口开始，可以按 DRRURRDDDR 的顺序通过迷宫， 一共 1010 步。其中 、、、D、U、L、R 分别表示向下、向上、向左、向右走。 对于下面这个更复杂的迷宫（3030 行 5050 列），请找出一种通过迷宫的方式，其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。\n请注意在字典序中 &lt;&lt;&lt;D&lt;L&lt;R&lt;U。\n010101010010110010010101100101101001000010001010100000100010000010101001000010000000100110011010010101111011010010001000001101001011100011000000010000010000000010101000110100001010000010101010110010110001111100000010100001001010001010000010110000000011001000110101000010101100011010011010101011110111000110110101010010010010100000010001010011100000001010000010100010011010101011111001100001000011101000111000001010100001100010000001000101001100001001110001101000011100100010010101010101010100011010000001000010010000010100101010111010001010101000010111100100101001001000010000010101010100100100010100000000100000001010110011110100011000001010101000111010101001110000100001100001011001111011010000100010101010100001101010100101000010100000111011101001100000001011000100001011001011010010111000000001001010100100000001010010000100010000010001111010100100101001010101101001010100011010101101110000110101110010100001000011000000101001010000010001110000100000100011000011010110100000010010100100100001110110100101000101000000001110110010110101101010100001001010000100001101010100001000100010010001000101011010000100011001000100001010100101010101111101001000000100101000000110010100101001000001000000000010110100000010011101110010010000111010010110111010000000011010001000100010000000100001110100000011001110101000101000100010001111100010101001010000001000100000101001010010101100000001001010100010111010000011110000100001000000011011100000000100000000101110000001100111010111010001000110111010101101111000\n\n解题思路:\n本题是一道简单的搜索题，需要注意的是要按照题目给定的字典序进行搜索，最后输出路径。\n我们使用 BFS 搜索记录路径，用 DFS 打印路径。\nC++ 语言描述：\n#include&lt;bits/stdc++.h&gt;using namespace std;#define maxn 2000string maze[maxn]= &#123;                  &quot;01010101001011001001010110010110100100001000101010&quot;,                  &quot;00001000100000101010010000100000001001100110100101&quot;,                  &quot;01111011010010001000001101001011100011000000010000&quot;,                  &quot;01000000001010100011010000101000001010101011001011&quot;,                  &quot;00011111000000101000010010100010100000101100000000&quot;,                  &quot;11001000110101000010101100011010011010101011110111&quot;,                  &quot;00011011010101001001001010000001000101001110000000&quot;,                  &quot;10100000101000100110101010111110011000010000111010&quot;,                  &quot;00111000001010100001100010000001000101001100001001&quot;,                  &quot;11000110100001110010001001010101010101010001101000&quot;,                  &quot;00010000100100000101001010101110100010101010000101&quot;,                  &quot;11100100101001001000010000010101010100100100010100&quot;,                  &quot;00000010000000101011001111010001100000101010100011&quot;,                  &quot;10101010011100001000011000010110011110110100001000&quot;,                  &quot;10101010100001101010100101000010100000111011101001&quot;,                  &quot;10000000101100010000101100101101001011100000000100&quot;,                  &quot;10101001000000010100100001000100000100011110101001&quot;,                  &quot;00101001010101101001010100011010101101110000110101&quot;,                  &quot;11001010000100001100000010100101000001000111000010&quot;,                  &quot;00001000110000110101101000000100101001001000011101&quot;,                  &quot;10100101000101000000001110110010110101101010100001&quot;,                  &quot;00101000010000110101010000100010001001000100010101&quot;,                  &quot;10100001000110010001000010101001010101011111010010&quot;,                  &quot;00000100101000000110010100101001000001000000000010&quot;,                  &quot;11010000001001110111001001000011101001011011101000&quot;,                  &quot;00000110100010001000100000001000011101000000110011&quot;,                  &quot;10101000101000100010001111100010101001010000001000&quot;,                  &quot;10000010100101001010110000000100101010001011101000&quot;,                  &quot;00111100001000010000000110111000000001000000001011&quot;,                  &quot;10000001100111010111010001000110111010101101111000&quot;&#125;;bool vis[maxn][maxn];//标记int dir[4][2]=&#123;&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,0&#125;&#125;;//D L R Ubool in(int x,int y)&#123;    return x&lt;30&amp;&amp;x&gt;=0&amp;&amp;y&gt;=0&amp;&amp;y&lt;50;&#125;struct node&#123;    int x,y,d;    char pos;//存储D L R U&#125;;node father[maxn][maxn];//当前节点的父节点node now,nex;//指向当前和下一个位置void dfs(int x,int y)//递归打印&#123;    if(x==0&amp;&amp;y==0)//找到起点开始正向打印路径        return;    else        dfs(father[x][y].x,father[x][y].y);    cout&lt;&lt;father[x][y].pos;&#125;void bfs(int x,int y)&#123;    queue&lt;node&gt; q;    now.x=x;    now.y=y;    now.d=0;    q.push(now);    vis[x][y]=true;    while(!q.empty())    &#123;        now=q.front();        q.pop();        for(int i=0;i&lt;4;i++)//走下左右上按字典序的四个方向        &#123;            int tx=now.x+dir[i][0];            int ty=now.y+dir[i][1];            if(in(tx,ty)&amp;&amp;!vis[tx][ty]&amp;&amp;maze[tx][ty]!=&#x27;1&#x27;)//判断是否超出范围，是否用过，是否为1            &#123;                vis[tx][ty]=true;//标记为用过                nex.x=tx;                nex.y=ty;                nex.d=now.d+1;                q.push(nex);//压入队列                father[tx][ty].x=now.x;//存储父节点坐标                father[tx][ty].y=now.y;                if(i==0)//存储路径                    father[tx][ty].pos=&#x27;D&#x27;;                else if(i==1)                    father[tx][ty].pos=&#x27;L&#x27;;                else if(i==2)                    father[tx][ty].pos=&#x27;R&#x27;;                else if(i==3)                    father[tx][ty].pos=&#x27;U&#x27;;            &#125;        &#125;    &#125;&#125;int main()&#123;    bfs(0,0);    dfs(29,49);//打印路径    return 0;&#125;\n\nJava 语言描述:\nimport java.util.*;public class Main &#123;    private static String[] nn= &#123;                  &quot;01010101001011001001010110010110100100001000101010&quot;,                  &quot;00001000100000101010010000100000001001100110100101&quot;,                  &quot;01111011010010001000001101001011100011000000010000&quot;,                  &quot;01000000001010100011010000101000001010101011001011&quot;,                  &quot;00011111000000101000010010100010100000101100000000&quot;,                  &quot;11001000110101000010101100011010011010101011110111&quot;,                  &quot;00011011010101001001001010000001000101001110000000&quot;,                  &quot;10100000101000100110101010111110011000010000111010&quot;,                  &quot;00111000001010100001100010000001000101001100001001&quot;,                  &quot;11000110100001110010001001010101010101010001101000&quot;,                  &quot;00010000100100000101001010101110100010101010000101&quot;,                  &quot;11100100101001001000010000010101010100100100010100&quot;,                  &quot;00000010000000101011001111010001100000101010100011&quot;,                  &quot;10101010011100001000011000010110011110110100001000&quot;,                  &quot;10101010100001101010100101000010100000111011101001&quot;,                  &quot;10000000101100010000101100101101001011100000000100&quot;,                  &quot;10101001000000010100100001000100000100011110101001&quot;,                  &quot;00101001010101101001010100011010101101110000110101&quot;,                  &quot;11001010000100001100000010100101000001000111000010&quot;,                  &quot;00001000110000110101101000000100101001001000011101&quot;,                  &quot;10100101000101000000001110110010110101101010100001&quot;,                  &quot;00101000010000110101010000100010001001000100010101&quot;,                  &quot;10100001000110010001000010101001010101011111010010&quot;,                  &quot;00000100101000000110010100101001000001000000000010&quot;,                  &quot;11010000001001110111001001000011101001011011101000&quot;,                  &quot;00000110100010001000100000001000011101000000110011&quot;,                  &quot;10101000101000100010001111100010101001010000001000&quot;,                  &quot;10000010100101001010110000000100101010001011101000&quot;,                  &quot;00111100001000010000000110111000000001000000001011&quot;,                  &quot;10000001100111010111010001000110111010101101111000&quot;&#125;;    private static char[][] tu=new char[30][50];    private static int[][] dis=new int[30][50];    private static int[][] step= &#123;&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,0&#125;&#125;;    private static char[] direction= &#123;&#x27;D&#x27;,&#x27;L&#x27;,&#x27;R&#x27;,&#x27;U&#x27;&#125;;//    保存经过的每一个点位置信息，采用(x)*m+y的公式表示(x,y);x,y从0开始，位置也是从来开始。m:大于最长边的随便一个数//    起点:0;终点:29*50-49    private static Queue&lt;Integer&gt; location=new LinkedList&lt;Integer&gt;();//    广度优先遍历求每一个位置到终点的距离，并存放在dis中//    广度优先遍历寻找所有从终点到起点的路线    public static void bfs() &#123;//x,y当前位置;        int x,y;//当前位置坐标        //不为空，继续循环        while(!location.isEmpty()) &#123;            int l=location.poll();//获取当前位置的坐标            x=l/50;//获取当前位置x            y=l%50;//获取当前位置y            for(int i=0;i&lt;4;i++) &#123;//探索四个方向                int xx=x+step[i][0];                int yy=y+step[i][1];                if(xx&gt;=0&amp;&amp;xx&lt;30&amp;&amp;yy&gt;=0&amp;&amp;yy&lt;50&amp;&amp;tu[xx][yy]==&#x27;0&#x27;&amp;&amp;dis[xx][yy]==0) &#123;                    dis[xx][yy]=dis[x][y]+1;//当前位置的距离+1等于本次探索位置的距离                    location.add(xx*50+yy);                    if(xx==0&amp;&amp;yy==0) &#123;                        break;                    &#125;                &#125;            &#125;        &#125;    &#125;//    深度优先遍历，从起点到终点    public static String dfs() &#123;        dis[29][49]=0;//        起点        int x=0;        int y=0;        String route=&quot;&quot;;        while(x!=29||y!=49) &#123;            for(int i=0;i&lt;4;i++) &#123;                int xx=x+step[i][0];                int yy=y+step[i][1];                if(xx&gt;=0&amp;&amp;xx&lt;30&amp;&amp;yy&gt;=0&amp;&amp;yy&lt;50&amp;&amp;tu[xx][yy]==&#x27;0&#x27;) &#123;                    if(dis[x][y]==dis[xx][yy]+1) &#123;                        x=xx;                        y=yy;                        route+=direction[i];                        break;                    &#125;                &#125;            &#125;        &#125;        return route;    &#125;    public static void main(String[] args) &#123;        long num=0;        for(int i=0;i&lt;30;i++) &#123;            tu[i]=nn[i].toCharArray();        &#125;        location.add(29*50+49);        bfs();        String route=dfs();        System.out.println(route);    &#125;&#125;\n\nPython 语言描述:\nfrom collections import dequen,m=30,50M=[[int(i) for i in input()]for j in range(n)]vis=[[0]*m for i in range(n)]go=[[&#x27;&#x27;]*m for i in range(n)]q=deque([(0,0)])vis[0][0]=1while q:    x,y=q.popleft()    if x==n-1 and y==m-1:        print(go[-1][-1])        break    for i,j,k in [[1,0,&#x27;D&#x27;],[0,-1,&#x27;L&#x27;],[0,1,&#x27;R&#x27;],[-1,0,&#x27;U&#x27;]]:        a,b=x+i,y+j        if 0&lt;=a&lt;n and 0&lt;=b&lt;m and M[a][b]==0 and vis[a][b]==0:            vis[a][b]=1            q.append((a,b))            go[a][b]=go[x][y]+k\n\n实验总结BFS 是广度优先搜索，是将某节点所有的“枝蔓”加入搜索队列，然后去除队列的首部的节点，重复进行该动作，这样就能由开始状态“一圈一圈的查找”。 BFS 拥有一个性质，那么就是先找到的节点，所经过的步骤一定最短。它一般用于寻找在近的状态，也是一个非常基础的算法，希望大家认真学习。\n","categories":["蓝桥杯冲刺营","3.搜索算法"],"tags":["蓝桥杯备赛"]},{"title":"枚举","url":"/2024/02/21/%E6%9E%9A%E4%B8%BE/","content":"\n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"桶排序","url":"/2024/02/21/%E6%A1%B6%E6%8E%92%E5%BA%8F/","content":"\n","categories":["蓝桥杯","第二章：基础算法","排序"],"tags":["蓝桥杯备赛"]},{"title":"模拟","url":"/2024/02/21/%E6%A8%A1%E6%8B%9F/","content":"\n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"离散化","url":"/2024/02/21/%E7%A6%BB%E6%95%A3%E5%8C%96/","content":"\n\n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"类的定义和使用","url":"/2024/02/21/%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/","content":"\n","categories":["蓝桥杯","第一章：语言基础","类的定义和使用"],"tags":["蓝桥杯备赛"]},{"title":"线性DP","url":"/2024/02/22/%E7%BA%BF%E6%80%A7DP/","content":"\n","categories":["蓝桥杯","第四章：动态规划","动态规划基础"],"tags":["蓝桥杯备赛"]},{"title":"自上而下树形DP","url":"/2024/02/22/%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E6%A0%91%E5%BD%A2DP/","content":"\t本节内容属于算法提高知识，由专属金牌选手录制，由于视频时长有限，所以视频中例题讲解主要以 C++ 为主讲解，大家可正常学习。算法思维是共通的，例题的其他语言解题代码，我们也在下方提供了，大家可以参考哦～\n\nC++\n\n#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 110000int n, val[maxn];struct Edge&#123;    int nex, to;&#125;edge[maxn &lt;&lt; 1];int head[maxn], cnt;int f[maxn][2];void add(int from, int to)&#123;    edge[++cnt].nex = head[from];    head[from] = cnt;    edge[cnt].to = to;    return ;&#125;void dfs(int u, int fa)&#123;    for (int i = head[u]; i; i = edge[i].nex)    &#123;        int v = edge[i].to;        if (v != fa)            continue;        dfs(v, u);        f[u][0] += max(f[v][0], f[v][1]);        f[u][1] += f[v][0];    &#125;    return ;&#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; ++ i )        scanf(&quot;%d&quot;, &amp;val[i]), f[i][1] = val[i];    for (int i = 1; i &lt; n; ++ i )    &#123;        int u, v;        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);        add(u, v), add(v, u);    &#125;    dfs(1, 0);    printf(&quot;%d\\n&quot;, max(f[1][0], f[1][1]));    return 0;&#125;\n\n\nJava\n\nimport java.util.Scanner;public class TreeDP &#123;    static final int maxn = 110000;    static int n;    static int[] val = new int[maxn];    static Edge[] edges = new Edge[maxn &lt;&lt; 1];    static int[] head = new int[maxn];    static int cnt;    static int[][] f = new int[maxn][2];    static class Edge &#123;        int next, to;        Edge(int next, int to) &#123;            this.next = next;            this.to = to;        &#125;    &#125;    public static void add(int from, int to) &#123;        edges[++cnt] = new Edge(head[from], to);        head[from] = cnt;    &#125;    public static void dfs(int u, int fa) &#123;        for (int i = head[u]; i != 0; i = edges[i].next) &#123;            int v = edges[i].to;            if (v == fa)                continue;            dfs(v, u);            f[u][0] += Math.max(f[v][0], f[v][1]);            f[u][1] += f[v][0];        &#125;    &#125;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        n = sc.nextInt();        for (int i = 1; i &lt;= n; ++i) &#123;            val[i] = sc.nextInt();            f[i][1] = val[i];        &#125;        for (int i = 1; i &lt; n; ++i) &#123;            int u = sc.nextInt();            int v = sc.nextInt();            add(u, v);            add(v, u);        &#125;        dfs(1, 0);        System.out.println(Math.max(f[1][0], f[1][1]));        sc.close();    &#125;&#125;\n\n\nPython\n\nfrom collections import defaultdictn = int(input())val = [0] + [int(x) for x in input().split()]edges = defaultdict(list)f = [[0, val[i]] for i in range(n + 1)]def add_edge(from_node, to_node):    edges[from_node].append(to_node)def dfs(u, fa):    for v in edges[u]:        if v == fa:            continue        dfs(v, u)        f[u][0] += max(f[v][0], f[v][1])        f[u][1] += f[v][0]for _ in range(n - 1):    u, v = map(int, input().split())    add_edge(u, v)    add_edge(v, u)dfs(1, 0)print(max(f[1][0], f[1][1]))\n\n\nC++\n\n#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 110int n, v;int f[maxn][maxn];int w[maxn], v[maxn];vector&lt;int&gt; g[maxn];struct Edge&#123;    int nex, to;&#125;edge[maxn &lt;&lt; 1];int head[maxn], cnt;void add(int from, int to)&#123;    edge[++ cnt].nex = head[from];    head[from] = cnt;    edge[cnt.to] = to;    return ;&#125;void dfs(int u, int fa)&#123;    memset(f[u], -0x3f, sizeof f[u]);    if (v[u] &lt;= V)        f[u][v[u]] = w[u];    for (int i = head[u]; i; i = edge[i].nex)    &#123;        int v = edge[i].to;        if (v == fa)            continue;        dfs(v, u);        vector&lt;int&gt; nf(f[u], f[u] + V + 1);        for (int v1 = 0; v1 &lt;= V; v1 ++)        &#123;            for (int v2 = 0; v1 + v2 &lt;= V; v2 ++ )            &#123;                nf[v1 + v2] = max(nf[v1 + v2], f[u][v1] + f[v][v2]);            &#125;        &#125;        for (int v = 0; v &lt;= V; v ++ )            f[u][v] = nf[v];    &#125;    return ;&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;v);    for (int i = 1; i &lt; n; ++ i )    &#123;        int u, v;        add(u, v), add(v, u);    &#125;    dfs(1, 0);    int ans = 0;    for (int i = 0; i &lt;= V; ++ i )        ans = max(ans, f[1][i]);    cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;\n\n\nJava\n\nimport java.util.Scanner;import java.util.Arrays;import java.util.ArrayList;import java.util.List;public class TreeDP &#123;    static final int maxn = 110;    static int n, V;    static int[][] f = new int[maxn][maxn];    static int[] w = new int[maxn], val = new int[maxn];    static List&lt;Integer&gt;[] g = new ArrayList[maxn];    static Edge[] edges = new Edge[maxn &lt;&lt; 1];    static int[] head = new int[maxn];    static int cnt;    static class Edge &#123;        int next, to;        Edge(int next, int to) &#123;            this.next = next;            this.to = to;        &#125;    &#125;    public static void add(int from, int to) &#123;        edges[++cnt] = new Edge(head[from], to);        head[from] = cnt;    &#125;    public static void dfs(int u, int fa) &#123;        Arrays.fill(f[u], Integer.MIN_VALUE);        if (val[u] &lt;= V)            f[u][val[u]] = w[u];        for (int i = head[u]; i != 0; i = edges[i].next) &#123;            int v = edges[i].to;            if (v == fa)                continue;            dfs(v, u);            int[] nf = Arrays.copyOf(f[u], V + 1);            for (int v1 = 0; v1 &lt;= V; v1++) &#123;                for (int v2 = 0; v1 + v2 &lt;= V; v2++) &#123;                    nf[v1 + v2] = Math.max(nf[v1 + v2], f[u][v1] + f[v][v2]);                &#125;            &#125;            for (int v = 0; v &lt;= V; v++)                f[u][v] = nf[v];        &#125;    &#125;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        n = sc.nextInt();        V = sc.nextInt();        for (int i = 1; i &lt;= n; ++i) &#123;            w[i] = sc.nextInt(); // Assuming input for weights w is provided            val[i] = sc.nextInt(); // Assuming input for values val is provided            g[i] = new ArrayList&lt;&gt;();        &#125;        for (int i = 1; i &lt; n; ++i) &#123;            int u = sc.nextInt();            int v = sc.nextInt();            add(u, v);            add(v, u);        &#125;        dfs(1, 0);        int ans = 0;        for (int i = 0; i &lt;= V; ++i)            ans = Math.max(ans, f[1][i]);        System.out.println(ans);        sc.close();    &#125;&#125;\n\n\nPython\n\nfrom collections import defaultdictimport sysn, V = map(int, input().split())w = [0] + [int(x) for x in input().split()]val = [0] + [int(x) for x in input().split()]edges = defaultdict(list)f = [[float(&#x27;-inf&#x27;) for _ in range(V+1)] for _ in range(n+1)]def add_edge(from_node, to_node):    edges[from_node].append(to_node)def dfs(u, fa):    f[u] = [float(&#x27;-inf&#x27;)] * (V+1)    if val[u] &lt;= V:        f[u][val[u]] = w[u]    for v in edges[u]:        if v == fa:            continue        dfs(v, u)        nf = f[u][:]        for v1 in range(V + 1):            for v2 in range(V - v1 + 1):                nf[v1 + v2] = max(nf[v1 + v2], f[u][v1] + f[v][v2])        f[u] = nffor _ in range(n - 1):    u, v = map(int, input().split())    add_edge(u, v)    add_edge(v, u)dfs(1, 0)ans = max(f[1])print(ans)\n","categories":["蓝桥杯","第四章：动态规划","树形DP"],"tags":["蓝桥杯备赛"]},{"title":"自定义排序","url":"/2024/02/21/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/","content":"\n","categories":["蓝桥杯","第一章：语言基础","实践应用"],"tags":["蓝桥杯备赛"]},{"title":"贪心","url":"/2024/02/21/%E8%B4%AA%E5%BF%83/","content":"  \n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"蓝桥杯知识记录","url":"/2024/02/21/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/","content":"\n","categories":["蓝桥杯","A学习路线"],"tags":["蓝桥杯学习路线"]},{"title":"选择排序","url":"/2024/02/21/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","content":"\n","categories":["蓝桥杯","第二章：基础算法","排序"],"tags":["蓝桥杯备赛"]},{"title":"进制转换","url":"/2024/02/21/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/","content":"\n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"递归","url":"/2024/02/21/%E9%80%92%E5%BD%92/","content":"\n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"递归与递推","url":"/2024/02/22/%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E6%8E%A8/","content":"递推法与递归法递推法：\n递推法是一种在数学和其他领域广泛应用的重要方法，它在计算机科学中被用作一种关键的数值求解算法。\n知识点：\n\n递推算法\n递归算法\n\n递推算法的特点递推法的核心在于找到递推关系式。这种方法可以将复杂的计算过程转化为简单的重复步骤，充分利用计算机在运行程序时的时间局部性和空间局部性。\n递推算法的思想：\n\n首先找到各个相邻数据项之间的递推关系；\n递推关系避开了求通项公式的麻烦，尤其是对于那些难以或无法求解通项公式的题目；\n将复杂问题分解为若干步骤的简单运算；\n一般来说，递推算法可以视为一种特殊的迭代算法。\n\n递推算法解题的基本思路：\n\n将复杂计算转换为简单重复运算；\n通过找到递推关系式进行简化运算；\n利用计算机的特性，减少运行时间。\n\n递推算法的一般步骤：\n\n根据题目确定数据项，并找到符合要求的递推关系式；\n根据递推关系式设计递推程序；\n根据题目找到递推的终点；\n单次查询可以不进行存储，多次查询都要进行存储；\n按要求输出答案即可。\n\n递归算法：\n递归算法是一种自顶向下的算法，它通过不断地直接或间接调用自身的函数，通过每次改变变量完成多个过程的重复计算，直到到达边界之后，结束调用。\n与递推法相似的是，递归与递推都是将一个复杂过程分解为几个简单重复步骤进行计算。\n递归算法的实现的核心是分治策略，即分而治之，将复杂过程分解为规模较小的同类问题，通过解决若干个小问题，进而解决整个复杂问题。\n递归算法的思想：\n\n将复杂计算过程转换为简单重复子过程；\n找到递归公式，即能够将大问题转化为小问题的公式；\n自上而下计算，在返回完成递归过程。\n\n递归算法设计的一般步骤：\n\n根据题目设计递归函数中的运算部分；\n根据题目找到递归公式，题目可能会隐含给出，也可能需要自己进行推导；\n找到递归出口，即递归的终止条件。\n\n递归法和递推法的思路已经给大家讲解得差不多了，接下来我们将结合真实的大赛题目进行讲解。这将有助于我们更好地理解和应用这两种方法。\n斐波纳契数列 fibonacci 问题在一定情况下，同一个问题可以使用用递归也可以使用递推解答。一般一个问题的递推关系和递归关系都好求的话就都可以解题。\n当然如果题目只有一个关系好求，那就最好采用关系好求的办法。\n题目描述:\n斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”。\n指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、…0、1、1、2、3、5、8、13、21、34、…\n在数学上，斐波那契数列以如下被以递推的方法定义：(0)&#x3D;0F(0)&#x3D;0，(1)&#x3D;1F(1)&#x3D;1，()&#x3D;(−1)+(−2)F(n)&#x3D;F(n−1)+F(n−2)（≥2，∈∗n≥2，n∈N∗）\n请求出该数列中第 n 个数字（n 从11开始计数）是多少。\n样例:\n输入样例样例1输入6样例2输入4输出样例样例1输出8样例2输出3\n\n对于上面的样例我们进行了如下计算；\n[0]=0[1]=1[2]=0+1[3]=1+1=2[4]=1+2=3[5]=2+3=5[6]=5+3=8\n\n运行限制:\n1. 最大运行时间：1s2. 最大运行内存：128M\n\n题目解析：\n\n这个题给出递推式 ()&#x3D;(−1)+(−2)F(n)&#x3D;F(n−1)+F(n−2)\n转化为可用的递推关系，即()+(+1)&#x3D;(+2)F(n)+F(n+1)&#x3D;F(n+2)\n\n这一通过从 &#x3D;1n&#x3D;1 开始循环即可完成递推，当然也可以使用递归法。\n首先我们写找出递归式，()&#x3D;(−1)+(−2)F(n)&#x3D;F(n−1)+F(n−2)。\nF(n)= F(n-1) + F(n-2)    = F(n-2)+F(n-3)+F(n-3)+F(n-4)//重复调用\n\n这样我们找到了递归式，然后我们应该找到递归出口。\n我们可以知道 ()&#x3D;0&#x3D;0,()&#x3D;1&#x3D;1F(n)&#x3D;0n&#x3D;0,F(n)&#x3D;1n&#x3D;1 这就是递归出口，能让递归停止的条件。\n递归算法的通用框架如下：\ndo(a,b,c...)&#123;    //递归终止条件，即出口    if(a==? ,b==? ,....) return    //递归条件    if(条件1)        do(参数1)    else(条件2)        do(参数2)&#125;如本题，各子式间存在计算关系，可以化为：do(a)&#123;    if(a==0) return 0;    if(a==1) return 1;    return do(a-1)+do(a-2);&#125;\n\n这道题不是多次询问问题，不需要存储直接计算的复杂度是最低的。\n答案解析C++ 代码：\n\n递推算法代码\n\n#include &lt;iostream&gt;using namespace std;int main()&#123;    int n; //第几个数    int x=0; //F(n)    int y=1; //F(n+1)    int ans; //F(n+2）    cin&gt;&gt;n;    if(n==0) ans=0;    else if(n==1) ans=1;    else &#123;        for(int i=2;i&lt;=n;i++)        &#123;            ans=x+y;            x=y;            y=ans;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n\n\n递归算法代码\n\n#include &lt;iostream&gt;using namespace std;int fn(int n)&#123;    //递归出口1    if(n==0)        return 0;    //递归出口2    else if(n==1 )        return 1;    else        return fn(n-1)+fn(n-2); //递归关系式&#125;int main()&#123;    int n; //第几个数    int ans;    cin&gt;&gt;n;    ans=fn(n);    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n\nPython 解题代码\n\n递推算法代码：\n\nif __name__ == &#x27;__main__&#x27;:    n =int( input())    x=0 # F(n)    y=1 #F(n+1)    ans=0 #F(n+2）    if n==0 :        ans=0    elif n==1:        ans=1    else:        for i in range (n-1):            ans=x+y            x=y            y=ans    print(ans)\n\n\n递归算法代码：\n\ndef f(n):    # 递归出口1    if n == 0:        return 0    # 递归出口2    elif n == 1:        return 1    else:        return f(n - 1) + f(n - 2)  # 递归关系式if __name__ == &#x27;__main__&#x27;:    n = int(input())    ans = f(n)    print(ans)\n\nJava 解题代码\n递推算法：\nimport java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        int n; //第几个数        int x=0; //F(n)        int y=1; //F(n+1)        int ans = 0; //F(n+2）        Scanner in = new Scanner(System.in);        n = in.nextInt();        if(n==0) ans=0;        else if(n==1) ans=1;        else &#123;            for(int i=2;i&lt;=n;i++)            &#123;                ans=x+y;                x=y;                y=ans;            &#125;        &#125;        System.out.println(ans);    &#125;&#125;\n\n递归算法代码：\nimport java.util.Scanner;public class Main &#123;    static  int fn(int n)    &#123;        if(n==0)            return 0;            //递归出口2        else if(n==1 )            return 1;        else            return fn(n-1)+fn(n-2); //递归关系式    &#125;    public static void main(String[] args) &#123;        int n; //第几个数        int ans = 0;        Scanner in = new Scanner(System.in);        n = in.nextInt();        ans=fn(n);        System.out.println(ans);    &#125;&#125;\n\n存储型的递推与递归我们在开始就讲过题目十分存储和非存储的，上面那个题目就是此询问，如果改为多次询问我们该怎么办，我们会采用存储的方式，存储的方式适用于大部分的的多次查询问题。\n我们看一下修改后的题目。\n题目描述：\n斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”。\n指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、…0、1、1、2、3、5、8、13、21、34、…\n在数学上，斐波那契数列以如下被以递推的方法定义：(0)&#x3D;0F(0)&#x3D;0，(1)&#x3D;1F(1)&#x3D;1，()&#x3D;(−1)+(−2)F(n)&#x3D;F(n−1)+F(n−2)（≥2，∈∗n≥2，n∈N∗）\n我们将进行M次查询，每次输入一个N，其中n小于3030。\n请求出该数列中第n个数字（n从11开始计数）是多少?\n样例:\n输入样例样例1输入：64278810样例2输入：81323141724161011输出样例样例1输出：3113212155样例2输出：233286573771597463689875589\n\n运行限制:\n1. 最大运行时间：1s2. 最大运行内存：128M\n\n题目解析：\n这道题跟上面一道题的算法原理相同，只是增加了多次查询的复杂度，所以仅需修改这一点即可。\n再有的是有的同学担心自己的输入输出是在一个屏幕上的，评测的时候会不会出现问题。\n\n类似这样的情况，这一点是不用担心的，只要不是交互题，评测机的输入与输出是分开的，只有你的输出会用来跟答案比较，所以我们只用关心我们的输出即可。\n比如有一道题让你计算 +x+y 的值，如果你知道每答案，就可以直接输出，都不用进行读入。\n然后我们来看一下需要多次询问的题目该怎么解决。\n答案解析C++ 代码：\n\n递推算法代码\n\n#include &lt;iostream&gt;using namespace std;int F[35];void init()&#123;    F[0]=0;    F[1]=1;    for(int i=2;i&lt;=30;i++)    &#123;        F[i]=F[i-1]+F[i-2];    &#125;&#125;int main()&#123;    int m; //m次查询    int n; //第几个数    init();    cin&gt;&gt;m;    while(m&gt;0)&#123;        m-=1;        cin&gt;&gt;n;        cout&lt;&lt;F[n]&lt;&lt;endl;    &#125;&#125;\n\n存储答案的递推法，才是最常使用的递推法。\n\n递归算法代码\n\n#include &lt;iostream&gt;using namespace std;int F[35];int fn(int n)&#123;    //递归出口1    if(n==0)    &#123;        F[0]=0;        return 0;    &#125;    //递归出口2    else if(n==1 )    &#123;        F[1]=1;        return 1;    &#125;    else    &#123;        F[n]=fn(n-1)+fn(n-2);        return F[n]; //递归关系式    &#125;&#125;int main()&#123;    int m; //m次查询    int n; //第几个数    fn(30);    cin&gt;&gt;m;    while(m&gt;0)&#123;        m-=1;        cin&gt;&gt;n;        cout&lt;&lt;F[n]&lt;&lt;endl;    &#125;&#125;\n\nPython 解题代码\n递推算法代码：\nF = [0]*35def init():    F[0] = 0    F[1] = 1    for i in range(2, 30):        F[i] = F[i-1]+F[i-2]if __name__ == &#x27;__main__&#x27;:    m = int(input())    init()    while m &gt; 0:        m -= 1        n = int(input())        print(F[n])    # print(F)\n\n递归算法代码：\nF = [0] * 35def f(n):    # 递归出口1    if n == 0:        F[0] = 0        return 0    # 递归出口2    elif n == 1:        F[1] = 1        return 1    else:        F[n] = f(n - 1) + f(n - 2) # 递归关系式        return F[n]if __name__ == &#x27;__main__&#x27;:    m = int(input())    f(30)    while m &gt; 0:        m -= 1        n = int(input())        print(F[n])    # print(F)\n\nJava 解题代码\n递推算法：\nimport java.util.Scanner;public class Main &#123;    static int []F=new int [35];    static  void init()    &#123;        F[0]=0;        F[1]=1;        for(int i=2;i&lt;=30;i++)        &#123;            F[i]=F[i-1]+F[i-2];        &#125;    &#125;    public static void main(String[] args) &#123;        int m; //m次查询        int n; //第几个数        init();        Scanner in = new Scanner(System.in);        m = in.nextInt();        while(m&gt;0)&#123;            m-=1;            n= in.nextInt();            System.out.println(F[n]);        &#125;    &#125;&#125;\n\n递归算法代码：\npackage com.company;import java.util.Scanner;public class Main &#123;    static int []F=new int [35];    static int fn(int n)    &#123;        //递归出口1        if(n==0)        &#123;            F[0]=0;            return 0;        &#125;        //递归出口2        else if(n==1 )        &#123;            F[1]=1;            return 1;        &#125;        else        &#123;            F[n]=fn(n-1)+fn(n-2);            return F[n]; //递归关系式        &#125;    &#125;    public static void main(String[] args) &#123;        int m; //m次查询        int n; //第几个数        fn(30);        Scanner in = new Scanner(System.in);        m = in.nextInt();        while(m&gt;0)&#123;            m-=1;            n= in.nextInt();            System.out.println(F[n]);        &#125;    &#125;&#125;\n\n数字三角形问题题目描述:\n\n如图数字三角形。如下所示为一个数字三角形。请编一个程序计算从顶到底的某处的一条路径，使该路径所经过的数字总和最大。只要求输出总和。 　\n\n一步可沿左斜线向下或右斜线向下走；\n三角形行数小于等于 100100；\n三角形中的数字为 0，1，…，990，1，…，99；\n\n测试数据通过键盘逐行输入。\n如上例数据应以样例所示格式输入：\n样例:\n输入：573 88 1 02 7 4 44 5 2 6 5输出：30\n\n运行限制:\n1. 最大运行时间：1s2. 最大运行内存：128M\n\n题目分析:\n解决该题目的方式有很多，包括动态规划， 枚举都可以解决这个问题。\n我们从递推的思想出发，假设我们从顶层沿着某条路径已经走到了第 i 层，正向着 +1i+1 层前进， 两条可行路径中我们肯定会选择最大的方向前进，为此我们可以采用递推中的反向递推，即逆推的方式解决，设 [][]a[i][j] 存放从 ,i,j 出发到达第 n 层的最大值。\n我们可以写出递推式：\na[i][j] = max&#123;a[i][j]+a[i+1][j]，a[i][j]+a[i+1][j+1]&#125;\n\n则 逆推到出发点 [1][1]a[1][1] 为题目所求答案，即第一层到第 N 层的最大值。\n答案解析C++ 代码：\n#include&lt;iostream&gt;using namespace std;int main()&#123;    int n; //n层    int a[101][101]; //路径矩阵    cin&gt;&gt;n;    //输入数字三角形的值    for (int i=1; i&lt;=n; i++)    &#123;        for (int j=1; j&lt;=i; j++)        &#123;        cin&gt;&gt;a[i][j]; //输入原始数据        &#125;    &#125;    //递推开始    for (int i=n-1; i&gt;=1; i--)//从最后一层逆推    &#123;        for (int j=1; j&lt;=i; j++)        &#123;            if (a[i+1][j]&gt;=a[i+1][j+1])                a[i][j]+=a[i+1][j];     //路径选择            else                a[i][j]+=a[i+1][j+1];        &#125;    &#125;    cout&lt;&lt;a[1][1]&lt;&lt;endl;&#125;\n\nPython 解题代码\na = [[0] * 101] * 101if __name__ == &#x27;__main__&#x27;:  n = int(input())  # 输入数字三角形的值  for i in range(1, n+1):      a[i] = input().split()      a[i] = list(map(int, a[i]))  # split 分割后都是 字符 这里是转化成数字  #  # for i in range(1, n + 1):  #     print(a[i]) # a = list(map(int, a)) # split 分割后都是 字符 这里是转化成数字  # 递推开始  for i in range(n - 1, 0, -1):      # 最后一层逆推      for j in range(0, i):          # 路径选择          if a[i + 1][j] &gt;= a[i + 1][j + 1]:              a[i][j] += a[i + 1][j]          else:              a[i][j] += a[i + 1][j + 1]  # for i in range(1, n + 1):  #     print(a[i])  print(a[1][0])\n\nJava 解题代码\npackage com.company;import java.util.Scanner;public class Main &#123;  static int [][]a=new int [101][101];  public static void main(String[] args) &#123;      int n;      Scanner in = new Scanner(System.in);      n = in.nextInt();      //输入数字三角形的值      for (int i=1; i&lt;=n; i++)      &#123;          for (int j=1; j&lt;=i; j++)          &#123;              a[i][j]=in.nextInt(); //输入原始数据          &#125;      &#125;      //递推开始      for (int i=n-1; i&gt;=1; i--)//从最后一层逆推      &#123;          for (int j=1; j&lt;=i; j++)          &#123;              if (a[i+1][j]&gt;=a[i+1][j+1])                  a[i][j]+=a[i+1][j];     //路径选择              else  a[i][j]+=a[i+1][j+1];          &#125;      &#125;      System.out.println(a[1][1]);  &#125;&#125;\n\n总结我们这节课讲了递推与递归的知识点，并且也讲了何时采用递归设计程序，何时采用递推设计程序。对于多次询问的题目，也为大家展示了一种解决方法。\n对于递推算法，我们覆盖了正推和逆推两种方式。无论是递推和递归的关键在于找到关系式。\n希望同学能够独立完成题目进行练习。并且在后面的学习中会多次用到递归与递推设计其他算法。\n","categories":["蓝桥杯冲刺营","2.递归与递推"],"tags":["蓝桥杯备赛"]},{"title":"集合","url":"/2024/02/21/%E9%9B%86%E5%90%88/","content":"\n","categories":["蓝桥杯","第一章：语言基础","基础数据结构"],"tags":["蓝桥杯备赛"]}]