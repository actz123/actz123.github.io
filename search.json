[{"title":"DFS-剪枝","url":"/2024/02/22/DFS-%E5%89%AA%E6%9E%9D/","content":"\n","categories":["蓝桥杯","第三章：搜索"],"tags":["蓝桥杯备赛"]},{"title":"DFS-回溯","url":"/2024/02/22/DFS-%E5%9B%9E%E6%BA%AF/","content":"\n","categories":["蓝桥杯","第三章：搜索"],"tags":["蓝桥杯备赛"]},{"title":"LCS","url":"/2024/02/22/LCS/","content":"\n","categories":["蓝桥杯","第四章：动态规划","动态规划基础"],"tags":["蓝桥杯备赛"]},{"title":"01背包","url":"/2024/02/22/01%E8%83%8C%E5%8C%85/","content":"\n","categories":["蓝桥杯","第四章：动态规划","背包问题"],"tags":["蓝桥杯备赛"]},{"title":"DFS-基础","url":"/2024/02/22/DFS-%E5%9F%BA%E7%A1%80/","content":"\n","categories":["蓝桥杯","第三章：搜索"],"tags":["蓝桥杯备赛"]},{"title":"LIS","url":"/2024/02/22/LIS/","content":"\n","categories":["蓝桥杯","第四章：动态规划","动态规划基础"],"tags":["蓝桥杯备赛"]},{"title":"Python开发环境与基础知识","url":"/2024/02/21/Python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"\n\n\n\n\n\n\n\n\n\n","categories":["蓝桥杯","第一章：语言基础","编程基础"],"tags":["蓝桥杯备赛"]},{"title":"Python输入输出","url":"/2024/02/21/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","content":"\n\n\n\n","categories":["蓝桥杯","第一章：语言基础","编程基础"],"tags":["蓝桥杯备赛"]},{"title":"collections","url":"/2024/02/21/collections/","content":"\n","categories":["蓝桥杯","第一章：语言基础","函数"],"tags":["蓝桥杯备赛"]},{"title":"for语句","url":"/2024/02/21/for%E8%AF%AD%E5%8F%A5/","content":"\n","categories":["蓝桥杯","第一章：语言基础","循环结构"],"tags":["蓝桥杯备赛"]},{"title":"functool","url":"/2024/02/21/functool/","content":"\n","categories":["蓝桥杯","第一章：语言基础","函数"],"tags":["蓝桥杯备赛"]},{"title":"heapq","url":"/2024/02/21/heapq/","content":"\n","categories":["蓝桥杯","第一章：语言基础","函数"],"tags":["蓝桥杯备赛"]},{"title":"Hello World","url":"/2024/02/20/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"itertools","url":"/2024/02/21/itertools/","content":"\n","categories":["蓝桥杯","第一章：语言基础","函数"],"tags":["蓝桥杯备赛"]},{"title":"if语句","url":"/2024/02/21/if%E8%AF%AD%E5%8F%A5/","content":"\n\n\n\n\n\n\n\n\n\n\n","categories":["蓝桥杯","第一章：语言基础","选择结构"],"tags":["蓝桥杯备赛"]},{"title":"math","url":"/2024/02/21/math/","content":"\n","categories":["蓝桥杯","第一章：语言基础","函数"],"tags":["蓝桥杯备赛"]},{"title":"while语句","url":"/2024/02/21/while%E8%AF%AD%E5%8F%A5/","content":"\n","categories":["蓝桥杯","第一章：语言基础","循环结构"],"tags":["蓝桥杯备赛"]},{"title":"二分","url":"/2024/02/21/%E4%BA%8C%E5%88%86/","content":"\n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"二分查找","url":"/2024/02/21/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","content":"\n","categories":["蓝桥杯","第一章：语言基础","实践应用"],"tags":["蓝桥杯备赛"]},{"title":"二维DP","url":"/2024/02/22/%E4%BA%8C%E7%BB%B4DP/","content":"\n","categories":["蓝桥杯","第四章：动态规划","动态规划基础"],"tags":["蓝桥杯备赛"]},{"title":"二维费用背包&分组背包","url":"/2024/02/22/%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/","content":"\n","categories":["蓝桥杯","第四章：动态规划","背包问题"],"tags":["蓝桥杯备赛"]},{"title":"位运算","url":"/2024/02/21/%E4%BD%8D%E8%BF%90%E7%AE%97/","content":"\n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"倍增","url":"/2024/02/21/%E5%80%8D%E5%A2%9E/","content":"\n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"冒泡排序","url":"/2024/02/21/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","content":"\n","categories":["蓝桥杯","第二章：基础算法","排序"],"tags":["蓝桥杯备赛"]},{"title":"函数定义与使用","url":"/2024/02/21/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/","content":"\n","categories":["蓝桥杯","第一章：语言基础","函数"],"tags":["蓝桥杯备赛"]},{"title":"列表和元组","url":"/2024/02/21/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/","content":"\n","categories":["蓝桥杯","第一章：语言基础","基础数据结构"],"tags":["蓝桥杯备赛"]},{"title":"前缀和","url":"/2024/02/21/%E5%89%8D%E7%BC%80%E5%92%8C/","content":"\n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"单调队列优多重背包","url":"/2024/02/22/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/","content":"\n","categories":["蓝桥杯","第四章：动态规划","背包问题"],"tags":["蓝桥杯备赛"]},{"title":"双指针","url":"/2024/02/21/%E5%8F%8C%E6%8C%87%E9%92%88/","content":"  \n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"基础算法","url":"/2024/02/21/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/","content":"\n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"字符串","url":"/2024/02/21/%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"\n","categories":["蓝桥杯","第一章：语言基础","基础数据结构"],"tags":["蓝桥杯备赛"]},{"title":"字典","url":"/2024/02/21/%E5%AD%97%E5%85%B8/","content":"\t\n","categories":["蓝桥杯","第一章：语言基础","基础数据结构"],"tags":["蓝桥杯备赛"]},{"title":"完全背包","url":"/2024/02/22/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/","content":"\n","categories":["蓝桥杯","第四章：动态规划","背包问题"],"tags":["蓝桥杯备赛"]},{"title":"差分","url":"/2024/02/21/%E5%B7%AE%E5%88%86/","content":"\n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"常用库函数","url":"/2024/02/21/%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0/","content":"\n","categories":["蓝桥杯","第一章：语言基础","类的定义和使用"],"tags":["蓝桥杯备赛"]},{"title":"常量、变量与运算符","url":"/2024/02/21/%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/","content":"\n\n\n\n\n\n\n\n","categories":["蓝桥杯","第一章：语言基础","编程基础"],"tags":["蓝桥杯备赛"]},{"title":"循环嵌套","url":"/2024/02/21/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/","content":"\n","categories":["蓝桥杯","第一章：语言基础","循环结构"],"tags":["蓝桥杯备赛"]},{"title":"归并排序","url":"/2024/02/21/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","content":"\n","categories":["蓝桥杯","第二章：基础算法","排序"],"tags":["蓝桥杯备赛"]},{"title":"快速排序","url":"/2024/02/21/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","content":"\n","categories":["蓝桥杯","第二章：基础算法","排序"],"tags":["蓝桥杯备赛"]},{"title":"插入排序","url":"/2024/02/21/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","content":"\n","categories":["蓝桥杯","第二章：基础算法","排序"],"tags":["蓝桥杯备赛"]},{"title":"日期和时间","url":"/2024/02/21/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/","content":"\n","categories":["蓝桥杯","第一章：语言基础","基础数据结构"],"tags":["蓝桥杯备赛"]},{"title":"条件表达式和逻辑表达式","url":"/2024/02/21/%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"\n\n","categories":["蓝桥杯","第一章：语言基础","选择结构"],"tags":["蓝桥杯备赛"]},{"title":"构造","url":"/2024/02/21/%E6%9E%84%E9%80%A0/","content":"\n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"桶排序","url":"/2024/02/21/%E6%A1%B6%E6%8E%92%E5%BA%8F/","content":"\n","categories":["蓝桥杯","第二章：基础算法","排序"],"tags":["蓝桥杯备赛"]},{"title":"模拟","url":"/2024/02/21/%E6%A8%A1%E6%8B%9F/","content":"\n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"离散化","url":"/2024/02/21/%E7%A6%BB%E6%95%A3%E5%8C%96/","content":"\n\n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"枚举","url":"/2024/02/21/%E6%9E%9A%E4%B8%BE/","content":"\n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"线性DP","url":"/2024/02/22/%E7%BA%BF%E6%80%A7DP/","content":"\n","categories":["蓝桥杯","第四章：动态规划","动态规划基础"],"tags":["蓝桥杯备赛"]},{"title":"类的定义和使用","url":"/2024/02/21/%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/","content":"\n","categories":["蓝桥杯","第一章：语言基础","类的定义和使用"],"tags":["蓝桥杯备赛"]},{"title":"自上而下树形DP","url":"/2024/02/22/%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E6%A0%91%E5%BD%A2DP/","content":"\t本节内容属于算法提高知识，由专属金牌选手录制，由于视频时长有限，所以视频中例题讲解主要以 C++ 为主讲解，大家可正常学习。算法思维是共通的，例题的其他语言解题代码，我们也在下方提供了，大家可以参考哦～\n\nC++\n\n#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 110000int n, val[maxn];struct Edge&#123;    int nex, to;&#125;edge[maxn &lt;&lt; 1];int head[maxn], cnt;int f[maxn][2];void add(int from, int to)&#123;    edge[++cnt].nex = head[from];    head[from] = cnt;    edge[cnt].to = to;    return ;&#125;void dfs(int u, int fa)&#123;    for (int i = head[u]; i; i = edge[i].nex)    &#123;        int v = edge[i].to;        if (v != fa)            continue;        dfs(v, u);        f[u][0] += max(f[v][0], f[v][1]);        f[u][1] += f[v][0];    &#125;    return ;&#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; ++ i )        scanf(&quot;%d&quot;, &amp;val[i]), f[i][1] = val[i];    for (int i = 1; i &lt; n; ++ i )    &#123;        int u, v;        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);        add(u, v), add(v, u);    &#125;    dfs(1, 0);    printf(&quot;%d\\n&quot;, max(f[1][0], f[1][1]));    return 0;&#125;\n\n\nJava\n\nimport java.util.Scanner;public class TreeDP &#123;    static final int maxn = 110000;    static int n;    static int[] val = new int[maxn];    static Edge[] edges = new Edge[maxn &lt;&lt; 1];    static int[] head = new int[maxn];    static int cnt;    static int[][] f = new int[maxn][2];    static class Edge &#123;        int next, to;        Edge(int next, int to) &#123;            this.next = next;            this.to = to;        &#125;    &#125;    public static void add(int from, int to) &#123;        edges[++cnt] = new Edge(head[from], to);        head[from] = cnt;    &#125;    public static void dfs(int u, int fa) &#123;        for (int i = head[u]; i != 0; i = edges[i].next) &#123;            int v = edges[i].to;            if (v == fa)                continue;            dfs(v, u);            f[u][0] += Math.max(f[v][0], f[v][1]);            f[u][1] += f[v][0];        &#125;    &#125;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        n = sc.nextInt();        for (int i = 1; i &lt;= n; ++i) &#123;            val[i] = sc.nextInt();            f[i][1] = val[i];        &#125;        for (int i = 1; i &lt; n; ++i) &#123;            int u = sc.nextInt();            int v = sc.nextInt();            add(u, v);            add(v, u);        &#125;        dfs(1, 0);        System.out.println(Math.max(f[1][0], f[1][1]));        sc.close();    &#125;&#125;\n\n\nPython\n\nfrom collections import defaultdictn = int(input())val = [0] + [int(x) for x in input().split()]edges = defaultdict(list)f = [[0, val[i]] for i in range(n + 1)]def add_edge(from_node, to_node):    edges[from_node].append(to_node)def dfs(u, fa):    for v in edges[u]:        if v == fa:            continue        dfs(v, u)        f[u][0] += max(f[v][0], f[v][1])        f[u][1] += f[v][0]for _ in range(n - 1):    u, v = map(int, input().split())    add_edge(u, v)    add_edge(v, u)dfs(1, 0)print(max(f[1][0], f[1][1]))\n\n\nC++\n\n#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 110int n, v;int f[maxn][maxn];int w[maxn], v[maxn];vector&lt;int&gt; g[maxn];struct Edge&#123;    int nex, to;&#125;edge[maxn &lt;&lt; 1];int head[maxn], cnt;void add(int from, int to)&#123;    edge[++ cnt].nex = head[from];    head[from] = cnt;    edge[cnt.to] = to;    return ;&#125;void dfs(int u, int fa)&#123;    memset(f[u], -0x3f, sizeof f[u]);    if (v[u] &lt;= V)        f[u][v[u]] = w[u];    for (int i = head[u]; i; i = edge[i].nex)    &#123;        int v = edge[i].to;        if (v == fa)            continue;        dfs(v, u);        vector&lt;int&gt; nf(f[u], f[u] + V + 1);        for (int v1 = 0; v1 &lt;= V; v1 ++)        &#123;            for (int v2 = 0; v1 + v2 &lt;= V; v2 ++ )            &#123;                nf[v1 + v2] = max(nf[v1 + v2], f[u][v1] + f[v][v2]);            &#125;        &#125;        for (int v = 0; v &lt;= V; v ++ )            f[u][v] = nf[v];    &#125;    return ;&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;v);    for (int i = 1; i &lt; n; ++ i )    &#123;        int u, v;        add(u, v), add(v, u);    &#125;    dfs(1, 0);    int ans = 0;    for (int i = 0; i &lt;= V; ++ i )        ans = max(ans, f[1][i]);    cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;\n\n\nJava\n\nimport java.util.Scanner;import java.util.Arrays;import java.util.ArrayList;import java.util.List;public class TreeDP &#123;    static final int maxn = 110;    static int n, V;    static int[][] f = new int[maxn][maxn];    static int[] w = new int[maxn], val = new int[maxn];    static List&lt;Integer&gt;[] g = new ArrayList[maxn];    static Edge[] edges = new Edge[maxn &lt;&lt; 1];    static int[] head = new int[maxn];    static int cnt;    static class Edge &#123;        int next, to;        Edge(int next, int to) &#123;            this.next = next;            this.to = to;        &#125;    &#125;    public static void add(int from, int to) &#123;        edges[++cnt] = new Edge(head[from], to);        head[from] = cnt;    &#125;    public static void dfs(int u, int fa) &#123;        Arrays.fill(f[u], Integer.MIN_VALUE);        if (val[u] &lt;= V)            f[u][val[u]] = w[u];        for (int i = head[u]; i != 0; i = edges[i].next) &#123;            int v = edges[i].to;            if (v == fa)                continue;            dfs(v, u);            int[] nf = Arrays.copyOf(f[u], V + 1);            for (int v1 = 0; v1 &lt;= V; v1++) &#123;                for (int v2 = 0; v1 + v2 &lt;= V; v2++) &#123;                    nf[v1 + v2] = Math.max(nf[v1 + v2], f[u][v1] + f[v][v2]);                &#125;            &#125;            for (int v = 0; v &lt;= V; v++)                f[u][v] = nf[v];        &#125;    &#125;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        n = sc.nextInt();        V = sc.nextInt();        for (int i = 1; i &lt;= n; ++i) &#123;            w[i] = sc.nextInt(); // Assuming input for weights w is provided            val[i] = sc.nextInt(); // Assuming input for values val is provided            g[i] = new ArrayList&lt;&gt;();        &#125;        for (int i = 1; i &lt; n; ++i) &#123;            int u = sc.nextInt();            int v = sc.nextInt();            add(u, v);            add(v, u);        &#125;        dfs(1, 0);        int ans = 0;        for (int i = 0; i &lt;= V; ++i)            ans = Math.max(ans, f[1][i]);        System.out.println(ans);        sc.close();    &#125;&#125;\n\n\nPython\n\nfrom collections import defaultdictimport sysn, V = map(int, input().split())w = [0] + [int(x) for x in input().split()]val = [0] + [int(x) for x in input().split()]edges = defaultdict(list)f = [[float(&#x27;-inf&#x27;) for _ in range(V+1)] for _ in range(n+1)]def add_edge(from_node, to_node):    edges[from_node].append(to_node)def dfs(u, fa):    f[u] = [float(&#x27;-inf&#x27;)] * (V+1)    if val[u] &lt;= V:        f[u][val[u]] = w[u]    for v in edges[u]:        if v == fa:            continue        dfs(v, u)        nf = f[u][:]        for v1 in range(V + 1):            for v2 in range(V - v1 + 1):                nf[v1 + v2] = max(nf[v1 + v2], f[u][v1] + f[v][v2])        f[u] = nffor _ in range(n - 1):    u, v = map(int, input().split())    add_edge(u, v)    add_edge(v, u)dfs(1, 0)ans = max(f[1])print(ans)\n","categories":["蓝桥杯","第四章：动态规划","树形DP"],"tags":["蓝桥杯备赛"]},{"title":"自定义排序","url":"/2024/02/21/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/","content":"\n","categories":["蓝桥杯","第一章：语言基础","实践应用"],"tags":["蓝桥杯备赛"]},{"title":"蓝桥杯知识记录","url":"/2024/02/21/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/","content":"\n","categories":["蓝桥杯","A学习路线"],"tags":["蓝桥杯学习路线"]},{"title":"进制转换","url":"/2024/02/21/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/","content":"\n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"贪心","url":"/2024/02/21/%E8%B4%AA%E5%BF%83/","content":"  \n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"选择排序","url":"/2024/02/21/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","content":"\n","categories":["蓝桥杯","第二章：基础算法","排序"],"tags":["蓝桥杯备赛"]},{"title":"递归","url":"/2024/02/21/%E9%80%92%E5%BD%92/","content":"\n","categories":["蓝桥杯","第二章：基础算法","基础算法"],"tags":["蓝桥杯备赛"]},{"title":"集合","url":"/2024/02/21/%E9%9B%86%E5%90%88/","content":"\n","categories":["蓝桥杯","第一章：语言基础","基础数据结构"],"tags":["蓝桥杯备赛"]}]