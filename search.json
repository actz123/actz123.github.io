[{"title":"顺序表","url":"/2024/02/27/顺序表/"},{"title":"排序示例代码","url":"/2024/02/27/排序示例代码/","content":"\n# 冒泡排序 #\n\n```py\n#冒泡排序\nn=int(input())\na=list(map(int,input().split()))\nfor i in range(1,n-1):\n    for j in range(0,n-i):\n        if a[j] > a[j+1]:\n            a[j],a[j+1] = a[j+1],a[j]  \nprint(\" \".join(map(str,a)))\n```\n\n# 选择排序 #\n\n```py\nn=int(input())\na=list(map(int,input().split()))\nfor i in range(n-1):\n    min_value =a[i]\n    min_idx =i\n    for j in range(i,n):\n        if a[j] < min_value:\n            min_value=a[j]\n            min_idx=j\n    print(a)\n    a[min_idx],a[i]=a[i],a[min_idx]\n    #将最小值和最前面的元素交换\n```\n\n# 插入排序 #\n\n```py\nn=int(input())\na=list(map(int,input().split()))\nfor i in range(1,n):\n    value =a[i]\n    insert_idx =0\n    for j in range(i-1,-1,-1):\n        if a[j]>value:\n            a[j+1] =a[j]\n        else:\n            insert_idx = j+1\n            break\n    a[insert_idx] = value\nprint(\" \".join(map(str,a)))\n```\n\n# 快速排序 #\n\n```py\ndef partition(a,left,right):\n    idx =left +1\n    for i in range(left+1,right+1):\n        if a[i]<=a[left]:\n            a[idx],a[i]=a[i],a[idx]\n            idx +=1\n    a[left],a[idx-1]=a[idx-1],a[left]\n    return idx -1\ndef quicksort(a,left,right):\n    if left < right:\n        mid =partition(a,left,right)\n        quicksort(a,left,mid-1)\n        quicksort(a,mid+1,right)\nn=int(input())\na=list(map(int,input().split()))\nquicksort(a,0,n-1)\nprint(\" \".join(map(str,a)))\t\n```\n\n# 归并排序 #\n\n```py\n#归并排序 合并两个list\nn=int(input())\na=list(map(int,input().split()))\ndef Merge(A,B):\n    result=[]\n    while len(A) !=0 and len(B) !=0:\n        if A[0] <=B[0]:\n            result.append(A.pop(0))\n        else:\n            result.append(B.pop(0))\n    result.extend(A)\n    result.extend(B)\n    return result\ndef MergeSort(A):\n    if len(A) <2:\n        return A\n    mid =len(A)//2\n    left =MergeSort(A[:mid])\n    right= MergeSort(A[mid:])\n    return Merge(left,right)\nprint(\" \".join(map(str,MergeSort(a))))\n```\n\n# 桶排序 #\n\n```py\n#桶排序\nfrom itertools import chain\ndef Bucket_Sort(a,bucketcount):\n    minvalue,maxvalue=min(a),max(a)\n    bucketsize =(maxvalue-minvalue+1)//bucketcount\n    res =[[] for i in range(bucketcount+1)]\n    for x in a:\n        idx =(x-minvalue)//bucketsize\n        res[idx].append(x)\n    for res_x in res:\n        res_x.sort()\n    return list(chain(*res))\nn=int(input())\na=list(map(int,input().split()))\n\na=Bucket_Sort(a,min(n,10000))\nprint(\" \".join(map(str,a)))\n```\n\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","代码集合"]},{"title":"组合数学","url":"/2024/02/22/组合数学/","content":"\n# 组合数学 #\n\n## 计数原理：加法原理 ##\n\n- 加法原理： 集合 (S) 被分成两两不相交的部分 (S_1, S_2, S_3, ..., S_m)，那么 (S) 的对象数目等于：(|S| = |S_1| + |S_2| + |S_3| + ... + |S_m|)\n- 例： 一个学生想学一门数学课，一门文化课，但不能同时选，现在从 44 门数学课和 44 门文化课中选，一共有 (4 + 4 = 8) 种方法选一门课。\n- 加法原理的关键是将计数分解为若干个独立（不相容）的部分，保证既不重复也不遗漏地进行计数。 加法原理是利用完备事件组的一个体现，我们可以利用一个集合的补记做题。\n\n### 例题：分割立方体 lanqiaoOJ 题号 1620 ###\n\n**题目描述：** 一个立方体，边长为 �*n*，分割成 �×�×�*n*×*n*×*n* 个单位立方体。任意两个单位立方体，或者有 22 个公共点，或者有 44 个公共点，或者没有公共点。请问，没有公共点和有 22 个公共点的立方体，共有多少对？\n\n**输入描述：** 一个整数�，1<=�<=30一个整数*n*，1<=*n*<=30\n\n**思路：** 反过来计算，先算出有 44 个公共点的立方体有多少对，然后用总对数减去。分几种情况讨论：\n\n1. 正方体和周围 33 个正方体相邻，这种情况共有 88 个，就是顶角上的 88 个，总个数 3×83×8；\n2. 正方体和周围 44 个正方体相邻，这种情况共有 (�−2)×12(*n*−2)×12 个 （棱）总个数 4×(�−2)×124×(*n*−2)×12；\n3. 正方体和周围 55 个正方体相邻，这种情况共有 6×(�×�−4×�+4)6×(*n*×*n*−4×*n*+4) 个，总个数 5×6×(�×�−4×�+4)5×6×(*n*×*n*−4×*n*+4)；\n4. 正方体和周围 66 个正方体相邻，这种情况共有 (�×�×�−�×�×6+�×12−8)(*n*×*n*×*n*−*n*×*n*×6+*n*×12−8) 个，总个数 6×(�×�×�−�×�×6+�×12−8)6×(*n*×*n*×*n*−*n*×*n*×6+*n*×12−8)； 最后把这 44 个情况求和再除以 22。\n\n正方体一共 �3*n*3 个，共有 �3(�3−1)22*n*3(*n*3−1) 种关系\n\n1. 正方体和周围 33 个正方体相邻，总个数 3×83×8；\n2. 正方体和周围 44 个正方体相邻，总个数 4×(�−2)×124×(*n*−2)×12；\n3. 正方体和周围 55 个正方体相邻，总个数 5×6×(�×�−4×�+4)5×6×(*n*×*n*−4×*n*+4)；\n4. 正方体和周围 66 个正方体相邻，总个数 6×(�×�×�−�×�×6+�×12−8)6×(*n*×*n*×*n*−*n*×*n*×6+*n*×12−8)；\n5. 最后把这 44 个情况求和再除以 22。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n; cin >> n;\n    if(n == 1){             // 边长为 1 时特判\n        cout << 0 << endl;\n        return 0;\n    }\n    long long sum = n * n * n * (n * n * n - 1) / 2;     //总数\n    int edge3 = 8;\n    int ans3 = 3 * edge3;\n    int edge4 = (n - 2) * 12;\n    int ans4 = 4 * edge4;\n    int edge5 = n * n - 4 * n + 4;\n    int ans5 = 5 * 6 * edge5;\n    int edge6 = n * n * n - n * n * 6 + n * 12 - 8;\n    int ans6 = 6 * edge6;\n    cout << sum - (ans3 + ans4 + ans5 + ans6) / 2 << endl;\n    return 0;\n}\nn = int(input())\nif n == 1: # 边长为 1 时特判\n    print(0)\nelse:\n    sum = n * n * n * (n * n * n - 1) // 2 # 总数\n    edge3 = 8\n    ans3 = 3 * edge3\n    edge4 = (n - 2) * 12\n    ans4 = 4 * edge4\n    edge5 = n * n - 4 * n + 4\n    ans5 = 5 * 6 * edge5\n    edge6 = n * n * n - n * n * 6 + n * 12 - 8\n    ans6 = 6 * edge6\n    print(sum - (ans3 + ans4 + ans5 + ans6) // 2)\nimport java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        if (n == 1) { // 边长为 1 时特判\n            System.out.println(0);\n            return;\n        }\n        long sum = (long) n * n * n * (n * n * n - 1) / 2; // 总数\n        int edge3 = 8;\n        int ans3 = 3 * edge3;\n        int edge4 = (n - 2) * 12;\n        int ans4 = 4 * edge4;\n        int edge5 = n * n - 4 * n + 4;\n        int ans5 = 5 * 6 * edge5;\n        int edge6 = n * n * n - n * n * 6 + n * 12 - 8;\n        int ans6 = 6 * edge6;\n        System.out.println(sum - (ans3 + ans4 + ans5 + ans6) / 2);\n    }\n}\n```\n\n## **计数原理：乘法原理** ##\n\n令 (S) 是对象的有序对 ((a, b)) 的集合，其中第一个对象 (a) 来自大小为 (p) 的一个集合，对于对象 (a) 的每个选择，对象 (b) 有 (q) 个选择，那么 (S) 的大小：(|S| = p \\times q)\n\n例：中性笔的长度有 33 种，颜色有 44 种，直径有 55 种。不同种类的中性笔有：(3 \\times 4 \\times 5 = 60) 种。\n\n例：(34 \\times 55 \\times 72 \\times 113) 的正整数因子有多少？答：这是算数基本定理的概念。33 有 00 ~ 44 这 55 种选择，55 有 66 个选择，77 有 33 个选择，1111 有 44 个选择，因子总数是 (5 \\times 6 \\times 3 \\times 4 = 360) 种。\n\n## 排列数 ##\n\n排列是有序的。\n\n不可重复排列数：从 (n) 个不同的物品中取出 (r) 个，排列数为：\n\n[\\mathrm{P_{n}^{r}=n(n-1)(n-2)...(n-r+1)=\\frac{n!}{(n-r)!}}]\n\n可重复排列数，从 (n) 个不同的物品中可重复地取出 (r) 个的排列数为：(n^r)。\n\n## 组合数 ##\n\n排列是有序的，组合是无序的。\n\n如果 (S) 中的元素都不相同，组合数：\n\n[\\mathrm{C*{n}^{r}={\\binom{n}{k}}={\\frac{P*{n}^{r}}{r!}}={\\frac{n!}{r!(n-r)!}}}]\n\n## 糊涂人寄信 lanqiaoOJ 题号 1622 ##\n\n**题目描述：** 有一个糊涂人，写了 (n) 封信和 (n) 个信封，到了邮寄的时候，把所有的信都装错了信封。求装错信封可能的种类数。\n\n**输入描述：** 每行输入一个正整数 (n)，表示一种情况。((n \\leq 20))\n\n**输出描述：** 输出相应的答案。\n\n### 解题思路： ###\n\n题目建模为：有 (1 \\sim n) 个数字，分别放在 (n) 个位置，问都放错的情况有多少种。\n\n用 DP 来做。定义 (dp[])，(dp[i]) 表示数字 (1 \\sim i) 都放错的种类数。(dp[n]) 是答案。\n\n下面考虑状态转移方程，从 (1 \\sim i) 递推到 (i)。\n\n数字 (i) 如果放错，有 (i-1) 个位置可以放，假设其放在第 (k) 个位置。对于数字 (k)，可以放在 (i) 位置也可以不放在 (i) 位置。\n\n如果 (k) 放在 (i) 位置，那么对于剩下 (i-2) 个数字放的次数，就是 (i-2) 个数字都放错的方法数 (dp[i-2])。\n\n如果 (k) 不放在 (i) 位置，和 (i-1) 个数字放错的情况相同，为 (dp[i-1])。\n\n状态转移方程：(dp[i] = (i-1) \\times (dp[i-1] + dp[i-2]))\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll dp[30];\nint main(){\n    dp[1]= dp[0]=0;\n    dp[2]=1;\n    for(int i=3;i<=22;i++) dp[i]=(i-1)*(dp[i-1]+dp[i-2]);\n    int n;\n    while(cin>>n) cout<<dp[n]<<endl;\n    return 0;\n}\nimport sys\ndef f(n):\n    if n==0 or n==1: return 0\n    elif n==2:  return 1\n    else:  return (n-1)*(f(n-1)+f(n-2))\nfor n in sys.stdin:   #读入n，和C++代码的while(cin>>n)功能一样\n    n = int(n)\n    print(f(n))\nimport java.util.Scanner;\n\npublic class Main {\n    static long[] dp = new long[30];\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        dp[1] = dp[0] = 0;\n        dp[2] = 1;\n        for (int i = 3; i <= 22; i++) {\n            dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]);\n        }\n        while (sc.hasNext()) {\n            int n = sc.nextInt();\n            System.out.println(dp[n]);\n        }\n        sc.close();\n    }\n}\n```\n\n## 鸽巢原理 ##\n\n鸽巢原理，又称抽屉原理。\n\n**鸽巢原理：** 把 (n+1) 个物体放进 (n) 个盒子，至少有一个盒子包含 22 个或更多的物体。\n\n- 例：在 370370 人中，至少有 22 人生日相同；\n- 例：�*n* 个人互相握手，一定有 22 个人握手次数相同。\n\n例：�*n* 个人互相握手，一定有 22 个人握手次数相同。 每人跟其他人握手，最少可以是 00 次，最多可以是�−1*n*−1次。 如果握手最少的是 00 次，那么剩下的�−1*n*−1人中，握手最多的人不会超过�−2*n*−2次。0∼�−20∼*n*−2 共�−1*n*−1种情况。 如果握手最少的张三是 11 次，那么剩下的�−1*n*−1人中，握手最多的李四除了跟张三握手一次，跟其他�−2*n*−2人最多握手�−2*n*−2次，李四最多握手�−1*n*−1次。1∼�−11∼*n*−1 共�−1*n*−1种情况。 如果握手最少的张三是 22 次，那么剩下的�−1*n*−1人中，握手最多的李四除了跟张三握手一次，跟其他�−2*n*−2人最多握手�−2*n*−2次，李四最多握手�−1*n*−1次。2∼�−12∼*n*−1 共�−2*n*−2种情况。 …… 所以握手次数最多有�−1*n*−1种情况，最少只有 11 种情况。 把最多的�−1*n*−1种情况看成�−1*n*−1个抽屉，�*n*个人放进这�−1*n*−1个抽屉，至少有一个抽屉里面有 22 人。\n\n## 例题：小蓝吃糖果 lanqiaoOJ 题号 1624 ##\n\n**题目描述：** Gardon 有 �*n* 种糖果，每种数量已知。Gardon 不喜欢连续 22 次吃同样的糖果。问有没有可行的吃糖方案。\n\n**输入：** 第一行是整数 N，(0 < n < 1000000)，第二行是 (n) 个数，表示 (n) 种糖果的数量 (m_i)，(0 < m_i < 1000000)\n\n**输出：** 输出一行，包含一个 \"Yes\" 或 \"no\"。\n\n## 解题思路 ##\n\n继续处理格式，鸽巢原理，用“隔板法”求解。\n\n找出最多的一种糖果，把它的数量 (K) 看成 (K) 个隔板，隔成 (K) 个空间（把每个隔板的右边看成一个空间）；其它所有糖果的数量为 (S)。\n\n最多的一种糖果，把它的数量 (K) 看成 (K) 个隔板，隔成 (K) 个空间（把每个隔板的右边看成一个空间）；其它所有糖果的数量为 (S)。\n\n- （1）如果 (S < K-1)，把 (S) 个糖果放到隔板之间，这 (K) 个隔板不够放，必然至少有 2 个隔板之间没有糖果，由于这 2 个隔板是同一种糖果，所以无解。\n- （2）(S \\geq K-1) 时，肯定有解。其中一个解是：把 (S) 个糖果排成一个长队，其中同种类的糖果是挨在一起的，然后每次取 (K) 个糖果，按顺序一个一个地放进 (K) 个空间。由于隔板数量比每一种糖果的数量都多，所以不可能有 22 个同样的糖果被放进一个空间里。把 (S) 个糖果放完，就是一个解，一些隔板里面可能放好几种糖果。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint a[1005000];\nint main(){\n    long long sum=0;\n    int Max=0;\n    int n; scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%d\",&a[i]);\n        sum += a[i];              //所有糖果数量\n        if(a[i]>Max)  Max=a[i];   //最多的一种糖果\n    }\n    if(sum-Max+1>=Max) printf(\"Yes\\n\");\n    else               printf(\"No\\n\");\nreturn 0;\n}\nn=int(input())\na=list(map(int,input().split()))\nif sum(a)-max(a) < max(a)-1:\n    print(\"No\")\nelse:\n    print(\"Yes\")\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        long sum = 0;\n        int max = 0;\n        int n = input.nextInt();\n        for (int i = 1; i <= n; i++) {\n            int x = input.nextInt();\n            sum += x;\n            if (x > max) {\n                max = x;\n            }\n        }\n        if (sum - max + 1 >= max) {\n            System.out.println(\"Yes\");\n        } else {\n            System.out.println(\"No\");\n        }\n    }\n}\n```\n\n## 二项式定理和杨辉三角 ##\n\n杨辉三角：排列成如下三角形的数字\n\n```txt\n                                 1\n                               1   1\n                              1  2  1\n                            1   3  3  1\n                           1  4   6  4  1\n```\n\n每个数是它上面 22 个数的和。\n\n求杨辉三角第 �*n* 行的数字，可以模拟这个推导过程，逐级递推，复杂度 �(�2)*O*(*n*2)。\n\n用数学公式计算，可以直接得到结果，这个公式是(1+�)�(1+*x*)*n*。\n\n![图片描述](./../imgs/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/163bed9e512b94d13ac8e09f824ca2ad-0.png)\n\n二项式系数就是(1+�)�(1+*x*)*n* 展开后第 �*r* 项的系数。\n\nCnr=(nr)=n!r!(n−r)!Cnr=(rn)=r!(n−r)!n!\n\n对应杨辉三角的第 �*n* 行第 �*r* 个数是\n\n例：杨辉三角的第 44 行是“13311331”，\n\nCn−1r−1=C4−11−1=C30=1、C31=3、C32=3、C33=1Cn−1r−1=C4−11−1=C30=1、C31=3、C32=3、C33=1\n\n理解：(1+�)�(1+*x*)*n* 的第 �*r* 项，就是从 �*n* 个 �*x* 中选出 �*r* 个，这就是组合数的定义\n\n当 n 较大，且需要取模时，二项式系数有两种计算方法：\n\n（1）递推公式：Cnr=Cn−1r+Cn−1r−1Cnr=Cn−1r+Cn−1r−1\n\n公式是杨辉三角的定义，即“每个数是它上面 22 个数的和”。计算复杂度是 �(�2)*O*(*n*2)。\n\n（2）用逆直接计算\n\n因为输出取模，那么不用递推公式，直接用公式计算更快。不过，由于除法不能直接取模，需要用到逆。用逆计算二项式系数，有：\n\nCnr=(nr)=n!r!(n−r)!Cnr=(rn)=r!(n−r)!n!\n\nCrnmodm=n!r!(n−r)!modm=(n!modm)((r!)−1modm)(((n−r)!)−1modm)modmCrnmodm=r!(n−r)!n!modm=(n!modm)((r!)−1modm)(((n−r)!)−1modm)modm\n\n用逆计算二项式系数，复杂度是 �(�)*O*(*n*) 的。\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯冲刺营","13.组合数学"]},{"title":"简单数论","url":"/2024/02/22/简单数论/","content":"\n# 简单数论 #\n\n## 1 模运算 ##\n\n- 定义：模运算为 a 除以 m 的余数，记为 a mod m，有 a mod m = a % m。\n- 模运算是大数运算中的常用操作。\n- 如果一个数太大，无法直接输出，或者不需要直接输出，可以把它取模后，缩小数值再输出。\n- Python 虽然能直接计算大数，不用担心数据溢出，但是大数乘法太耗时，所以也常用取模来缩小数值。\n- 一个简单应用，判断奇偶：a%2=0，a 是偶数；a%2=1，a 是奇数\n\n### 例题：刷题统计 2022 年第十三届省赛，lanqiaoOJ 题号 2098 ###\n\n【问题描述】 小明决定从下周一开始努力刷题准备蓝桥杯竞赛。他计划周一至周五每天做 a 道题目，周六和周日每天做 b 道题目。请你帮小明计算，按照计划他将在第几天实现做题数大于等于 n 题？\n\n【输入格式】 输入一行包含三个整数 a, b 和 n。\n\n【输出格式】 输出一个整数代表天数。\n\n【评测用例规模与约定】 对于 50%的评测用例，1 ≤ a, b, n ≤ 106106；对于 100%的评测用例，1 ≤ a, b, n ≤ 10181018。\n\n### 题目解析 ###\n\n求余数的简单题，利用求余，把计算复杂度降为 O(1)。\n\n**C++ 代码：**\n\n```c\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n    ll a,b,n; cin>>a>>b>>n;\n    ll week = a*5+b*2;     //每周做题\n    ll days = (n/week)*7;  //周数\n    n %= week;             //剩下的做题数\n    if(n<=a*5) days += n/a+(n%a?1:0);  //在周一到周五内\n    else{                  //周六和周日\n        days += 5, n -= a*5;\n        days += n/b+(n%b?1:0);\n    }\n    cout<<days;\n    return 0;\n}\n```\n\n**Java 代码：**\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        long a = sc.nextLong(), b = sc.nextLong(), n = sc.nextLong();\n        long week = a * 5 + b * 2;  //每周做题\n        long days = (n / week) * 7; //周数*7天\n        n %= week;                  //余下不够一周的做题数\n        if (n <= a * 5)\n            days += n / a + (n % a != 0 ? 1 : 0); //在周一到周五内\n        else {                       //周六和周日\n            days += 5;\n            n -= a * 5;\n            days += n / b + (n % b != 0 ? 1 : 0);\n        }\n        System.out.println(days);\n        sc.close();\n    }\n}\n```\n\n**Python 代码：**\n\n```python\na, b, n = map(int, input().split())\nweek = a * 5 + b * 2  #每周做题\ndays = (n // week) * 7  #天数\nn %= week  #余数\nif n <= a * 5:\n    days += n // a + (n % a != 0)  #在周一到周五内\nelse:  #周六和周日\n    days += 5\n    n -= a * 5\n    days += n // b + (n % b != 0)\nprint(days)\n```\n\n## 2 快速幂 ##\n\n幂运算 an，当 n 很大时，如果一个个乘，时间是 O(n) 的，速度很慢，此时可以用快速幂，在 O(logn) 的时间内算出来。 快速幂的一个解法：分治法，算 a2，然后再算(a2) 2，…，一直算到 an，代码也容易写。\n\n- 标准的快速幂：用位运算实现。\n- 基于位运算的快速幂，原理是倍增。\n\n### 快速幂原理 ###\n\n以 �11*a*11 为例说明如何用倍增法做快速幂。\n\n（1）幂次与二进制的关系。把 �11*a*11 分解成幂 �8、�2、�1*a*8、*a*2、*a*1 的乘积：�11=�8+2+1=�8×�2×�1*a*11=*a*8+2+1=*a*8×*a*2×*a*1。其中�1、�2、�4、�8...*a*1、*a*2、*a*4、*a*8...的幂次都是 2 的倍数，所有的幂 ��*a**i* 都是倍乘关系，逐级递推，代码： a *= a\n\n（2）幂次用二进制分解。如何把 11 分解为 8+2+1？利用数的二进制的特征，n = 1110 = 10112 = 23+21+20 = 8+2+1，把 n 按二进制处理就可以。\n\n（3）如何跳过那些没有的幂次？例如 1011 需要跳过 �4*a*4。做个判断，用二进制的位运算实现：\n\n- n & 1 取 n 的最后一位，并且判断这一位是否需要跳过。\n- n >>= 1 把 n 右移一位，目的是把刚处理过的 n 的最后一位去掉。 幂运算的结果往往很大，一般会先取模再输出。 根据取模的性质有：��mod�=(�mod�)�mod�*a**n*mod*m*=(*a*mod*m*)*n*mod*m*\n\n### 例题：快速幂 lanqiaoOJ 题号 1514 ###\n\n【题目描述】给定 b, p, k，求(bp) mod k。其中 2≤b, p, k≤109。 【输入描述】三个整数 b，p，k。 【输出描述】输出(bp) mod k。\n\n### 题目解析 ###\n\n**C++ 代码：**\n\n```c\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;     //变量改用较大的long long\nll fastPow(ll a, ll n, ll mod){\n    ll ans = 1;\n    a %= mod;          //重要，防止下面的ans*a越界\n    while(n) {\n        if(n & 1)   ans = (ans*a) % mod;   //取模\n        a = a*a % mod;                     //取模\n        n >>= 1;\n    }\n    return ans;\n}\nint main(){\n    ll b,p,k;    cin>>b>>p>>k;\n    cout << fastPow(b,p,k);\n    return 0;\n}\n```\n\n**Java 代码：**\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n    static long fastPow(long a, long n, long mod) {\n        long ans = 1;\n        a %= mod;   //重要，防止下面的ans*a越界\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                ans = (ans * a) % mod;  //取模\n            }\n            a = (a * a) % mod;  //取模\n            n >>= 1;\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        long b = sc.nextLong(), p = sc.nextLong(), k = sc.nextLong();\n        System.out.println(fastPow(b, p, k));\n        sc.close();\n    }\n}\n```\n\n**Python 代码：**\n\n```python\ndef fast_pow(a, n, mod):\n    ans = 1\n    a %= mod  #重要，防止下面的ans*a越界\n    while n > 0:\n        if n & 1 == 1:\n            ans = (ans * a) % mod  #取模\n        a = (a * a) % mod  #取模\n        n >>= 1\n    return ans\n\nb, p, k = map(int, input().split())\nprint(fast_pow(b, p, k))\n```\n\n## GCD 定义、性质 ##\n\n最大公约数 Greatest Common Divisor(GCD)：整数 a 和 b 的 GCD 是指能同时整除 a 和 b 的最大整数，记为 gcd(a, b)。由于-a 的因子和 a 的因子相同，因此 gcd(a, b) = gcd(|a|, |b|)。编码时只关注正整数的最大公约数。 性质： （1）gcd(a, b) = gcd(a, a+b) = gcd(a, k·a+b) （2）gcd(ka, kb) = k·gcd(a, b) （3）定义多个整数的最大公约数：gcd(a, b, c) = gcd(gcd(a, b), c)。 （4）若 gcd(a, b) = d，则 gcd(a/d, b/d) = 1，即 a/d 与 b/d 互素。这个定理很重要。 （5）gcd(a+cb, b) = gcd(a, b)\n\n**C++福利：** c++函数 std::__gcd()，可以返回负数，可以带多个参数。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    cout<<__gcd(15, 81)<<\"\\n\";    // 输出  3\n    cout<<__gcd(0, 44)<<\"\\n\";     // 输出  44\n    cout<<__gcd(0, 0)<<\"\\n\";      // 输出  0\n    cout<<__gcd(-6, -15)<<\"\\n\";   // 输出  -3\n    cout<<__gcd(-17,289)<<\"\\n\";   // 输出  -17\n    cout<<__gcd(17,-289)<<\"\\n\";   // 输出  17\n    return 0;\n}\n```\n\n### 手写 GCD 代码 ###\n\n手写 gcd 函数，常用欧几里得算法。 辗转相除法求 gcd： `gcd(a, b) = gcd(b, a mod b)` 这是最常用的方法，极为高效。 设 a > b，辗转相除法的计算复杂度为�((���2�)3)*O*((*l**o**g*2*a*)3)。\n\n可输出负数，和库函数一样:\n\n```c\n#include<bits/stdc++.h>\nusing namespace std;\nint gcd(int a, int b){     return b? gcd(b, a%b):a; }\nint main(){\n    cout<<gcd(15, 81)<<\"\\n\";    // 输出  3\n    cout<<gcd(0, 44)<<\"\\n\";     // 输出  44\n    cout<<gcd(0, 0)<<\"\\n\";      // 输出  0\n    cout<<gcd(-6, -15)<<\"\\n\";   // 输出  -3\n    cout<<gcd(-17,289)<<\"\\n\";   // 输出  -17\n    cout<<gcd(17,-289)<<\"\\n\";   // 输出  17\n    return 0;\n}\n// 或者使用如下编码方式：\n// int GCD(int a,int b)\n// {\n//     if(b==0)\n//         return a;\n//     return GCD(b,a%b);\n// }\npublic class Main {\n    static int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(gcd(15, 81));   // 输出  3\n        System.out.println(gcd(0, 44));    // 输出  44\n        System.out.println(gcd(0, 0));     // 输出  0\n        System.out.println(gcd(-6, -15));  // 输出  -3\n        System.out.println(gcd(-17, 289)); // 输出  17\n        System.out.println(gcd(17, -289)); // 输出  17\n    }\n}\n// 或者使用如下编码方式：\n// static int GCD(int a,int b)\n// {\n//     if(b==0)\n//         return a;\n//     return GCD(b,a%b);\n// }\ndef gcd(a, b):\n    return a if b == 0 else gcd(b, a % b)\n\nprint(gcd(15, 81))   # 输出  3\nprint(gcd(0, 44))    # 输出  44\nprint(gcd(0, 0))     # 输出  0\nprint(gcd(-6, -15))  # 输出  -3\nprint(gcd(-17, 289)) # 输出  17\nprint(gcd(17, -289)) # 输出  17\n\n# 或者使用如下编码方式：\n# def GCD(a,b):\n\n#     if b==0:\n#         return a\n#     return GCD(b,a%b)\n```\n\n## LCM ##\n\n最小公倍数 LCM (the Least Common Multiple) 。· a 和 b 的最小公倍数 lcm(�,�)(*a*,*b*),从算术基本定理推理得到。 算术基本定理：任何大于 1 的正整数 n 都可以唯一分解为有限个素数的乘积：\n\nn=p1c1p2c2…pmcmn=p1c1p2c2…pmcm,其中c1c1 都是正整数，pipi 都是素数且从小到大。\n\n推导 LCM： 设:�=�1�1�2�2…����,�=�1�1�2�2…����:*a*=*p*1*c*1*p*2*c*2…*p**m**c**m*,*b*=*p*1*f*1*p*2*f*2…*p**m**f**m*\n\n那么：gcd(a, �)=�1min⁡�1,�1�2min⁡�2,�2…��min⁡��,��*b*)=*p*1min*c*1,*f*1*p*2min*c*2,*f*2…*p**m*min*c**m*,*f**m*\n\nIcm(�,�)=�1max⁡�1,�1�2max⁡�2,�2…��max⁡��,��(*a*,*b*)=*p*1max*c*1,*f*1*p*2max*c*2,*f*2…*p**m*max*c**m*,*f**m*\n\n推出：gcd(a, b)*lcm(a, b)=a*b\n\n即：\n\nlcm(�,�):=:�∗�/gcd(�,�):=:�/gcd(�,:�)∗�.lcm(*a*,*b*):=:*a*∗*b*/gcd(*a*,*b*):=:*a*/gcd(*a*,:*b*)∗*b*.\n\n### lcm()手写代码 ###\n\n```c\n//c or c++\nint lcm(int a, int b){    //需要的时候把int改成long long\n   return a / gcd(a, b) * b;  //先做除法再做乘法，防止先做乘法溢出\n}\n\n# Python\ndef lcm(a, b):\n    return a // gcd(a, b) * b  #先做除法再做乘法，防止先做乘法溢出\n\n//java\nstatic int lcm(int a, int b) {\n    return a / gcd(a, b) * b; //先做除法再做乘法，防止先做乘法溢出\n}\n```\n\n### 核桃的数量 2013 年第四届省赛 lanqiaoOJ 题号 210 ###\n\n【题目描述】小张是软件项目经理，他带领 3 个开发组。工期紧，今天都在加班呢。为鼓舞士气，小张打算给每个组发一袋核桃（据传言能补脑）。他的要求是： 1.各组的核桃数量必须相同 2.各组内必须能平分核桃（当然是不能打碎的） 3.尽量提供满足 1, 2 条件的最小数量（节约闹革命嘛） 【输入格式】输入三个正整数 a, b, c，表示每个组正在加班的人数，用空格分开（a,b,c< 30）\n【输出格式】输出一个正整数，表示每袋核桃的数量。\n\n### 题目解析 ###\n\n简单题，答案就是三个数字的最小公倍数。\n\n```c\n#include<bits/stdc++.h>\nusing namespace std;\nint lcm(int a, int b){ return a / __gcd(a, b) * b;}\nint main(){\n    int a,b,c;    cin>>a>>b>>c;\n    int k = lcm(a,b);\n    cout<<lcm(k,c)<<endl;\n    return 0;\n}\nimport java.util.Scanner;\n\npublic class Main {\n    static int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    static int lcm(int a, int b) {\n        return a / gcd(a, b) * b;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int c = sc.nextInt();\n        int k = lcm(a, b);\n        System.out.println(lcm(k, c));\n        sc.close();\n    }\n}\ndef gcd(a, b):\n    return a if b == 0 else gcd(b, a % b)\n\ndef lcm(a, b):\n    return a // gcd(a, b) * b\n\na, b, c = map(int, input().split())\nk = lcm(a, b)\nprint(lcm(k, c))\n```\n\n## 5 素数的判断 ##\n\n素数定义：只能被 1 和自己整除的正整数。注：1 不是素数，最小素数是 2。\n\n判断一个数 n 是不是素数：当�≤1014*n*≤1014时，用试除法；n > 1014 时，试除法不够用，需 要用高级算法，例如 Miller Rabin 算法。\n\n**试除法：** 用[2,n-1]内的所有数去试着除 n，如果都不能整除，就是素数。 优化：把[2,n-1]缩小到[2,�][2,*n*]。证明：若 n = axb, 设 a≤�*n* ,则 b≥�*n*,如果 a 是 n 的因子，说明 n 不是素数，b 不用再试且 b 一定也是。\n\n### C++ 实现： ###\n\n```cpp\n#include <iostream>\n#include <cmath>\n\nbool is_prime(long long n){\n    if(n <= 1)\n        return false; // 1不是素数\n    for(long long i = 2; i <= sqrt(n); i++)\n        if(n % i == 0)\n            return false; // 能整除，不是素数\n    return true; // 全不能整除，是素数\n}\n\nint main() {\n    long long number = 29; // 例子：要检查是否为素数的数值\n    if (is_prime(number))\n        std::cout << number << \" 是素数。\" << std::endl;\n    else\n        std::cout << number << \" 不是素数。\" << std::endl;\n    return 0;\n}\n```\n\n### Java 实现： ###\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n    static boolean isPrime(long n) {\n        if (n <= 1)\n            return false; // 1不是素数\n        for (long i = 2; i <= Math.sqrt(n); i++)\n            if (n % i == 0)\n                return false; // 能整除，不是素数\n        return true; // 全不能整除，是素数\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"输入一个要检查是否为素数的数值：\");\n        long number = scanner.nextLong(); // 例子：要检查是否为素数的数值\n\n        if (isPrime(number))\n            System.out.println(number + \" 是素数。\");\n        else\n            System.out.println(number + \" 不是素数。\");\n    }\n}\n```\n\n### Python 实现： ###\n\n```python\ndef is_prime(n):\n    if n <= 1:\n        return False  # 1不是素数\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False  # 能整除，不是素数\n    return True  # 全不能整除，是素数\n\nnumber = 29  # 例子：要检查是否为素数的数值\nif is_prime(number):\n    print(number, \"是素数。\")\nelse:\n    print(number, \"不是素数。\")\n```\n\n## 6 素数筛 ##\n\n素数的筛选：给定 n，求 2~n 内所有的素数。 一个个地判断很慢，所以用“筛子”筛所有的整数，把非素数筛掉，剩下的就是素数。 常用两种筛法：埃氏筛、欧拉筛。\n\n**埃氏筛:**\n\n初始队列{2、3，4，5，6，7，8，9，10，11，12，13，...，n}，操作步骤： （1）输出最小的素数 2，筛掉 2 的倍数，得{2，3，4，5，6，7，8，9，10，11，12，13，...} （2）输出最小的素数 3，筛掉 3 的倍数，得{2，3，4，5，6，7，8，9，10，11，12，13，...} （3）输出最小的素数 5，筛掉 5 的倍数，得{2，3，4，5，6，7，8，9，10，11，12，13，...} 继续以上步骤，直到队列为空。\n\n### C++ 实现： ###\n\n```cpp\nint primes[N],cnt;\nbool bprime[N];\nvoid getPrime(int n){\n    memset(bprime,false,sizeof(bprime));\n    bprime[0]=true;\n    bprime[1]=true;\n\n    for(int i=2;i<=n;i++){\n        if(!bprime[i]){\n            prime[cnt++]=i;\n            for(LL j=i*2;j<=n;j+=i)\n                bprime[j]=true;\n        }\n    }\n}\n```\n\n### Java 实现： ###\n\n```java\nint[] primes = new int[N];\nint cnt;\nboolean[] bprime = new boolean[N];\n\nvoid getPrimes(int n) {\n    Arrays.fill(bprime, false);\n    bprime[0] = true;\n    bprime[1] = true;\n\n    for (int i = 2; i <= n; i++) {\n        if (!bprime[i]) {\n            primes[cnt++] = i;\n            for (int j = i * 2; j <= n; j += i) {\n                bprime[j] = true;\n            }\n        }\n    }\n}\n```\n\n### Python 实现： ###\n\n```python\nprimes = [0] * N\ncnt = 0\nbprime = [False] * N\n\ndef getPrimes(n):\n    global cnt, primes, bprime\n    bprime[0] = True\n    bprime[1] = True\n    for i in range(2, n+1):\n        if not bprime[i]:\n            primes[cnt] = i\n            cnt += 1\n            for j in range(i*2, n+1, i):\n                bprime[j] = True\n```\n\n**但是埃氏筛法的缺点：例如 6 会被 3 整除，6 会被 2 整除，会被筛两次，所以我们再给出欧氏线性筛法：**\n\n### C++ 实现： ###\n\n```cpp\nint primes[N],cnt;\nbool bPrime[N];\nvoid getPrimes(int n){\n    memset(bPrime,false,sizeof(bPrime));\n\n    for(int i=2;i<=n;i++){\n        if(!bPrime[i])\n            primes[cnt++]=i;\n\n        for(int j=0;j<cnt&&i*primes[j]<n;j++){\n            bPrime[i*primes[j]]=true;\n            if(i%primes[j]==0)\n                break;\n        }\n    }\n}\n```\n\n### Java 实现： ###\n\n```java\n    static int[] primes = new int[N], bPrime = new int[N];\n    static int cnt;\n\n    public static void getPrimes(int n) {\n        Arrays.fill(bPrime, 0, n + 1, 0);\n        for (int i = 2; i <= n; i++) {\n            if (bPrime[i] == 0)\n                primes[cnt++] = i;\n            for (int j = 0; j < cnt && i * primes[j] <= n; j++) {\n                bPrime[i * primes[j]] = 1;\n                if (i % primes[j] == 0)\n                    break;\n            }\n        }\n    }\n```\n\n### Python 实现： ###\n\n```python\nN = 1000005\nprimes = [0] * N\nbprime = [False] * N\ncnt = 0\n\ndef getPrimes(n: int):\n    global cnt\n    for i in range(2, n+1):\n        if not bprime[i]:\n            primes[cnt] = i\n            cnt += 1\n        j = 0\n        while j < cnt and i * primes[j] <= n:\n            bprime[i * primes[j]] = True\n            if i % primes[j] == 0:\n                break\n            j += 1\n```\n\n### 例题：质数 lanqiaoOJ 题号 1557 ###\n\n【题目描述】给定一个正整数 N，请你输出 N 以内（不包含 N）的质数以及质数的个数。 【输入描述】一个正整数 N，n<1000 【输出描述】两行，第 1 行包含若干个素数，从小到大输出，用空格分开。第 2 行一个整数，表示素数个数。\n\n输入： 10\n\n输出： 2 3 5 7 4\n\n题目为模板题目，实现方式如下，其中：\n\n- bprime[i]记录数 i 的状态，若 bprime [i]=1，表示它被筛掉，不是素数。\n- 用 primes[]存放素数，prime[0]是第一个素数 2。\n- Cnt 是素数个数计数\n\n### C++ 实现： ###\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6;\nint primes[N],cnt;\nbool bprime[N]; //true表示被筛掉，不是素数\nvoid getPrimes(int n){ //埃氏筛，计算[2, n]内的素数\n        memset(bprime,false,sizeof(bprime));\n        bprime[0]=true;\n        bprime[1]=true;\n\n        for(int i=2;i<=n;i++){\n            if(!bprime[i]){\n                primes[cnt++]=i;\n                for(int j=i*2;j<=n;j+=i)\n                    bprime[j]=true;\n            }\n        }\n    }\n\nint main(){\n    int n;\n    cin >>n;\n    getPrimes(n-1);\n    for(int i=0;i<cnt;i++)  cout << primes[i]<<\" \";\n    cout << endl;\n    cout << cnt;\n}\n```\n\n### Java 实现： ###\n\n```java\npublic class Main {\n    static final int N = 1000000;\n    static int[] primes = new int[N];\n    static boolean[] bprime = new boolean[N];\n    static int cnt;\n\n    public static void getPrimes(int n) {\n        bprime[0] = true;\n        bprime[1] = true;\n\n        for (int i = 2; i <= n; i++) {\n            if (!bprime[i]) {\n                primes[cnt++] = i;\n                for (int j = i * 2; j <= n; j += i) {\n                    bprime[j] = true;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        getPrimes(n - 1);\n        for (int i = 0; i < cnt; i++) {\n            System.out.print(primes[i] + \" \");\n        }\n        System.out.println();\n        System.out.println(cnt);\n    }\n}\n```\n\n### Python 实现： ###\n\n```python\nN = 10**6\nprimes = []\nbprime = [False] * N\n\ndef getPrimes(n):\n    global primes\n    global cnt\n\n    bprime[0] = True\n    bprime[1] = True\n\n    for i in range(2, n+1):\n        if not bprime[i]:\n            primes.append(i)\n            cnt += 1\n            for j in range(i*2, n+1, i):\n                bprime[j] = True\n\nn = int(input())\ncnt = 0\ngetPrimes(n-1)\n\nfor p in primes:\n    print(p, end=' ')\nprint()\n\nprint(cnt)\n```\n\n## 7 分解质因子 ##\n\n任何一个正整数 n 都可以唯一地分解为有限个素数的乘积：�=�1�1�2�2…����*n*=*p*1*c*1*p*2*c*2…*p**m**c**m*,其中�i*c*i都是正整数，p*i 都是素数且从小到大。 分解质因子也可以用试除法。求 n 的质因子： (1) 第一步，求最小质因子$p*{1}。逐个检查从2到。逐个检查从2到\\sqrt{n}的所有素数，如果它能整除�，就是最小质因子。然后连续用�的所有素数，如果它能整除*n*，就是最小质因子。然后连续用*p**{1}除�，目的是去掉�中的�除\\*n*，目的是去掉\\*n*中的\\*p**{1},得到�,得到*n**{1}。(2)第二步，再找�。(2)第二步，再找\\*n**{1}的最小质因子。逐个检查从�的最小质因子。逐个检查从*p**{1}到到\\quad\\sqrt{n1}\\quad\\text{的所有素数。从p}*{1}开始试除，是因为�开始试除，是因为*n**{1}没有比�没有比\\*P**{1}小的素因子，而且�小的素因子，而且*n*_{1}$的因子也是 n 的因子。 (3)继续以上步骤，直到找到所有质因子。\n\n我们直接看一个例题：\n\n【题目描述】求出区间[a,b]中所有整数的质因数分解。 【输入描述】输入一行，包含 2 个整数 a，b。2<=a<=b<=10000 【输出描述】每行输出一个数的分解，形如 k=a1×a2×a3×...，k 从小到大，a 从小到大。\n\n输入： 3 10\n\n输出： $\\begin{aligned} &\\text{3=} \\text{3} \\ &\\text{4=} 2\\times2 \\ &\\text{5=} \\text{5} \\ &6=2\\times3 \\ &\\text{7=7} \\ &8=2\\times2\\times2 \\ &9=3\\times3 \\ &10=2\\times5 \\end{aligned}$\n\n直接对每个数进行分解，然后打印出它的因数。\n\n### C++ 实现： ###\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint p[20];  //p[]记录因子，p[1]是最小因子。一个int数的质因子最多有10几个\nint c[40];  //c[i]记录第i个因子的个数。一个因子的个数最多有30几个\nint factor(int n){\n    int m = 0;\n    for(int i = 2; i <= sqrt(n); i++)\n        if(n%i == 0){\n            p[++m] = i, c[m] = 0;\n            while(n%i == 0)            //把n中重复的因子去掉\n                n/=i, c[m]++;\n        }\n    if(n>1)                           //没有被除尽，是素数\n        p[++m] = n, c[m] = 1;\n    return m;                         //共m个因子\n}\nint main(){\n    int a,b;   cin>>a>>b;\n    for(int i=a;i<=b;i++){\n        int m = factor(i);\n        cout<<i<<\"=\";\n        for(int j=1;j<=m;j++){ //第j个因子\n            for(int k=1;k<=c[j];k++){    //第j个因子的个数\n                cout <<p[j];\n                if(k<c[j]) cout <<\"*\";\n            }\n            if(j<m) cout <<\"*\";\n        }\n        cout<<endl;\n    }\n    return 0;\n}\n```\n\n### Java 实现： ###\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n    static int[] p = new int[20];  // p[] 记录因子，p[1] 是最小因子。一个 int 数的质因子最多有 10 几个\n    static int[] c = new int[40];  // c[i] 记录第 i 个因子的个数。一个因子的个数最多有 30 几个\n\n    static int factor(int n) {\n        int m = 0;\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                p[++m] = i;\n                c[m] = 0;\n                while (n % i == 0) {\n                    n /= i;\n                    c[m]++;\n                }\n            }\n        }\n        if (n > 1) {\n            p[++m] = n;\n            c[m] = 1;\n        }\n        return m;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int a = sc.nextInt(), b = sc.nextInt();\n        for (int i = a; i <= b; i++) {\n            int m = factor(i);\n            System.out.print(i + \"=\");\n            for (int j = 1; j <= m; j++) {\n                for (int k = 1; k <= c[j]; k++) {\n                    System.out.print(p[j]);\n                    if (k < c[j]) {\n                        System.out.print(\"*\");\n                    }\n                }\n                if (j < m) {\n                    System.out.print(\"*\");\n                }\n            }\n            System.out.println();\n        }\n    }\n}\n```\n\n### Python 实现： ###\n\n```python\nimport math\n\np = [0] * 20  # p[] 记录因子，p[1] 是最小因子。一个 int 数的质因子最多有 10 几个\nc = [0] * 40  # c[i] 记录第 i 个因子的个数。一个因子的个数最多有 30 几个\n\ndef factor(n):\n    m = 0\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            m += 1\n            p[m], c[m] = i, 0\n            while n % i == 0:\n                n //= i\n                c[m] += 1\n    if n > 1:\n        m += 1\n        p[m], c[m] = n, 1\n    return m\n\na, b = map(int, input().split())\nfor i in range(a, b+1):\n    m = factor(i)\n    print(f'{i}=', end='')\n    for j in range(1, m+1):\n        for k in range(1, c[j]+1):\n            print(p[j], end='')\n            if k < c[j]:\n                print('*', end='')\n        if j < m:\n            print('*', end='')\n    print()\n```\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯冲刺营","12.简单数论"]},{"title":"图论入门","url":"/2024/02/22/图论入门/","content":"\n# 图论 #\n\n本章节为图论最基本的内容，要求每位同学都要尽量掌握。\n\n## 图的基本概念 ##\n\n图：由点(`node`，或者 `vertex`)和连接点的边(`edge`)组成。图是点和边构成的网。\n\n树：特殊的图\n\n树，即连通无环图树的结点从根开始，层层扩展子树，是一种层次关系，这种层次关系，保证了树上不会出现环路。两点之间的路径：有且仅有一条路径。最近公共祖先。\n\n### 图的种类 ###\n\n（1）无向无权图，边没有权值、没有方向； （2）有向无权图，边有方向、无权值； （3）加权无向图，边有权值，但没有方向； （4）加权有向图； （5）有向无环图（Directed Acyclic Graph，DAG）。\n\n### 图算法的时间分析 ###\n\n图算法的复杂度和边的数量 E、点的数量 V 相关。�(�+�)*O*(*V*+*E*)：几乎是图问题中能达到的最好程度。�(�log⁡�)*O*(*V*log*E*)、�(�log⁡�)*O*(*E*log*V*)：很好的算法。�(�2)*O*(*V*2)、�(�2)*O*(*E*2)或更高：不算是好的算法。\n\n## 图的存储 ##\n\n能快速访问：图的存储，能让程序很快定位结点 `u` 和 `v` 的边`(u, v)` 。\n\n- 数组存边：简单、空间使用最少；无法快递定位\n- 邻接矩阵：简单、空间使用最大；定位最快 `dis[a][b]`\n- 邻接表：空间很少，定位较快\n- 链式前向星：空间更少，定位较快\n\n**注： 存储方式跟题目相匹配，占用空间少定位快也不一定是问题的最优存储方式。**\n\n### 数组存边 ###\n\n优点：简单、最省空间。 缺点：无法定位某条边。 应用：`bellman-ford` 算法、最小生成树的 `kruskal` 算法\n\n```c++\n// c/c++实现\nstruct Edge{\n    int from,to,dis;\n}e[M]; //结构体数组存边\n\ncin>>n>>m;\n\nfor(int i=1;i<=m;++i)\n    cin>>e[i].from>>e[i].to>>e[i].dis;\n//Java实现\nclass Edge { int from; int to; int dis;\n\n    public Edge(int from, int to, int dis) {\n        this.from = from;\n        this.to = to;\n        this.dis = dis;\n    }\n\n}\n\nEdge[] e = new Edge[M];\n\nScanner sc = new Scanner(System.in);\nint n = sc.nextInt();\nint m = sc.nextInt();\n\nfor (int i = 0; i < m; ++i)\n{\n    int from = sc.nextInt();\n    int to = sc.nextInt();\n    int dis = sc.nextInt();\n    e[i] = new Edge(from, to, dis);\n}\n#python实现\nclass Edge:\n    def init(self, f, t, d):\n        self.from = f\n        self.to = t\n        self.dis = d\n\ne = [Edge(0, 0, 0) for i in range(M)]\n\nn, m = map(int, input().split())\n\nfor i in range(1, m + 1):\n    e[i].from, e[i].to, e[i].dis = map(int, input().split())\n```\n\n### 邻接矩阵 ###\n\n二维数组： ����ℎ[���][���]*g**r**a**p**h*[*N**U**M*][*N**U**M*] 无向图： ����ℎ[�][�]=����ℎ[�][�]。*g**r**a**p**h*[*i*][*j*]=*g**r**a**p**h*[*j*][*i*]。 有向图： ����ℎ[�][�]≠����ℎ[�][�]。*g**r**a**p**h*[*i*][*j*]=*g**r**a**p**h*[*j*][*i*]。 权值： ����ℎ[�][�]存结点�到�的边的权值。*g**r**a**p**h*[*i*][*j*]存结点*i*到*j*的边的权值。 例如 ����ℎ[1][2]=3，����ℎ[2][1]=5等等。*g**r**a**p**h*[1][2]=3，*g**r**a**p**h*[2][1]=5等等。 用 ����ℎ[�][�]=���表示�，�之间无边。*g**r**a**p**h*[*i*][*j*]=*I**N**F*表示*i*，*j*之间无边。\n\n优点：\n\n- 适合稠密图；\n- 编码非常简短；\n- 对边的存储、查询、更新等操作又快又简单。\n\n缺点：\n\n- 存储复杂度 �(�2)*O*(*V*2)太高。V=10000 时，空间 100M。\n- 不能存储重边。\n\n### 邻接表和链式前向星 ###\n\n邻接表（指针或数组下标）和链式前向星（容器模拟）的思路一样，只是表达方式不同。\n\n![图片描述](./../imgs/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8/29bc6278e9e147f9597ba0c263fc1903-0.png)\n\n```c\nstruct edge{\n    int from, to; long long w; //起点，终点，权值。起点from并没有用到，e[i]的i就是from\n    edge(int a, int b,long long c){from=a; to=b; w=c;}\n};\nvector<edge>e[N];          //用于存储图\nstatic class Edge {\n    int from, to;\n    long w;\n\n    Edge(int a, int b, long c) {\n        from = a;\n        to = b;\n        w = c;\n    }\n}\nstatic ArrayList<Edge>[] e = new ArrayList[N];\nclass Edge:\n    def __init__(self, fr, to, w):\n        self.fr = fr\n        self.to = to\n        self.w = w\n\ne = [[] for _ in range(N)]\n```\n\n我们会在使用的时候进行讲解。\n\n## 最短路问题 ##\n\n最广为人知的图论问题就是最短路径问题。\n\n简单图的最短路径\n\n- 树上的路径：任意 22 点之间\n\n只有一条路径\n\n- 所有边长都为 11 的图：用 `BFS` 搜最短路径，复杂度 �(�+�)*O*(*n*+*m*)\n\n普通图的最短路径\n\n- 边长：不一定等于 11，而且可能为负数\n- 算法：`Floyd`、`Dijkstra`、`SPFA` 等，各有应用场景，不可互相替代\n\n### 最短路算法比较 ###\n\n| 问题                 | 边权                         | 算法                     | 时间复杂度                        |\n| -------------------- | ---------------------------- | ------------------------ | --------------------------------- |\n| 一个起点，一个终点   | 非负数；无边权（或边权为 1） | A*                       | <�((�+�)log⁡�)*O*((*m*+*n*)log*n*) |\n|                      |                              | 双向广搜                 | <�((�+�)log⁡�)*O*((*m*+*n*)log*n*) |\n|                      |                              | 贪心最优搜索             | <�(�+�)*O*(*m*+*n*)               |\n| 一个起点到其他所有点 | 无边权（或边权为 1）         | BFS                      | �(�+�)*O*(*m*+*n*)                |\n|                      | 非负数                       | Dijkstra(堆优化优先队列) | �((�+�)log⁡�)*O*((*m*+*n*)log*n*)  |\n|                      | 允许有负数                   | SPFA                     | <�(��)*O*(*m**n*)                 |\n| 所有点对之间         | 允许有负数                   | Floyd-Warshall           | �(�3)*O*(*n*3)                    |\n\n什么算法也不能解决存在负环图的最短路的问题！最多是判断是否存在，或者找到负环。\n\n网站推荐：[CSAcademy Graph Editor](https://csacademy.com/app/graph_editor/?tdsourcetag=s_pctim_aiomsg)\n\n![图片描述](./../imgs/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8/5c77aaf44a27ba24fd4dfee6aa36a8ce-0.png)\n\n方便图论的学习。\n\n### Floyd 算法 ###\n\n- 最简单的最短路径算法，代码仅有 44 行\n- 存图：最简单的矩阵存图\n- 易懂，比暴力的搜索更简单易懂。\n- 效率不高，不能用于大图在某些场景下有自己的优势，难以替代。能做传递闭包问题（离散数学）\n\n```c\n//java 和 c++\nfor(int k=1; k<=n; k++)         //floyd的三重循环\n    for(int i=1; i<=n; i++)\n        for(int j=1; j<=n; j++)      // k循环在i、j循环外面\n            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n#python\nfor k in range(1, n+1): #floyd的三重循环\n    for i in range(1, n+1):\n        for j in range(1, n+1): # k循环在i、j循环外面\n            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n```\n\n`Floyd算法`：`多源`最短路算法，一次计算能得到图中每一对结点之间（`多对多`）的最短路径。 `Dijkstra`、`Bellman-Ford`、`SPFA`算法：`单源`最短路径算法（`Single source shortest path algorithm`），一次计算能得到一个起点到其他所有点（`一对多`）的最短路径。在截止目前的蓝桥杯大赛中，`Floyd`算法是最常见的最短路径算法。 以上统计包括国赛和省赛，所以另外两种仍然要进行学习。\n\n#### Floyd 算法思想：动态规划 ####\n\n下面为 `Floyd` 算法的原理，不看背代码也可以。\n\n- 动态规划：求图上两点 `i`、`j` 之间的最短距离，按“从小图到全图”的步骤，在逐步扩大图的过程中计算和更新最短路。\n- 定义状态：`dp[k][i][j]，i、j、k`是点的编号，范围 `1 ~ n`。状态`dp[k][i][j]`表示在包含 `1 ~ k` 点的子图上，点对 `i、j` 之间的最短路。\n- 状态转移方程：从子图 `1 ~ k-1` 扩展到子图 `1 ~ k`��[�][�][�]=���(��[�−1][�][�],��[�−1][�][�]+��[�−1][�][�])*d**p*[*k*][*i*][*j*]=*m**i**n*(*d**p*[*k*−1][*i*][*j*],*d**p*[*k*−1][*i*][*k*]+*d**p*[*k*−1][*k*][*j*])\n\n首先是包含 `1 ~ k-1` 点的子图。 ��[�−1][�][�]*d**p*[*k*−1][*i*][*j*]：不包含 `k` 点子图内的点对 `i、j` 的最短路； ��[�−1][�][�]+��[�−1][�][�]*d**p*[*k*−1][*i*][*k*]+*d**p*[*k*−1][*k*][*j*]：经过 k 点的新路径的长度，即这条路径从 `i` 出发，先到 `k`，再从 `k` 到终点 `j`。 比较：不经过 `k` 的最短路径��[�−1][�][�]*d**p*[*k*−1][*i*][*j*]和经过 `k` 的新路径，较小者就是新的��[�][�][�]*d**p*[*k*][*i*][*j*]。\n\n所以 `Floyd` 的原理就是每次引入一个新的点，用它去更新其他点的最短距离。\n\n`k` 从 `1` 逐步扩展到 `n`：最后得到的��[�][�][�]*d**p*[*n*][*i*][*j*]是点对 `i、j` 之间的最短路径长度。 初值��[0][�][�]*d**p*[0][*i*][*j*]：若 `i、j` 是直连的，就是它们的边长；若不直连，赋值为无穷大。 `i、j` 是任意点对：计算结束后得到了所有点对之间的最短路。\n\n��[�][�][�]=���(��[�−1][�][�],��[�−1][�][�]+��[�−1][�][�])*d**p*[*k*][*i*][*j*]=*m**i**n*(*d**p*[*k*−1][*i*][*j*],*d**p*[*k*−1][*i*][*k*]+*d**p*[*k*−1][*k*][*j*]) 用滚动数组简化： ��[�][�]=���(��[�][�],��[�][�]+��[�][�])*d**p*[*i*][*j*]=*m**i**n*(*d**p*[*i*][*j*],*d**p*[*i*][*k*]+*d**p*[*k*][*j*])\n\n**特点：**\n\n- 在一次计算后求得所有结点之间的最短距离。\n- 代码极其简单，是最简单的最短路算法。\n- 效率低下，计算复杂度是 �(�3)*O*(*n*3)，只能用于 �<300*n*<300 的小规模的图。\n- 存图用邻接矩阵 `dp[][]` 。因为 `Floyd` 算法计算的结果是所有点对之间的最短路，本身就需要 `n^2` 的空间，用矩阵存储最合适。\n- 能判断负圈。 负圈：若图中有权值为负的边，某个经过这个负边的环路，所有边长相加的总长度也是负数，这就是负圈。在这个负圈上每绕一圈，总长度就更小，从而陷入在负圈上兜圈子的死循环。 `Floyd` 算法很容易判断负圈，只要在算法运行过程出现任意一个 `dp[i][i] < 0` 就说明有负圈。因为 `dp[i][i]` 是从 `i` 出发，经过其他中转点绕一圈回到自己的最短路径，如果小于零，就存在负圈。\n\n### Dijkstra 算法 ###\n\n- Dijkstra：单源最短路径问题。\n- 优点：非常高效而且稳定。\n- 缺点：只能处理不含有负权边的图。\n- 思路：贪心思想+优先队列。\n\n#### 算法思想 ####\n\n`Dijkstra` 算法算是贪心思想实现的，首先把起点到所有点的距离存下来找个最短的，然后松弛一次再找出最短的，所谓的松弛操作就是，遍历一遍看通过刚刚找到的距离最短的点作为中转站会不会更近，如果更近了就更新距离，这样把所有的点找遍之后就存下了起点到其他所有点的最短距离。\n\n**为什么是每次都是找最小的？**\n\n因为最小边的不会被其它的点松弛，只有可能最小边去松弛别人。 如果存在一个点 �*K* 能够松弛 ��*a**b* 的话那么一定有 ��*a**k* 距离加上 ��*k**b* 的距离小于 ��*a**b*，已知 ��*a**b* 最短，所以不存在 ��+��<��*a**k*+*k**b*<*a**b*。\n\n`Dijkstra` 算法应用了贪心法的思想，即“抄近路走，肯定能找到最短路径”。\n\n算法高效稳定：\n\n- `Dijkstra` 的每次迭代，只需要检查上次已经确定最短路径的那些结点的邻居，检查范围很小，算法是高效的；\n- 每次迭代，都能得到至少一个结点的最短路径，算法是稳定的\n\n优先队列实现：\n\n- 每次往队列中放新数据时，按从小到大的顺序放，采用小顶堆的方式，复杂度是 �(����)*O*(*l**o**g**n*)，保证最小的数总在最前面；\n- 找最小值，直接取 `B` 的第一个数，复杂度是 �(1)*O*(1)。\n- 复杂度：用优先队列时，`Dijkstra` 算法的复杂度是 �(�����)*O*(*m**l**o**g**n*)，是最高效的最短路算法。\n\n维护两个集合：已确定最短路径的结点集合 `A`、这些结点向外扩散的邻居结点集合 `B`。\n\n1. 把起点 `s` 放到 `A` 中，把 `s` 所有的邻居放到 `B` 中。此时，邻居到 `s` 的距离就是直连距离。\n2. 从 `B` 中找出距离起点 `s` 最短的结点 `u`，放到 `A` 中。\n3. 把 `u` 所有的新邻居放到 `B` 中。显然，`u` 的每一条边都连接了一个邻居，每个新邻居都要加进去。其中 `u` 的一个新邻居 `v`，它到 `s` 的距离 `dis(s, v)` 等于 `dis(s, u) + dis(u, v)`。\n4. 重复(2)、(3)，直到 `B` 为空时，结束。\n\n**Dijkstra 的局限性是边的权值不能为负数：**\n\nDijkstra 基于 `BFS`，计算过程是从起点 `s` 逐步往外扩散的过程，每扩散一次就用贪心得到到一个点的最短路。 扩散要求路径越来越长，如果遇到一个负权边，会导致路径变短，使扩散失效。\n\nDijkstra 模板如下：\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nconst long long INF = 0x3f3f3f3f3f3f3f3fLL;\n//这样定义INF的好处是: INF <= INF+x\nconst int N= 3e5+2;\nstruct edge{\n    int from, to; long long w; //起点，终点，权值。起点from并没有用到，e[i]的i就是from\n    edge(int a, int b,long long c){from=a; to=b; w=c;}\n};\nvector<edge>e[N];          //用于存储图\nstruct s_node{\n    int id; long long n_dis;   //id：结点；n_dis：这个结点到起点的距离\n    s_node(int b,long long c){id=b; n_dis=c;}\n    bool operator < (const s_node & a) const\n    { return n_dis > a.n_dis;}\n};\nint n,m;\nint pre[N];                                //记录前驱结点，用于生成路径\nvoid print_path(int s, int t) {            //打印从s到t的最短路\n    if(s==t){ printf(\"%d \", s); return; }  //打印起点\n    print_path(s, pre[t]);                 //先打印前一个点\n    printf(\"%d \", t);                      //后打印当前点。最后打印的是终点t\n}\nlong long  dis[N];         //记录所有结点到起点的距离\nvoid dijkstra(){\n    int s = 1;             //起点s是1\n    bool done[N]; //done[i]=true表示到结点i的最短路径已经找到\n    for (int i=1;i<=n;i++) {dis[i]=INF; done[i]=false; }    //初始化\n    dis[s]=0;                           //起点到自己的距离是0\n    priority_queue <s_node> Q;          //优先队列，存结点信息\n    Q.push(s_node(s, dis[s]));          //起点进队列\n    while (!Q.empty())   {\n        s_node u = Q.top();             //pop出距起点s距离最小的结点u\n        Q.pop();\n        if(done[u.id])  continue;       //丢弃已经找到最短路径的结点。即集合A中的结点            \n        done[u.id]= true;\n        for (int i=0; i<e[u.id].size(); i++) {  //检查结点u的所有邻居\n            edge y = e[u.id][i];         //u.id的第i个邻居是y.to\n            if(done[y.to])  continue;    //丢弃已经找到最短路径的邻居结点                \n            if (dis[y.to] > y.w + u.n_dis) {\n                dis[y.to] = y.w + u.n_dis;\n                Q.push(s_node(y.to, dis[y.to]));  //扩展新的邻居，放到优先队列中\n                pre[y.to]=u.id;  //如果有需要，记录路径\n            }\n        }\n    }\n    // print_path(s,n);          //如果有需要，打印路径: 起点1，终点n\n}\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1;i<=n;i++)    e[i].clear();\n    while (m--) {\n        int u,v,w;  scanf(\"%d%d%lld\",&u,&v,&w);\n        e[u].push_back(edge(u,v,w));\n     // e[v].push_back(edge(v,u,w));    //本题是单向道路\n    }\n    dijkstra();\n    for(int i=1;i<=n;i++){\n        if(dis[i]>=INF)  cout<<\"-1 \";\n        else   printf(\"%lld \", dis[i]);\n    }\n}\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final long INF = 0x3f3f3f3f3f3f3f3fL;\n    static final int N = 300005;\n    static ArrayList<Edge>[] e = new ArrayList[N];\n    static int n, m;\n    static int[] pre = new int[N];\n    static long[] dis = new long[N];\n    static boolean[] done = new boolean[N];\n\n    static class Edge {\n        int from, to;\n        long w;\n\n        Edge(int a, int b, long c) {\n            from = a;\n            to = b;\n            w = c;\n        }\n    }\n\n    static class SNode implements Comparable<SNode> {\n        int id;\n        long n_dis;\n\n        SNode(int b, long c) {\n            id = b;\n            n_dis = c;\n        }\n\n        public int compareTo(SNode o) {\n            return Long.compare(n_dis, o.n_dis);\n        }\n    }\n\n    static void printPath(int s, int t) {\n        if (s == t) {\n            System.out.print(s + \" \");\n            return;\n        }\n        printPath(s, pre[t]);\n        System.out.print(t + \" \");\n    }\n\n    static void dijkstra() {\n        int s = 1;\n        PriorityQueue<SNode> Q = new PriorityQueue<>();\n        Arrays.fill(dis, INF);\n        dis[s] = 0;\n        Q.offer(new SNode(s, dis[s]));\n        while (!Q.isEmpty()) {\n            SNode u = Q.poll();\n            if (done[u.id])\n                continue;\n            done[u.id] = true;\n            for (Edge y : e[u.id]) {\n                if (done[y.to])\n                    continue;\n                if (dis[y.to] > y.w + u.n_dis) {\n                    dis[y.to] = y.w + u.n_dis;\n                    Q.offer(new SNode(y.to, dis[y.to]));\n                    pre[y.to] = u.id;\n                }\n            }\n        }\n        // printPath(s, n);\n    }\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        n = Integer.parseInt(st.nextToken());\n        m = Integer.parseInt(st.nextToken());\n        for (int i = 1; i <= n; i++)\n            e[i] = new ArrayList<>();\n        for (int i = 1; i <= m; i++) {\n            st = new StringTokenizer(br.readLine());\n            int u = Integer.parseInt(st.nextToken());\n            int v = Integer.parseInt(st.nextToken());\n            long w = Long.parseLong(st.nextToken());\n            e[u].add(new Edge(u, v, w));\n            // e[v].add(new Edge(v, u, w)); //本题是单向道路\n        }\n        dijkstra();\n        for (int i = 1; i <= n; i++) {\n            if (dis[i] >= INF)\n                System.out.print(\"-1 \");\n            else\n                System.out.print(dis[i] + \" \");\n        }\n    }\n}\nimport heapq\n\nINF = 0x3f3f3f3f3f3f3f3f\nN = 300002\n\nclass Edge:\n    def __init__(self, fr, to, w):\n        self.fr = fr\n        self.to = to\n        self.w = w\n\nclass SNode:\n    def __init__(self, id, n_dis):\n        self.id = id\n        self.n_dis = n_dis\n\n    def __lt__(self, other):\n        return self.n_dis < other.n_dis\n\ndef print_path(s, t):\n    if s == t:\n        print(s, end=\" \")\n        return\n    print_path(s, pre[t])\n    print(t, end=\" \")\n\ndef dijkstra():\n    s = 1\n    done = [False] * N\n    dis = [INF] * N\n    pre = [-1] * N\n    dis[s] = 0\n    pq = []\n    heapq.heappush(pq, SNode(s, dis[s]))\n    while pq:\n        u = heapq.heappop(pq)\n        if done[u.id]:\n            continue\n        done[u.id] = True\n        for y in e[u.id]:\n            if done[y.to]:\n                continue\n            if dis[y.to] > y.w + u.n_dis:\n                dis[y.to] = y.w + u.n_dis\n                heapq.heappush(pq, SNode(y.to, dis[y.to]))\n                pre[y.to] = u.id\n    for i in range(1, n+1):\n        if dis[i] >= INF:\n            print(\"-1\", end=\" \")\n        else:\n            print(dis[i], end=\" \")\n\nn, m = map(int, input().split())\ne = [[] for _ in range(N)]\nfor i in range(m):\n    u, v, w = map(int, input().split())\n    e[u].append(Edge(u, v, w))\n\ndijkstra()\n```\n\n### Bellman-Ford 算法 ###\n\nBFS 的扩散思想，每个人都去问自己的相邻节点到 `S` 点的距离最近是多少。\n\n第一轮至少有一个点得到了到 `S` 的最短距离，即与 `S` 相邻的节点，标记为 `T1`\n\n重复以上操作，那么必然至少又有一个节点找到了与 `S` 的最短距离，即与 `T1` 相邻的节点，标记为 `T2`\n\n**一共需要几轮操作？**\n\n每一轮操作，都至少有一个新的结点得到了到 `S` 的最短路径。所以，最多只需要 `n` 轮操作，就能完成 `n` 个结点。在每一轮操作中，需要检查所有 `m` 个边，更新最短距离。\n\nBellman-Ford 算法的复杂度：`O(nm)`。\n\n**Bellman-Ford 能判断负圈：**\n\n没有负圈时，只需要 `n` 轮就结束。\n\n如果超过 `n` 轮，最短路径还有变化，那么肯定有负圈。\n\n#### SPFA 算法 ####\n\n队列优化版的 Bellman-Ford\n\nSPFA = 队列处理+Bellman-Ford。\n\nBellman-Ford 算法有很多低效或无效的操作。其核心内容，是在每一轮操作中，更新所有结点到起点 `S` 的最短距离。 计算和调整一个结点 `U` 到 `S` 的最短距离后，如果紧接着调整 `U` 的邻居结点，这些邻居肯定有新的计算结果；而如果漫无目的地计算不与 `U` 相邻的结点，很可能毫无变化，所以这些操作是低效的。\n\n**改进：** 计算结点 `U` 之后，下一步只计算和调整它的邻居，能加快收敛的过程。 这些步骤用队列进行操作，这就是 SPFA。\n\n（1）起点 `S` 入队，计算它所有邻居到 `S` 的最短距离。把 `S` 出队，状态有更新的邻居入队，没更新的不入队。 （2）现在队列的头部是 `S` 的一个邻居 `U`。弹出 `U`，更新它所有邻居的状态，把其中有状态变化的邻居入队列。 （3）继续以上过程，直到队列空。这也意味着，所有结点的状态都不再更新。最后的状态就是到起点 `S` 的最短路径。\n\n弹出 `U` 之后，在后面的计算中，`U` 可能会再次更新状态（后来发现，`U` 借道别的结点去 `S`，路更近）。所以，`U` 可能需要重新入队列。 有可能只有很少结点重新进入队列，也有可能很多。这取决于图的特征。\n\n**所以，SPFA 是不稳定的,所以根据题目的类型，我们要选择合适的算法。**\n\n**SPFA 模板如下：**\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\nconst int N = 5e3+10;\nstruct edge{\n    int to;    long long w;\n    edge(int tt,long long ww) {to = tt; w = ww;}\n};\nlong long dist[N];\nint inq[N];\nvector<edge> e[N];\nvoid spfa(int s){\n    memset(dist,0x3f,sizeof(dist));\n    dist[s] = 0;      //起点到自己的距离是0\n    queue<int> q;\n    q.push(s);        //从s开始，s进队列\n    inq[s] = 1;       //起点在队列中\n    while(!q.empty()) {\n        int u = q.front();\n        q.pop();\n        inq[u] = 0;   //u已经不在队列中\n        if(dist[u] == INF)     continue;\n        for(int i = 0;i < e[u].size();i++) {   //遍历u的邻居\n            int v = e[u][i].to;\n            long long w = e[u][i].w;\n            if(dist[v] > dist[u]+w) {         //u的第i个邻居v，它借道u，到s更近\n                dist[v] = dist[u]+w;          //更新邻居v到s的距离\n                if(!inq[v]) {      //邻居v更新状态了，但v不在队列中，放进队列\n                    q.push(v);\n                    inq[v] = 1;\n                }\n            }\n        }\n    }\n}\nint main(){\n    int n,m,s;cin>>n>>m>>s;\n    for(int i = 1;i <= m;i++)    {\n        int u,v; long long w;\n        cin>>u>>v>>w;\n        e[u].push_back(edge(v,w));\n    }\n    spfa(s);\n    for(int i = 1;i <= n;i++) {\n        if(dist[i]==INF)  cout << -1;\n        else              cout << dist[i];\n        if(i != n)        cout << \" \";\n        else              cout << endl;\n    }\n    return 0;\n}\nimport java.util.*;\n\npublic class Main {\n    static final long INF = 0x3f3f3f3f3f3f3f3fL;\n    static final int N = 5010;\n\n    static long[] dist = new long[N];\n    static int[] inq = new int[N];\n    static List<edge>[] e = new ArrayList[N];\n\n    static class edge {\n        int to;\n        long w;\n\n        public edge(int tt, long ww) {\n            to = tt;\n            w = ww;\n        }\n    }\n\n    static void spfa(int s) {\n        Arrays.fill(dist, INF);\n        dist[s] = 0;\n        Queue<Integer> q = new LinkedList<>();\n        q.add(s);\n        inq[s] = 1;\n        while (!q.isEmpty()) {\n            int u = q.poll();\n            inq[u] = 0;\n            if (dist[u] == INF) continue;\n            for (int i = 0; i < e[u].size(); i++) {\n                int v = e[u].get(i).to;\n                long w = e[u].get(i).w;\n                if (dist[v] > dist[u] + w) {\n                    dist[v] = dist[u] + w;\n                    if (inq[v] == 0) {\n                        q.add(v);\n                        inq[v] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int s = in.nextInt();\n        for (int i = 1; i <= n; i++) {\n            e[i] = new ArrayList<>();\n        }\n        for (int i = 1; i <= m; i++) {\n            int u = in.nextInt();\n            int v = in.nextInt();\n            long w = in.nextLong();\n            e[u].add(new edge(v, w));\n        }\n        spfa(s);\n        for (int i = 1; i <= n; i++) {\n            if (dist[i] == INF) System.out.print(\"-1 \");\n            else System.out.print(dist[i] + \" \");\n        }\n    }\n}\nimport heapq\n\nINF = 0x3f3f3f3f3f3f3f3f\nN = 5010\n\nclass Edge:\n    def __init__(self, to, w):\n        self.to = to\n        self.w = w\n\ndist = [INF] * N\ninq = [0] * N\ne = [[] for _ in range(N)]\n\ndef spfa(s):\n    global dist\n    global inq\n    dist = [INF] * N\n    dist[s] = 0\n    q = []\n    heapq.heappush(q, s)\n    inq[s] = 1\n    while q:\n        u = heapq.heappop(q)\n        inq[u] = 0\n        if dist[u] == INF:\n            continue\n        for i in range(len(e[u])):\n            v = e[u][i].to\n            w = e[u][i].w\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                if inq[v] == 0:\n                    heapq.heappush(q, v)\n                    inq[v] = 1\n\nn, m, s = map(int, input().split())\nfor i in range(m):\n    u, v, w = map(int, input().split())\n    e[u].append(Edge(v, w))\nspfa(s)\nfor i in range(1, n+1):\n    if dist[i] == INF:\n        print(\"-1\", end=\" \")\n    else:\n        print(dist[i], end=\" \")\n```\n\n### 总结 ###\n\nDijkstra：适用于权值为非负的图的单源最短路径，用斐波那契堆的复杂度 `O(E+VlgV)` BellmanFord：适用于权值有负值的图的单源最短路径，并且能够检测负圈，复杂度 `O(VE)` SPFA：适用于权值有负值，且没有负圈的图的单源最短路径。论文中的复杂度为 `O(kE)`, 其中 `k` 为每个节点进入队列的次数，且 `k` 一般 `<=2`，但此处的复杂度证明是有问题的，其实 SPFA 的最坏情况应该是 `O(VE)`。 Floyd：每对节点之间的最短路径。\n\n**所以：**\n\n单源最短路 (1)当权值为非负时，用 `Dijkstra`。 (2)当权值有负值，且没有负圈，则用 `SPFA`。`SPFA` 能检测负圈，但是不能输出负圈。 (3)当权值有负值，而且可能存在负圈需要输出，则用 `BellmanFord`。能够检测并输出负圈。 多源最短路使用 `Floyd`\n\n## 最小生成树 ##\n\n在无向图中，连通而且不含有圈（环路）的图，称为树。 最小生成树 MST：一个有 `n` 个结点的连通图的生成树是原图的极小连通子图，包含原图中的所有 `n` 个结点，并且边的权值之和最小。\n\n### Prim 算法 ###\n\n对点进行贪心操作：“最近的邻居一定在 MST 上”。 从任意一个点 `u` 开始，把距离它最近的点 `v` 加入到 MST 中；下一步，把距离 {`u, v`} 最近的点 `w` 加入到 MST 中；继续这个过程，直到所有点都在 MST 中。\n\n```c\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst int MAXN = 1005;\nvector<int> demo;\nint closest[MAXN],lowcost[MAXN],m,n;//m为节点的个数，n为边的数量\nint G[MAXN][MAXN];//邻接矩阵\nint prim()\n{\n    for(int i=0;i<m;i++)\n    {\n        lowcost[i] = INF;\n    }\n    for(int i=0;i<m;i++)\n    {\n        closest[i] = 0;\n    }\n    closest[0] = -1;//加入第一个点，-1表示该点在集合U中，否则在集合V中\n    int num = 0,ans = 0,e = 0;//e为最新加入集合的点\n    while (num < m-1)//加入m-1条边\n    {\n        int micost = INF,miedge = -1;\n        for(int i=0;i<m;i++)\n        if(closest[i] != -1)\n        {\n            int temp = G[e][i];\n            if(temp < lowcost[i])\n            {\n                lowcost[i] = temp;\n                closest[i] = e;\n            }\n            if(lowcost[i] < micost)\n            micost = lowcost[miedge=i];\n        }\n        ans += micost;\n        demo.push_back(micost);\n        closest[e = miedge] = -1;\n        num++;\n    }\n    return ans;\n}\n\nint main()\n{\n\n    scanf(\"%d %d\", &m, &n);\n    memset(G,INF,sizeof(G));\n    for(int i = 0; i < n; ++i)\n    {\n       int a,b,c;\n       cin>>a>>b>>c;\n\n       G[b][a]=G[a][b]=c;\n\n    }\n\n    cout<<prim()<<endl;\n    for(int i=0;i<m-1;i++) cout<<demo[i]<<\" \";\n    return 0;\n}\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    private static final int INF = 0x3f3f3f3f;\n    private static final int MAXN = 1005;\n    private static int[] closest = new int[MAXN];\n    private static int[] lowcost = new int[MAXN];\n    private static int[][] G = new int[MAXN][MAXN];\n    private static int m;\n    private static List demo = new ArrayList();\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        m = scanner.nextInt();\n        int n = scanner.nextInt();\n\n        for (int i = 0; i < n; ++i) {\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            int c = scanner.nextInt();\n            G[b][a] = G[a][b] = c;\n        }\n\n        System.out.println(prim());\n        for (int i = 0; i < m - 1; i++) {\n            System.out.print(demo.get(i) + \" \");\n        }\n    }\n\n    private static int prim() {\n        for (int i = 0; i < m; i++) {\n            lowcost[i] = INF;\n            closest[i] = 0;\n        }\n\n        closest[0] = -1;//加入第一个点，-1表示该点在集合U中，否则在集合V中\n        int num = 0, ans = 0, e = 0;//e为最新加入集合的点\n\n        while (num < m - 1)//加入m-1条边\n        {\n            int micost = INF, miedge = -1;\n            for (int i = 0; i < m; i++) {\n                if (closest[i] != -1) {\n                    int temp = G[e][i];\n                    if (temp < lowcost[i]) {\n                        lowcost[i] = temp;\n                        closest[i] = e;\n                    }\n                    if (lowcost[i] < micost) {\n                        micost = lowcost[miedge = i];\n                    }\n                }\n            }\n            ans += micost;\n            demo.add(micost);\n            closest[e = miedge] = -1;\n            num++;\n        }\n        return ans;\n    }\n}\nINF = 0x3f3f3f3f\nMAXN = 1005\nclosest = [0] * MAXN\nlowcost = [0] * MAXN\nG = [[INF] * MAXN for _ in range(MAXN)]\ndemo = []\n\nm,n = map(int, input().split())\n\nfor i in range(n):\n    a,b,c = map(int, input().split())\n    G[b][a]=G[a][b]=c\n\ndef prim():\n    global closest, lowcost, G, m\n    for i in range(m):\n        lowcost[i] = INF\n        closest[i] = 0\n\n    closest[0] = -1\n    num = 0\n    ans = 0\n    e = 0\n\n    while num < m-1:\n        micost = INF\n        miedge = -1\n        for i in range(m):\n            if closest[i] != -1:\n                temp = G[e][i]\n                if temp < lowcost[i]:\n                    lowcost[i] = temp\n                    closest[i] = e\n                if lowcost[i] < micost:\n                    miedge=i\n                    micost = lowcost[miedge]\n        ans += micost\n        demo.append(micost)\n        e = miedge\n        closest[e] = -1\n        num += 1\n\n    return ans\n\nprint(prim())\nfor i in range(m - 1): print(demo[i], end=' ')\n```\n\n### kruskal 算法 ###\n\n对边进行贪心操作：“最短的边一定在 `MST` 上”。 从最短的边开始，把它加入到 `MST` 中；在剩下的边中找最短的边，加入到 `MST` 中；继续这个过程，直到所有点都在 `MST` 中。\n\n`kruskal` 算法的 2 个关键技术： （1）对边进行排序。 （2）判断圈，即处理连通性问题。这个问题用并查集简单而高效，并查集是 `kruskal` 算法的实现基础。\n\n初始时最小生成树 `MST` 为空。开始的时候，每个点属于独立的集。\n\n按边长从小到大进行边的遍历操作：\n\n尝试将最小边加入最小生成树：\n\n- 如果边的两个端点属于同一个集合，就说明这两个点已经被加入最小生成树。则不能将边加入，否则就会生成一个环。\n- 如果两个端点不属于同一个集合，就说明该点还未纳入最小生成树，此边可以加入。\n\n重复上述操作，直到加入 `n-1` 条边。\n\n`kruskal` 算法的复杂度包括两部分：对边的排序 `O(ElogE)`，并查集的操作 `O(E)`，一共是 `O(ElogE + E)`，约等于 `O(ElogE)`，时间主要花在排序上。\n\n如果图的边很多，`kruskal` 的复杂度要差一些。`kruskal` 适用于稀疏图，`prim` 适合稠密图。\n\n**模板如下：**\n\n```c\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nint father[1100000];\nstruct node\n{\n    int x;\n    int y;\n    int k;\n} Q[1100000];\n\nint find(int x)\n{\n    if (father[x] == x)\n        return x;\n    return father[x] = find(father[x]);\n}\nbool cmp(node a, node b)\n{\n    return a.k < b.k;\n}\nint main()\n{\n    scanf(\"%d %d\", &n, &m);\n\n    int cont = 0,\n        sum = 0, st = 0;\n    for (int i = 0; i < m; i++)\n    {\n        scanf(\"%d %d %d\", &Q[i].x, &Q[i].y, &Q[i].k);\n        cont += Q[i].k;\n    }\n    sort(Q, Q + m, cmp);\n    for (int i = 1; i <= n; i++)\n        father[i] = i;\n    for (int i = 0; i < m; i++)\n    {\n        int tx = find(Q[i].x);\n        int ty = find(Q[i].y);\n        if (tx != ty)\n        {\n            sum += Q[i].k;\n            st++;\n            father[tx] = ty;\n            if (st == n - 1)\n                break;\n        }\n    }\n    printf(\"%d\\n\", sum);\n    return 0;\n}\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    static int n, m;\n    static int[] father;\n    static Node[] Q;\n\n    static class Node {\n        int x;\n        int y;\n        int k;\n\n        public Node(int x, int y, int k) {\n            this.x = x;\n            this.y = y;\n            this.k = k;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        n = scanner.nextInt();\n        m = scanner.nextInt();\n\n        father = new int[n + 1];\n        Q = new Node[m];\n\n        int cont = 0, sum = 0, st = 0;\n        for (int i = 0; i < m; i++) {\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            int k = scanner.nextInt();\n            Q[i] = new Node(x, y, k);\n            cont += k;\n        }\n        Arrays.sort(Q, (a, b) -> a.k - b.k);\n        for (int i = 1; i <= n; i++)\n            father[i] = i;\n        for (int i = 0; i < m; i++) {\n            int tx = find(Q[i].x);\n            int ty = find(Q[i].y);\n            if (tx != ty) {\n                sum += Q[i].k;\n                st++;\n                father[tx] = ty;\n                if (st == n - 1)\n                    break;\n            }\n        }\n        System.out.println(sum);\n    }\n\n    static int find(int x) {\n        if (father[x] == x)\n            return x;\n        return father[x] = find(father[x]);\n    }\n\n}\nn, m = map(int, input().split())\n\nfather = [i for i in range(n+1)]\n\nQ = []\n\ncont = 0\nsum = 0\nst = 0\n\nfor i in range(m):\n    x, y, k = map(int, input().split())\n    Q.append({'x': x, 'y': y, 'k': k})\n    cont += k\n\nQ.sort(key=lambda x:x['k'])\n\ndef find(x):\n\n    if father[x] == x :\n        return x\n    father[x] = find(father[x])\n    return father[x]\n\nfor i in range(m):\n    tx = find(Q[i]['x'])\n    ty = find(Q[i]['y'])\n    if tx != ty:\n        sum += Q[i]['k']\n        st += 1\n        father[tx] = ty\n        if st == n - 1:\n            break\nprint(sum)\n```\n\n------\n\nshow: step version: 1.0 enable_checker: true\n\n------\n\n# 图论例题 #\n\n## 蓝桥王国 lanqiaoOJ 题号 1122 ##\n\n**题目描述**\n\n蓝桥王国一共有 (N) 个建筑和 (M) 条单向道路，每条道路都连接着两个建筑，每个建筑都有自己编号，分别为 (1 \\sim N)。（其中皇宫的编号为 1）国王想让小明回答从皇宫到每个建筑的最短路径是多少，但紧张的小明此时已经无法思考，请你编写程序帮助小明回答国王的考核。\n\n**输入描述**\n\n输入第一行包含 2 个正整数 (N,M)。第 2 到 (M+1) 行每行包含三个正整数 (u,v,w)，表示 (u \\to v) 之间存在一条距离为 (w) 的路。(1 \\leq N \\leq 3 \\times 10^5)，(1 \\leq M \\leq 10^6)，(1 \\leq u_i , v_i \\leq N)，(0 \\leq w_i \\leq 10^9)。\n\n**输出描述**\n\n输出仅一行，共 (N) 个数，分别表示从皇宫到编号为 (1 \\sim N) 建筑的最短距离，两两之间用空格隔开。（如果无法到达则输出 −1）\n\n**解题思路:**\n\n本题为单源最短路的模板题，直接套模板即可，本题我们采用 Dijkstra。\n\nC++ 语言描述:\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst long long INF = 0x3f3f3f3f3f3f3f3fLL;\n//这样定义INF的好处是: INF <= INF+x\nconst int N= 3e5+2;\nstruct edge{\n    int from, to; long long w; //起点，终点，权值。起点from并没有用到，e[i]的i就是from\n    edge(int a, int b,long long c){from=a; to=b; w=c;}\n};\nvector<edge>e[N];          //用于存储图\nstruct s_node{\n    int id; long long n_dis;   //id：结点；n_dis：这个结点到起点的距离\n    s_node(int b,long long c){id=b; n_dis=c;}\n    bool operator < (const s_node & a) const\n    { return n_dis > a.n_dis;}\n};\nint n,m;\nint pre[N];                                //记录前驱结点，用于生成路径\nvoid print_path(int s, int t) {            //打印从s到t的最短路\n    if(s==t){ printf(\"%d \", s); return; }  //打印起点\n    print_path(s, pre[t]);                 //先打印前一个点\n    printf(\"%d \", t);                      //后打印当前点。最后打印的是终点t\n}\nlong long  dis[N];         //记录所有结点到起点的距离\nvoid dijkstra(){\n    int s = 1;             //起点s是1\n    bool done[N]; //done[i]=true表示到结点i的最短路径已经找到\n    for (int i=1;i<=n;i++) {dis[i]=INF; done[i]=false; }    //初始化\n    dis[s]=0;                           //起点到自己的距离是0\n    priority_queue <s_node> Q;          //优先队列，存结点信息\n    Q.push(s_node(s, dis[s]));          //起点进队列\n    while (!Q.empty())   {\n        s_node u = Q.top();             //pop出距起点s距离最小的结点u\n        Q.pop();\n        if(done[u.id])  continue;       //丢弃已经找到最短路径的结点。即集合A中的结点\n        done[u.id]= true;\n        for (int i=0; i<e[u.id].size(); i++) {  //检查结点u的所有邻居\n            edge y = e[u.id][i];         //u.id的第i个邻居是y.to\n            if(done[y.to])  continue;    //丢弃已经找到最短路径的邻居结点\n            if (dis[y.to] > y.w + u.n_dis) {\n                dis[y.to] = y.w + u.n_dis;\n                Q.push(s_node(y.to, dis[y.to]));  //扩展新的邻居，放到优先队列中\n                pre[y.to]=u.id;  //如果有需要，记录路径\n            }\n        }\n    }\n    // print_path(s,n);          //如果有需要，打印路径: 起点1，终点n\n}\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1;i<=n;i++)    e[i].clear();\n    while (m--) {\n        int u,v,w;  scanf(\"%d%d%lld\",&u,&v,&w);\n        e[u].push_back(edge(u,v,w));\n     // e[v].push_back(edge(v,u,w));    //本题是单向道路\n    }\n    dijkstra();\n    for(int i=1;i<=n;i++){\n        if(dis[i]>=INF)  cout<<\"-1 \";\n        else   printf(\"%lld \", dis[i]);\n    }\n}\n```\n\nPython 语言描述:\n\n```python\nimport heapq\n\nINF = 0x3f3f3f3f3f3f3f3f\nN = 300002\n\nclass Edge:\n    def __init__(self, fr, to, w):\n        self.fr = fr\n        self.to = to\n        self.w = w\n\nclass SNode:\n    def __init__(self, id, n_dis):\n        self.id = id\n        self.n_dis = n_dis\n\n    def __lt__(self, other):\n        return self.n_dis < other.n_dis\n\ndef print_path(s, t):\n    if s == t:\n        print(s, end=\" \")\n        return\n    print_path(s, pre[t])\n    print(t, end=\" \")\n\ndef dijkstra():\n    s = 1\n    done = [False] * N\n   \n\n dis = [INF] * N\n    pre = [-1] * N\n    dis[s] = 0\n    pq = []\n    heapq.heappush(pq, SNode(s, dis[s]))\n    while pq:\n        u = heapq.heappop(pq)\n        if done[u.id]:\n            continue\n        done[u.id] = True\n        for y in e[u.id]:\n            if done[y.to]:\n                continue\n            if dis[y.to] > y.w + u.n_dis:\n                dis[y.to] = y.w + u.n_dis\n                heapq.heappush(pq, SNode(y.to, dis[y.to]))\n                pre[y.to] = u.id\n    for i in range(1, n+1):\n        if dis[i] >= INF:\n            print(\"-1\", end=\" \")\n        else:\n            print(dis[i], end=\" \")\n\nn, m = map(int, input().split())\ne = [[] for _ in range(N)]\nfor i in range(m):\n    u, v, w = map(int, input().split())\n    e[u].append(Edge(u, v, w))\n\ndijkstra()\n```\n\nJava 语言描述:\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final long INF = 0x3f3f3f3f3f3f3f3fL;\n    static final int N = 300005;\n    static ArrayList<Edge>[] e = new ArrayList[N];\n    static int n, m;\n    static int[] pre = new int[N];\n    static long[] dis = new long[N];\n    static boolean[] done = new boolean[N];\n\n    static class Edge {\n        int from, to;\n        long w;\n\n        Edge(int a, int b, long c) {\n            from = a;\n            to = b;\n            w = c;\n        }\n    }\n\n    static class SNode implements Comparable<SNode> {\n        int id;\n        long n_dis;\n\n        SNode(int b, long c) {\n            id = b;\n            n_dis = c;\n        }\n\n        public int compareTo(SNode o) {\n            return Long.compare(n_dis, o.n_dis);\n        }\n    }\n\n    static void printPath(int s, int t) {\n        if (s == t) {\n            System.out.print(s + \" \");\n            return;\n        }\n        printPath(s, pre[t]);\n        System.out.print(t + \" \");\n    }\n\n    static void dijkstra() {\n        int s = 1;\n        PriorityQueue<SNode> Q = new PriorityQueue<>();\n        Arrays.fill(dis, INF);\n        dis[s] = 0;\n        Q.offer(new SNode(s, dis[s]));\n        while (!Q.isEmpty()) {\n            SNode u = Q.poll();\n            if (done[u.id])\n                continue;\n            done[u.id] = true;\n            for (Edge y : e[u.id]) {\n                if (done[y.to])\n                    continue;\n                if (dis[y.to] > y.w + u.n_dis) {\n                    dis[y.to] = y.w + u.n_dis;\n                    Q.offer(new SNode(y.to, dis[y.to]));\n                    pre[y.to] = u.id;\n                }\n            }\n        }\n        // printPath(s, n);\n    }\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        n = Integer.parseInt(st.nextToken());\n        m = Integer.parseInt(st.nextToken());\n        for (int i = 1; i <= n; i++)\n            e[i] = new ArrayList<>();\n        for (int i = 1; i <= m; i++) {\n            st = new StringTokenizer(br.readLine());\n            int u = Integer.parseInt(st.nextToken());\n            int v = Integer.parseInt(st.nextToken());\n            long w = Long.parseLong(st.nextToken());\n            e[u].add(new Edge(u, v, w));\n            // e[v].add(new Edge(v, u, w)); //本题是单向道路\n        }\n        dijkstra();\n        for (int i = 1; i <= n; i++) {\n            if (dis[i] >= INF)\n                System.out.print(\"-1 \");\n            else\n                System.out.print(dis[i] + \" \");\n        }\n    }\n}\n```\n\n## 随机数据下的最短路问题 lanqiaoOJ 题号 1366 ##\n\n**题目描述**\n\n给定 (N) 个点和 (M) 条单向道路，每条道路都连接着两个点，每个点都有自己编号，分别为 (1 \\sim N)。问你从 (S) 点出发，到达每个点的最短路径为多少。\n\n**输入描述**\n\n输入第一行包含三个正整数 (N,M,S)。第 2 到 (M+1) 行每行包含三个正整数 (u,v,w)，表示 (u \\to v) 之间存在一条距离为 (w) 的路。(1 \\leq N \\leq 5 \\times 10^3)，(1 \\leq M \\leq 5 \\times 10^4)，(1 \\leq u_i, v_i \\leq N)，(0 \\leq w_i \\leq 10^9)。\n\n**输出描述**\n\n输出仅一行，共 (N) 个数，分别表示从编号 (S) 到编号为 (1 \\sim N) 点的最短距离，两两之间用空格隔开。（如果无法到达则输出 −1）\n\n**解题思路:**\n\n本题为单源最短路的模板题，直接套模板即可，本题我们采用 SPFA。\n\nC++ 语言描述:\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\nconst int N = 5e3+10;\nstruct edge{\n    int to;    long long w;\n    edge(int tt,long long ww) {to = tt; w = ww;}\n};\nlong long dist[N];\nint inq[N];\nvector<edge> e[N];\nvoid spfa(int s){\n    memset(dist,0x3f,sizeof(dist));\n    dist[s] = 0;      //起点到自己的距离是0\n    queue<int> q;\n    q.push(s);        //从s开始，s进队列\n    inq[s] = 1;       //起点在队列中\n    while(!q.empty()) {\n        int u = q.front();\n        q.pop();\n        inq[u] = 0;   //u已经不在队列中\n        if(dist[u] == INF)     continue;\n        for(int i = 0;i < e[u].size();i++) {   //遍历u的邻居\n            int v = e[u][i].to;\n            long long w = e[u][i].w;\n            if(dist[v] > dist[u]+w) {         //u的第i个邻居v，它借道u，到s更近\n                dist[v] = dist[u]+w;          //更新邻居v到s的距离\n                if(!inq[v]) {      //邻居v更新状态了，但v不在队列中，放进队列\n                    q.push(v);\n                    inq[v] = 1;\n                }\n            }\n        }\n    }\n}\nint main(){\n    int n,m,s;cin>>n>>m>>s;\n    for(int i = 1;i <= m;i++)    {\n        int u,v; long long w;\n        cin>>u>>v>>w;\n        e[u].push_back(edge(v,w));\n    }\n    spfa(s);\n    for(int i = 1;i <= n;i++) {\n        if(dist[i]==INF)  cout << -1;\n        else              cout << dist[i];\n        if(i != n)        cout << \" \";\n        else              cout << endl;\n    }\n    return 0;\n}\n```\n\nPython 语言描述:\n\n```python\nimport heapq\n\nINF = 0x3f3f3f3f3f3f3f3f\nN = 5010\n\nclass Edge:\n    def __init__(self, to, w):\n        self.to = to\n        self.w = w\n\ndist = [INF] * N\ninq = [0] * N\ne = [[] for _ in range(N)]\n\ndef spfa(s):\n    global dist\n    global inq\n    dist = [INF] * N\n    dist[s] = 0\n    q = []\n    heapq.heappush(q, s)\n    inq[s] = 1\n    while q:\n        u = heapq.heappop(q)\n        inq[u] = 0\n        if dist[u] == INF:\n            continue\n        for i in range(len(e[u])):\n            v = e[u][i].to\n            w = e[u][i].w\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                if inq[v] == 0:\n                    heapq.heappush(q, v)\n                    inq[v] = 1\n\nn, m, s = map(int, input().split())\nfor i in range(m):\n    u, v, w = map(int, input().split())\n    e[u].append(Edge(v, w))\nspfa(s)\nfor i in range(1, n+1):\n    if dist[i] == INF:\n        print(\"-1\", end=\" \")\n    else:\n        print(dist[i], end=\" \")\n```\n\nJava 语言描述:\n\n```java\nimport java.util.*;\n\npublic class Main {\n    static final long INF = 0x3f3f3f3f3f3f3f3fL;\n    static final int N = 5010;\n\n    static long[] dist = new long[N];\n    static int[] inq = new int[N];\n    static List<edge>[] e = new ArrayList[N];\n\n    static class edge {\n        int to;\n        long w;\n\n        public edge(int tt, long ww) {\n            to = tt;\n            w = ww;\n        }\n    }\n\n    static void spfa(int s) {\n        Arrays.fill(dist, INF);\n        dist[s] = 0;\n        Queue<Integer> q = new LinkedList<>();\n        q.add(s);\n        inq[s] = 1;\n        while (!q.isEmpty()) {\n            int u = q.poll();\n            inq[u] = 0;\n            if (dist[u] == INF) continue;\n            for (int i = 0; i < e[u].size(); i++) {\n                int v = e[u].get(i).to;\n                long w = e[u].get(i).w;\n                if (dist[v] > dist[u] + w) {\n                    dist[v] = dist[u] + w;\n                    if (inq[v] == 0) {\n                        q.add(v);\n                        inq[v] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int s = in.nextInt();\n        for (int i = 1; i <= n; i++) {\n            e[i] = new ArrayList<>();\n        }\n        for (int i = 1; i <= m; i++) {\n            int u = in.nextInt();\n            int v = in.nextInt();\n            long w = in.nextLong();\n            e[u].add(new edge(v, w));\n        }\n        spfa(s);\n        for (int i = 1; i <= n; i++) {\n            if (dist[i] == INF) System.out.print(\"-1 \");\n            else System.out.print(dist[i] + \" \");\n        }\n    }\n}\n```\n\n## 路径 OJ 编号 1460 ##\n\n![图片描述](./../imgs/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8/e77a71de068da604d1245d5231201326-0.png)\n\n**解题思路:**\n\n填空题对时间没有要求，用最简单的 floyd\n\nC++ 语言描述:\n\n```c++\n#include<bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int N = 3000;\nconst ll INF = 1e18;\nll mp[N][N];\nvoid floyd(int n){\n    for(int k = 1;k <= n;k++)\n        for(int i = 1;i <= n;i++)\n            for(int j = 1;j <= n;j++)\n                mp[i][j] = min(mp[i][j], mp[i][k] + mp[k][j]);\n}\nint main(){\n    int n = 2021;\n    for(int i = 1;i <= n;i++){\n        for(int j = 1;j <= n;j++){\n            if(i == j) mp[i][j] = 0;\n            else if(abs(i - j)<=21) mp[i][j]=mp[j][i]=i*j/__gcd(i, j);\n            else mp[i][j] = mp[j][i] = INF;\n        }\n    }\n    floyd(n);\n    cout << mp[1][2021];\n    return 0;\n}\n```\n\nPython 语言描述:\n\n```python\nimport math\n\ndef lcm(a, b):\n    return int(a * b / math.gcd(a, b))\n\nn = 2021\ng = [[0 for i in range(1, n + 2)] for j in range(1, n + 2)]\nfor i in range(1, n + 1):\n    for j in range(1, n + 1):\n        if i == j:\n            g[i][j] = g[j][i] = 0\n        elif abs(i - j) <= 21:\n            g[i][j] = g[j][i] = lcm(i, j)\n        else:\n            g[i][j] = 1000000000\nfor k in range(1, n + 1):\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if g[i][j] > g[i][k] + g[k][j]:\n                g[i][j] = g[i][k] + g[k][j]\nprint(g[1][n])\n```\n\nJava 语言描述:\n\n```java\npublic class Main {\n\n    static final int n = 2021;\n\n    static int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    static int lcm(int a, int b) {\n        return a * b / gcd(a, b);\n    }\n\n    public static void main(String[] args) {\n        int[][] floyd = new int[n][n];\n        for (int i = 0; i < n; i++)\n            for (int j = i + 1; j < n && j < i + 22; j++)\n                floyd[i][j] = floyd[j][i] = lcm(i + 1, j + 1);\n        for (int k = 0; k < n; k++)\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    if (floyd[i][k] != 0 && floyd[k][j] != 0 && (floyd[i][j] == 0 || floyd[i][k] + floyd[k][j] < floyd[i][j]))\n                        floyd[i][j] = floyd[i][k] + floyd[k][j];\n        System.out.println(floyd[0][n - 1]);\n    }\n}\n```\n\n## 出差 ##\n\n![图片描述](./../imgs/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8/6fab239959de9ee1ffb4d57d7654fabf-0.png)\n\n**解题思路:**\n\n![图片描述](./../imgs/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8/a28b434cf3a3579931db1586e3d0d710-0.png)\n\n我们这里给大家一个朴素的 dijkstra 的模板，大家感受一下，优先队列到底优化的那一部分。\n\nC++ 语言描述:\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1010;\n\n//邻接矩阵\nint gra[N][N];\nint dist[N];\nint g[N];\nbool st[N];\nint n,m;\n//朴素版dijkstra\nint dijkstra()\n{\n     memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n\n    for (int i = 0; i < n - 1; i ++ )\n    {\n        int t = -1;\n        for (int j = 1; j <= n; j ++ )\n            if (!st[j] && (t == -1 || dist[t] > dist[j]))\n                t = j;\n        for (int j = 1; j <= n; j ++ )\n            dist[j] = min(dist[j], dist[t] + gra[t][j]);\n        st[t] = true;\n    }\n    return dist[n];\n}\nint main()\n{\n    cin>>n>>m;\n    for(int i=1;i<=n;++i) cin>>g[i];\n    g[n]=0;\n    memset(gra, 0x3f, sizeof gra);\n    for(int i=1;i<=m;++i){\n        int u,v,c;\n        cin>>u>>v>>c;\n        gra[u][v]=g[v]+c;\n        gra[v][u]=g[u]+c;\n    }\n    cout<<dijkstra()<<endl;\n    return 0;\n}\n```\n\nPython 语言描述:\n\n```python\nimport sys\nfrom typing import List\n\nn, m = map(int, input().split())\n\n# 邻接矩阵\ngra = [[float('inf')] * (n+1) for _ in range(n+1)]\ndist = [float('inf')] * (n+1)\ng = [0] + list(map(int, input().split()))\ng[n] = 0\nst = [False] * (n+1)\n\n# 朴素版 Dijkstra\ndef dijkstra() -> int:\n    dist[1] = 0\n\n    for _ in range(n - 1):\n        t = -1\n        for j in range(1, n + 1):\n            if not st[j] and (t == -1 or dist[t] > dist[j]):\n                t = j\n        for j in range(1, n + 1):\n            dist[j] = min(dist[j], dist[t] + gra[t][j])\n        st[t] = True\n    return dist[n]\n\nfor _ in range(m):\n    u, v, c = map(int, input().split())\n    gra[u][v] = g[v] + c\n    gra[v][u] = g[u] + c\n\nprint(dijkstra())\n```\n\nJava 语言描述:\n\n```java\nimport java.util.*;\npublic class Main {\n    static int N = 1010;\n    static int[][] gra = new int[N][N];\n    static int[] dist = new int[N];\n    static int[] g = new int[N];\n    static boolean[] st = new boolean[N];\n    static int n, m;\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        n = scan.nextInt();\n        m = scan.nextInt();\n        for(int i = 1; i <= n; ++i) {\n            g[i] = scan.nextInt();\n        }\n        g[n] = 0;\n        for(int i = 0 ; i < N ; i ++) Arrays.fill(gra[i], 0x3f3f3f);\n        for(int i = 1; i <= m; ++i) {\n            int u = scan.nextInt(), v = scan.nextInt(), c = scan.nextInt();\n            gra[u][v] = g[v] + c;\n            gra[v][u] = g[u] + c;\n        }\n        System.out.println(dijkstra());\n    }\n    private static int dijkstra() {\n        Arrays.fill(dist, 10000000);\n        dist[1] = 0;\n        for(int i = 0; i < n - 1; i++) {\n            int t = -1;\n            for(int j = 1; j <= n; j++) {\n                if(!st[j] && (t == -1 || dist[t] > dist[j])) {\n                    t = j;\n                }\n            }\n            if(t == -1) break;\n            for(int j = 1; j <= n; j++) {\n                dist[j] = Math.min(dist[j], dist[t] + gra[t][j]);\n            }\n            st[t] = true;\n        }\n        return dist[n];\n    }\n}\n```\n\n## 聪明的猴子 ##\n\n![图片描述](./../imgs/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8/ceeb52dc7e8b316134f2c9c7b74b1c11-0.png)\n\n------\n\n**解题思路:**\n\n![图片描述](./../imgs/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8/f77dcab941517e1b3648b7cb3c2fa740-0.png)\n\nC++ 语言描述:\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint a[5005], x[5005], y[5005], f[5005];\nstruct Edge{\n    int x;\n    int y;\n    double w;\n}edge[1000005];\nint find(int x){\n    if (x == f[x])\n        return x;\n    f[x] = find(f[x]);\n    return f[x];\n}\nint cmp(Edge a, Edge b){\n    return a.w < b.w;\n}\nvoid merge(int x, int y){\n    int xx = find(x);\n    int yy = find(y);\n    if (xx != yy)\n        f[yy] = xx;\n}\nint main(){\n    int cnt = 0;\n    int n, m;\n    cin >> m;\n    for (int i = 1; i <= m; i++)\n        cin >> a[i];\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n        cin >> x[i] >> y[i];\n    for (int i = 1; i <= n; i++)\n        f[i] = i;\n    for (int i = 1; i <= n; i++){\n        for (int j = i + 1; j <= n; j++){\n            double w = sqrt((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]));\n            edge[++cnt] = {i, j, w};\n        }\n    }\n    sort(edge + 1, edge + cnt + 1, cmp);\n    int num = 0;\n    double max = 0.0;\n    for (int i = 1; i <= cnt; i++){\n        if (find(edge[i].x)!=find(edge[i].y)){\n            merge(edge[i].x, edge[i].y);\n            num++;\n            max = max>=edge[i].w?max:edge[i].w;\n        }\n        if (num == n - 1)\n            break;\n    }\n    int ans = 0;\n    for (int i = 1; i <= m; i++)\n        if (a[i] >= max)\n            ans++;\n    cout << ans << endl;\n    return 0;\n}\n```\n\nPython 语言描述:\n\n```python\nimport math\n\nclass Edge:\n    x = 0\n    y = 0\n    w = 0.0\n    def __init__(self, x, y, w):\n        self.x = x\n        self.y = y\n        self.w = w\n\ndef find(x):\n    if f[x]==x:\n        return f[x]\n    else:\n        f[x] = find(f[x])\n        return f[x]\n\ndef merge(x,y):\n    xx = find(x)\n    yy = find(y)\n    if xx!=yy:\n        f[yy] = xx\n\nif __name__ == '__main__':\n    m = int(input())\n    a = list(map(int, input().split()))\n    n = int(input())\n    x = [0 for i in range(n + 2)]\n    y = [0 for i in range(n + 2)]\n    for i in range(n):\n        b = list(map(int, input().split()))\n        x[i + 1] = b[0]\n        y[i + 1] = b[1]\n    edge_list = []\n    maxvalue = 0\n    num = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            w = math.sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]))\n            edge =  Edge(i, j, w)\n            edge_list.append(edge)\n\n    edge_list.sort(key=lambda x: x.w)\n    f = [i for i in range(n + 1)]\n    for i in edge_list:\n        if find(i.x)!=find(i.y):\n            merge(i.x,i.y)\n            maxvalue = max(maxvalue,i.w)\n            num+=1\n            if num==n-1:\n                break\n    ans = 0\n    for i in range(m):\n        if a[i]>=maxvalue:\n            ans+=1\n    print(ans)\n```\n\nJava 语言描述:\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class Main {\n    static int ans = 0;\n    static int n;\n    static int[] a;\n    static int m;\n    static int[] x;\n    static int[] y;\n    static double max;\n    static int[] f;\n    static int num = 0;\n    static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n    public static void main(String[] args) throws IOException{\n        m = Integer.parseInt(in.readLine().trim());\n        a = new int[m];\n        String[] s = in.readLine().trim().split(\" \");\n        for(int i=0;i<m;i++)\n            a[i] = Integer.parseInt(s[i]);\n        n = Integer.parseInt(in.readLine().trim());\n        x = new int[n];\n        y = new int[n];\n        for(int i=0;i<n;i++) {\n            s = in.readLine().trim().split(\" \");\n            x[i] = Integer.parseInt(s[0]);\n            y[i] = Integer.parseInt(s[1]);\n        }\n        ArrayList<Edge> list = new ArrayList<>();\n        for(int i=0;i<n-1;i++) {\n            for(int j=i+1;j<n;j++) {\n                double l = Math.sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n                Edge edge = new Edge(i, j, l);\n                list.add(edge);\n            }\n        }\n        Collections.sort(list);\n        f = new int[n];\n        for(int i=0;i<n;i++)\n            f[i] = i;\n        for(int i=0;i<list.size();i++) {\n            Edge e = list.get(i);\n            if(find(e.x)!=find(e.y)) {\n                merge(e.x,e.y);\n                max = Math.max(max, e.w);\n                num++;\n                if(num==n-1)\n                    break;\n            }\n        }\n        for(int i=0;i<m;i++)\n            if(a[i]>=max)\n                ans++;\n        System.out.println(ans);\n    }\n    static int find(int x) {\n        if(f[x] == x)\n            return f[x];\n        f[x] = find(f[x]);\n        return f[x];\n    }\n    static void merge(int x,int y) {\n        int xx = find(x);\n        int yy = find(y);\n        if(xx!=yy)\n            f[yy] = xx;\n    }\n}\nclass Edge implements Comparable<Edge>{\n    int x;\n    int y;\n    double w;\n    public Edge(int x, int y, double w) {\n        super();\n        this.x = x;\n        this.y = y;\n        this.w = w;\n    }\n    @Override\n    public int compareTo(Edge o) {\n        // TODO Auto-generated method stub\n        return this.w>o.w?1:-1;\n    }\n}\n```\n\n## 通电 ##\n\n![图片描述](./../imgs/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8/e0bde279d708165b220cfdf8848e1467-0.png)\n\n**解题思路:**\n\n给了你 `n` 个节点，又给了你 `n` 个基点之间相互连接需要多少钱，现在要 `n` 个村庄都通电，只需要保证 `n` 个节点构成连通子图即可。\n\n最小的连通子图是树，也就是构造一棵树，那么在图上构造一棵最最少花费的树的问题即为最小生成树。\n\nC++ 语言描述:\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst int MAXN = 1005;\nvector<int> demo;\ndouble closest[MAXN], lowcost[MAXN];\nint m, n;             // m为节点的个数，n为边的数量\ndouble G[MAXN][MAXN]; // 邻接矩阵\ndouble prim()\n{\n    for (int i = 0; i < m; i++)\n    {\n        lowcost[i] = INF;\n    }\n    for (int i = 0; i < m; i++)\n    {\n        closest[i] = 0;\n    }\n    closest[0] = -1;             // 加入第一个点，-1表示该点在集合U中，否则在集合V中\n    int num = 0,  e = 0; // e为最新加入集合的点\n    double ans=0;\n    while (num < m - 1)          // 加入m-1条边\n    {\n        int miedge = -1;\n        double micost = INF;\n        for (int i = 0; i < m; i++)\n            if (closest[i] != -1)\n            {\n                double temp = G[e][i];\n                if (temp < lowcost[i])\n                {\n                    lowcost[i] = temp;\n                    closest[i] = e;\n                }\n                if (lowcost[i] < micost)\n                    micost = lowcost[miedge = i];\n            }\n        ans += micost;\n        demo.push_back(micost);\n        closest[e = miedge] = -1;\n        num++;\n    }\n    return ans;\n}\n\nstruct node\n{\n    double x, y, h;\n} dis[MAXN];\n\ndouble getDistance(node a, node b)\n{\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2)) + pow(a.h - b.h, 2);\n}\n\nint main()\n{\n\n    scanf(\"%d\", &m);\n\n    for (int i = 0; i < m; i++)\n        scanf(\"%lf%lf%lf\", &dis[i].x, &dis[i].y, &dis[i].h);\n    for (int i = 0; i < m - 1; i++)\n        for (int j = i + 1; j < m; j++)\n        {\n            G[i][j] = getDistance(dis[i], dis[j]);\n            G[j][i] = G[i][j];\n        }\n\n    printf(\"%.2lf\", prim());\n    // for (int i = 0; i < m - 1; i++)\n    //     cout << demo[i] << \" \";\n    return 0;\n}\n```\n\nPython 语言描述:\n\n```python\nimport os\nimport sys\n\nimport math\ndef caculate(x1,y1,h1,x2,y2,h2):\n    return math.sqrt( (x1-x2)**2+(y1-y2)**2)+(h1-h2)**2\\\n\ndef find(x):\n    if x!=ufs[x]:\n        ufs[x]=find(ufs[x])\n    return ufs[x]\n\ndef kruskal():\n    global ufs\n    ufs=list(range(n+1))\n    my_brige.sort(key=lambda x:x[2])\n    ans=0\n    cnt=0\n    for a,b,w in my_brige:\n        x=find(a)\n        y=find(b)\n        if x==y:\n            continue\n        cnt+=1\n        ans+=w\n        ufs[x]=y\n\n        if cnt==n-1:\n            return ans\n\n\n\nn=int(input())\nbrige=[[] for i in range(n+1)]\nfor i in range(1,n+1):\n    x,y,h=map(int,input().split())\n    brige[i]=(x,y,h)\n\n\nmy_brige=[]\nfor i in range(1,n):\n    for j in range(i+1,n+1):\n        x1,y1,h1=brige[i]\n        x2,y2,h2=brige[j]\n        w=caculate(x1,y1,h1,x2,y2,h2)\n        my_brige.append((i,j,w))\nans=kruskal()\nprint(\"{:.2f}\".format(ans))\n```\n\nJava 语言描述:\n\n```java\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    static int N = 1010;\n    static List<Node> list = new ArrayList<>();\n    static int[] x = new int[N], y = new int[N], z = new int[N];\n    static int n;\n    //并查集数组\n    static int[] q = new int[N];\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        for (int i = 0; i < n; i++) {\n            x[i] = sc.nextInt();\n            y[i] = sc.nextInt();\n            z[i] = sc.nextInt();\n        }\n        //建边  任意两个村庄都要建边\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int l = x[i] - x[j];\n                int r = y[i] - y[j];\n                double c = z[i] - z[j];\n                // i 村庄 到  j 村庄的 距离\n                double s = Math.sqrt(l * l + r * r) + c * c;\n                list.add(new Node(i, j, s));\n            }\n        }\n        // 核心：按权值排序\n        list.sort(Comparator.comparingDouble(a -> a.w));\n        for (int i = 0; i < n; i++) {\n            q[i] = i;\n        }\n        //记录权重之和，答案\n        double res = 0;\n        for (int i = 0; i < list.size(); i++) {\n            int a = list.get(i).a;\n            int b = list.get(i).b;\n            double w = list.get(i).w;\n            a = find(a);\n            b = find(b);\n            if (a != b) {\n                q[a] = b;\n                res += w;\n            }\n        }\n        System.out.printf(\"%.2f\", res);\n    }\n\n    static int find(int x) {\n        if (q[x] != x) q[x] = find(q[x]);\n        return q[x];\n    }\n\n    static class Node {\n        int a, b;\n        double w;\n\n        public Node(int a, int b, double w) {\n            this.a = a;\n            this.b = b;\n            this.w = w;\n        }\n    }\n}\n```\n\n## 机房 ##\n\n这天, 小明在机房学习。\n\n他发现机房里一共有 �*n* 台电脑, 编号为 1 到 �*n*, 电脑和电脑之间有网线连 接, 一共有 �−1*n*−1 根网线将 �*n* 台电脑连接起来使得任意两台电脑都直接或者间 接地相连。\n\n小明发现每台电脑转发、发送或者接受信息需要的时间取决于这台电脑和 多少台电脑直接相连, 而信息在网线中的传播时间可以忽略。比如如果某台电脑 用网线直接连接了另外 �*d* 台电脑, 那么任何经过这台电脑的信息都会延迟 �*d* 单 位时间 (发送方和接收方也会产生这样的延迟, 当然如果发送方和接收方都是 同一台电脑就只会产生一次延迟)。\n\n小明一共产生了 �*m* 个疑问: 如果电脑 ��*u**i* 向电脑 ��*v**i* 发送信息, 那么信息从 ��*u**i* 传到 ��*v**i* 的最短时间是多少?\n\n**解题思路:**\n\n还是一道比较明显的求`LCA`(最近公共祖先)模型的题目,我们可以使用多种方法来解决该问题，这里我们使用更好写的离线的`tarjan`算法来解决该问题。\n\n除去`tarjan`算法必用的基础数组，我们还有一个数组`d[]`,`d[i]`记录的是每个点的出度，也就是它的延迟时间，以及数组`w[]`,`w[i]`的含义是点`i`到根节点的延迟时间。在通过`dfs`求出每个点`i`的`w[i]`以后，在`tarjan`中我们该如何求出两点的延迟时间呢？\n\n我们设点`i`到`j`的延迟时间为�(�)*f*(*x*),当我们求得`i`与`j`的最近公共祖先为`anc`，我们首先让�(�)=�[�]+�[�]*f*(*x*)=*w*[*i*]+*w*[*j*],但很明显，我们多加了两遍�[���]*w*[*a**n**c*]，所以我们需要减去两倍的�[���]*w*[*a**n**c*]，但延迟时间还包括经过`anc`的时间，所以还得加上一个�[���]*d*[*a**n**c*]。**此处请结合`w[]`和`d[]`的含义理解。** 最后能得出式子:�(�)=�[�]+�[ℎ]−�[���]∗2+�[���]*f*(*x*)=*w*[*i*]+*w*[*h*]−*w*[*a**n**c*]∗2+*d*[*a**n**c*]我们利用这个式子在`tarjan`函数中就能得出每个询问的答案，当然对于起始和结束都在同一个节点的情况下,它的答案就是当前节点的出度，我们可以进行特判一下。输入输出较多，建议使用`scanf`和`printf`进行输入输出。\n\n**时间复杂度**:`dfs`：每个点遍历一次,复杂度级别�(�)*O*(*n*),`tarjan`算法复杂度接近 �(�+�)*O*(*n*+*m*)。\n\nC++ 语言描述:\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\nconst int N=100010;\n\nunordered_map<int,vector<int>> gra;\nint n,m;\n//单个点的出度\nint d[N];\n//记录点i到根节点的延迟\nint w[N];\n//并查集数组\nint q[N];\n//记录答案\nint res[N];\nint st[N];\n//存下查询\nvector<PII>    query[N];\n//并查集查询\nint find(int x){\n    if(x!=q[x]) q[x]=find(q[x]);\n    return q[x];\n}\n\nvoid dfs(int u,int fa)\n{\n    w[u]+=d[u];\n    for(auto g:gra[u]){\n        if(g==fa) continue;\n        w[g]+=w[u];\n        dfs(g,u);\n    }\n}\n\nvoid tarjan(int u)\n{\n    st[u]=1;\n    for(auto j:gra[u]){\n        if(!st[j])\n        {\n            tarjan(j);\n            q[j]=u;\n        }\n    }\n    for(auto item: query[u]){\n        int y=item.first,id=item.second;\n        if(st[y]==2){\n            int anc=find(y);\n            res[id]=w[y]+w[u]-w[anc]*2+d[anc];\n        }\n    }\n    st[u]=2;\n}\nint main()\n{\n    cin>>n>>m;\n    for(int i=0;i<n-1;++i){\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        gra[a].push_back(b);\n        gra[b].push_back(a);\n        d[a]++,d[b]++;\n    }\n    for(int i=0;i<m;++i){\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        if(a!=b){\n            query[a].push_back({b,i});\n            query[b].push_back({a,i});\n        }else{\n            res[i]=d[a];\n        }\n    }\n    dfs(1,-1);\n    for(int i=1;i<=n;++i) q[i]=i;\n    tarjan(1);\n    for(int i=0;i<m;++i) printf(\"%d\\n\",res[i]);\n    return 0;\n}\n```\n\nPython 语言描述:\n\n```python\nfrom collections import defaultdict\n\ngra = defaultdict(list)\nd = [0] * 100010\nw = [0] * 100010\nq = [0] * 100010\nres = [0] * 100010\nst = [0] * 100010\nquery = [[] for _ in range(100010)]\n\ndef find(x):\n    if x != q[x]:\n        q[x] = find(q[x])\n    return q[x]\n\ndef dfs(u, fa):\n    w[u] += d[u]\n    for g in gra[u]:\n        if g == fa:\n            continue\n        w[g] += w[u]\n        dfs(g, u)\n\ndef tarjan(u):\n    st[u] = 1\n    for j in gra[u]:\n        if st[j] == 0:\n            tarjan(j)\n            q[j] = u\n    for item in query[u]:\n        y, id = item\n        if st[y] == 2:\n            anc = find(y)\n            res[id] = w[y] + w[u] - w[anc] * 2 + d[anc]\n    st[u] = 2\n\nn, m = map(int, input().split())\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    gra[a].append(b)\n    gra[b].append(a)\n    d[a] += 1\n    d[b] += 1\n\nfor i in range(m):\n    a, b = map(int, input().split())\n    if a != b:\n        query[a].append((b, i))\n        query[b].append((a, i))\n    else:\n        res[i] = d[a]\n\ndfs(1, -1)\nfor i in range(1, n + 1):\n    q[i] = i\ntarjan(1)\nfor i in range(m):\n    print(res[i])\n```\n\nJava 语言描述:\n\n```java\nimport java.util.*;\n\npublic class Main {\n    static class Pair {\n        int first, second;\n        public Pair(int first, int second) {\n            this.first = first;\n            this.second = second;\n        }\n    }\n\n    static Map<Integer, List<Integer>> gra = new HashMap<>();\n    static int[] d = new int[100010];\n    static int[] w = new int[100010];\n    static int[] q = new int[100010];\n    static int[] res = new int[100010];\n    static int[] st = new int[100010];\n    static List<Pair>[] query = new List[100010];\n\n    static int find(int x) {\n        if (x != q[x]) q[x] = find(q[x]);\n        return q[x];\n    }\n\n    static void dfs(int u, int fa) {\n        w[u] += d[u];\n        for (int g : gra.get(u)) {\n            if (g == fa) continue;\n            w[g] += w[u];\n            dfs(g, u);\n        }\n    }\n\n    static void tarjan(int u) {\n        st[u] = 1;\n        for (int j : gra.get(u)) {\n            if (st[j] == 0) {\n                tarjan(j);\n                q[j] = u;\n            }\n        }\n        for (Pair item : query[u]) {\n            int y = item.first, id = item.second;\n            if (st[y] == 2) {\n                int anc = find(y);\n                res[id] = w[y] + w[u] - w[anc] * 2 + d[anc];\n            }\n        }\n        st[u] = 2;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        for (int i = 1; i <= n; i++) {\n            gra.put(i, new ArrayList<>());\n            query[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < n - 1; i++) {\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            gra.get(a).add(b);\n            gra.get(b).add(a);\n            d[a]++;\n            d[b]++;\n        }\n        for (int i = 0; i < m; i++) {\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            if (a != b) {\n                query[a].add(new Pair(b, i));\n                query[b].add(new Pair(a, i));\n            } else {\n                res[i] = d[a];\n            }\n        }\n        dfs(1, -1);\n        for (int i = 1; i <= n; i++) {\n           q[i] = i;\n        }\n        tarjan(1);\n        for (int i = 0; i < m; i++) {\n            System.out.println(res[i]);\n        }\n    }\n}\n```\n\n## 环境治理 ##\n\nLQ 国拥有 �*n* 个城市, 从 0 到 �−1*n*−1 编号, 这 �*n* 个城市两两之间都有且仅有 一条双向道路连接, 这意味着任意两个城市之间都是可达的。每条道路都有一 个属性 �*D*, 表示这条道路的灰尘度。当从一个城市 �*A* 前往另一个城市 �*B* 时, 可 能存在多条路线, 每条路线的灰尘度定义为这条路线所经过的所有道路的灰尘 度之和, LQ 国的人都很讨厌灰尘, 所以他们总会优先选择灰尘度最小的路线。\n\nLQ 国很看重居民的出行环境, 他们用一个指标 �*P* 来衡量 LQ 国的出行环 境, �*P* 定义为:\n\n�=∑∗�=0�−1∑∗�=0�−1�(�,�)*P*=∑∗*i*=0*n*−1∑∗*j*=0*n*−1*d*(*i*,*j*)\n\n其中 �(�,�)*d*(*i*,*j*) 表示城市 �*i* 到城市 �*j* 之间灰尘度最小的路线对应的灰尘度的值。 为了改善出行环境, 每个城市都要有所作为, 当某个城市进行道路改善时, 会将与这个城市直接相连的所有道路的灰尘度都减少 1 , 但每条道路都有一个 灰尘度的下限值 �*L*, 当灰尘度达到道路的下限值时, 无论再怎么改善, 道路的 灰尘度也不会再减小了。\n\n具体的计划是这样的:\n\n第 1 天, 0 号城市对与其直接相连的道路环境进行改善;\n\n第 2 天, 1 号城市对与其直接相连的道路环境进行改善;\n\n⋯⋯\n\n第 �*n* 天, �−1*n*−1 号城市对与其直接相连的道路环境进行改善;\n\n第 �+1*n*+1 天, 0 号城市对与其直接相连的道路环境进行改善;\n\n第 �+2*n*+2 天, 1 号城市对与其直接相连的道路环境进行改善;\n\nLQ 国想要使得 �*P* 指标满足 �≤�*P*≤*Q* 。请问最少要经过多少天之后, �*P* 指标 可以满足 �≤�*P*≤*Q* 。如果在初始时就已经满足条件, 则输出 0 ; 如果永远不可能 满足, 则输出 −1−1 。\n\n**解题思路:**\n\n首先，对于求解`P`指的公式，我们要清楚，是每个点到其他所有点的最短路径之和相加，这种涉及到任意两点的最短路，加上 �*n* 的最大范围只有`100`，很明显我们需要想到`Floyd`算法求任意两点的最短路。\n\n我们并没有一个直观的算法直接求得答案，所以，我们考虑**二分答案。** 如果改善`x`天是符合要求的，那么大于`x`的天数也一定符合，但小于`x`的天数不一定，所以满足二段性，我们可以二分。\n\n我们用`g[][]`记录初始道路的灰尘度,`m[][]`记录每条道路的最低灰尘度,`f[][]`记录的是在改善`x`天后的每条道路的环境。这样我们就可以使用二分+`Floyd`的做法得到答案。\n\n当然这里有一些需要注意的细节问题，当我们改变`f[i][j]`的值时，相应的也要改变`f[j][i]`的值，因为任意两点只存在一条双向道路，所以这两个状态应该表示的是同一条道路。每次`check`时，别忘记将`f[][]`重置回`g[][]`，再去减去对于的天数。`floyd`函数每次跑完后，计算并返回此时的`P`值。\n\n最开始时我们可以判断每条道路都是最低复杂度的情况下，计算出来的`P`是否大于`Q`，如果大于说明肯定无解，直接返回`-1`即可。二分对于`r`的上限也需要注意，最多`100`个点，每个点最大`1e5`，所以理论上我们只要开到大于`1e7`以上就不会有问题，否则样例过大时可能会出错。\n\n时间复杂度：�(�3���(�∗�))*O*(*n*3*l**o**g*(*n*∗*m*))。\n\nC++ 语言描述:\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N=110;\n\nLL g[N][N];\nLL m[N][N];\nLL f[N][N];\nLL n,q;\nLL floyd()\n{\n    LL a=0;\n    for (int k = 1; k <= n; k ++ )\n        for (int i = 1; i <= n; i ++ )\n            for (int j = 1; j <= n; j ++ )\n                f[i][j] = min(f[i][j], f[i][k] + f[k][j]);\n\n    for(int i=1;i<=n;++i)\n        for(int j=1;j<=n;++j)\n            a+=f[i][j];\n    return a;\n}\n//改善X天\nbool check(LL x){\n    memcpy(f,g,sizeof(g));\n    LL h=x/n;\n    LL s=x%n;\n    for(int i=1;i<=n;++i){\n        for(int j=1;j<=n;++j){\n            if(i==j) continue;\n            if(i<=s) f[i][j]=max(m[i][j],f[i][j]-h-1);\n            else f[i][j]=max(m[i][j],f[i][j]-h);\n            f[j][i]=f[i][j];\n        }\n    }\n    return floyd()<=q;\n}\nvoid solve()\n{\n    cin>>n>>q;\n    for(int i=1;i<=n;++i){\n        for(int j=1;j<=n;++j){\n            cin>>g[i][j];\n        }\n    }\n    for(int i=1;i<=n;++i){\n        for(int j=1;j<=n;++j){\n            cin>>m[i][j];\n            f[i][j]=m[i][j];\n        }\n    }\n    if(floyd()>q){\n        cout<<-1<<endl;\n        return;\n    }\n    LL l=0,r=1000000000;\n    while(l<r){\n        int mid=l+r>>1;\n        if(check(mid)) r=mid;\n        else l=mid+1;\n    }\n    cout<<r<<endl;\n}\nint main()\n{\n    solve();\n    return 0;\n}\n```\n\nPython 语言描述:\n\n```python\nimport copy\nN=110\ng=[[0]*N for i in range(N)]\nm=[[0]*N for i in range(N)]\nf=[[0]*N for i in range(N)]\nn,q=map(int,input().split())\ndef floyd(f):\n    a=0\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                f[i][j]=min(f[i][j],f[i][k]+f[k][j])\n    for i in range(1,n+1):\n        for j in range(1,n+1):\n            a=a+f[i][j]\n    return a\ndef check(x,g):\n    f=copy.deepcopy(g)\n    h=x//n\n    s=x%n\n    for i in range(1,n+1):\n        for j in range(1,n+1):\n            if i==j:\n                continue\n            if i<=s:\n                f[i][j]=max(m[i][j],f[i][j]-h-1)\n            else:\n                f[i][j]=max(m[i][j],f[i][j]-h)\n            f[j][i]=f[i][j]\n    return  floyd(f)<=q\n\ndef solve():\n    for i in range(1,n+1):\n        l=list(map(int,input().split()))\n        for j in range(1,n+1):\n            g[i][j]=l[j-1]#灰尘度\n    for i in range(1,n+1):\n        l = list(map(int, input().split()))\n        for j in range(1,n+1):\n            m[i][j]=l[j-1]#灰尘度的下限值\n            f[i][j]=m[i][j]\n    if floyd(f)>q:\n        print(-1)\n        return\n    l,r=0,10000000\n    while (l < r):\n        mid=(l+r)>>1\n        if (check(mid,g)):\n            r=mid\n        else:\n            l=mid+1\n    print(r)\nsolve()\n```\n\nJava 语言描述:\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static int N=110;\n    static long[][] g=new long[N][N],m=new long[N][N],f=new long[N][N];\n    static long n,q;\n    static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter  out=new PrintWriter(new OutputStreamWriter(System.out));\n    public static void main(String[] args) throws IOException {\n        String[] s=br.readLine().split(\" \");\n        n=Long.parseLong(s[0]);\n        q=Long.parseLong(s[1]);\n        for(int i=1;i<=n;++i){\n            s=br.readLine().split(\" \");\n            for(int j=1;j<=n;++j){\n                g[i][j]=Long.parseLong(s[j-1]);\n            }\n        }\n        for(int i=1;i<=n;++i){\n            s=br.readLine().split(\" \");\n            for(int j=1;j<=n;++j){\n                m[i][j]=Long.parseLong(s[j-1]);\n                f[i][j]=m[i][j];\n            }\n        }\n        if(floyd()>q){\n            out.println(-1);\n            out.flush();\n            return;\n        }\n        long l=0,r=1000000000;\n        while(l<r){\n            long mid=l+r>>1;\n            if(check(mid)) r=mid;\n            else l=mid+1;\n        }\n        out.println(r);\n        out.flush();\n    }\n    static long floyd(){\n        long a=0;\n        for (int k = 1; k <= n; k ++ )\n            for (int i = 1; i <= n; i ++ )\n                for (int j = 1; j <= n; j ++ )\n                    f[i][j] =Math.min(f[i][j], f[i][k] + f[k][j]);\n\n        for(int i=1;i<=n;++i)\n            for(int j=1;j<=n;++j)\n                a+=f[i][j];\n        return a;\n    }\n    static boolean check(long x){\n        for(int i=1;i<=n;++i){\n            for(int j=1;j<=n;++j) f[i][j]=g[i][j];\n        }\n        long h=x/n;\n        long s=x%n;\n        for(int i=1;i<=n;++i){\n            for(int j=1;j<=n;++j){\n                if(i==j) continue;\n                if(i<=s) f[i][j]=Math.max(m[i][j],f[i][j]-h-1);\n                else f[i][j]=Math.max(m[i][j],f[i][j]-h);\n                f[j][i]=f[i][j];\n            }\n        }\n        return floyd()<=q;\n    }\n}\n```\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯冲刺营","11.图论入门"]},{"title":"动态规划","url":"/2024/02/22/动态规划/","content":"\n# 动态规划（Dynamic Programming） #\n\n## 实验介绍 ##\n\n本节课我们进入动态规划课程的学习，动态规划是一种多阶段的决策过程最优化的问题。\n\n本课程对于算法学习非常重要，但是又比较难，我们讲解分 33 个章节进行动态规划问题的讲解。\n\n今天的课程是动态规划系列的第一个章节。\n\n### 知识点 ###\n\n- 动态规划的基本思想\n- 动态规划问题的基本套路与步骤\n\n## 为什么使用动态规划算法 ##\n\n我们先回忆一下贪心问题。\n\n贪心又称贪婪算法。是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而使得问题得到全局最优解。\n\n**它的特点：**\n\n贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。\n\n这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。\n\n贪心选择性质就是，该问题的每一步选择都在选择最优的情况下能够导致最终问题的答案也是最优。\n\n其实贪心和动态规划的区别，你可以理解为一个是正推，一眼就能看出来最优子结构，依次按照最优子结构选择每个过程最优选择即可。\n\n而动态规划是没办法按照题目的意思直接得到最有优子结构，如下文所述:\n\n#### 多阶段决策过程最优化问题 ####\n\n动态规划问题，是运筹学的一个分支，动态规划主要用于求解以时间划分阶段的动态过程的优化问题。\n\n在实际生活中，动态规划问题与贪心问题相似，都是完成某一事件的过程可以划分成多个阶段。\n\n但是与贪心不同的是动态规划的每个状态之间都会相互影响和相互干涉，也就是说在某一阶段做出的决策会影响整个事件的最终结果。\n\n因为阶段是有先后的，所以某一阶段的选取受之前阶段的影响，他也会影响后面的阶段。\n\n**多阶段决策问题：**\n\n多阶段决策过程问题，就是一类在每一阶段都需要做出选择，且某一阶段的决策受前面所有阶段决策后的状态影响，他的决策又会影响后续的决策。\n\n这样一类问题就是多阶段决策问题。\n\n**多阶段决策过程最优化问题：**\n\n在多阶段决策问题中，各个阶段采取的决策，通常与时间相关，但有时又与其他的线性的变量相关。\n\n我们前面说到，某个阶段的决策是在前面做完了的决策引发的某一个状态开始进行决策的。\n\n而现在做的决策又会使得状态进行转移，那么又影响了下次进行决策的状态。\n\n所以说作决策时的状态是动态的，规划是解决最优化问题的方式，所以解决这种多阶段决策过程最优化的方法叫做动态规划。\n\n#### 动态规划中的术语解释 ####\n\n- 阶段： 把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不同\n- 状态： 述事物的性质，不同事物有不同的性质，因而用不同的状态来刻画。对问题的求解状态的描述是分阶段的\n- 决策： 根据题意要求，对每个阶段所做出的某种选择性操作\n- 策略： 由每个阶段的决策组成的序列称为策略\n- 状态转移方程： 用数学公式描述与阶段相关的状态间的演变规律\n\n#### 能采用动态规划求解的问题的性质 ####\n\n- 最优化原理：\n\n  如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。\n\n- 无后效性：\n\n  即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。\n\n- 有重叠子问题：\n\n  即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）\n\n#### 解题步骤 ####\n\n- 拆分问题\n- 定义状态(并找出初状态)\n- 找到状态转移\n- 逆推找最优子结构\n- 写出 DP 状态转移方程。\n\n#### 一般的模型方法 ####\n\n- 递归搜索法\n- 记忆化搜索(记忆化暴力)\n- 递推式法\n\n#### 经典例题数塔问题 ####\n\n我们先来回顾一下我们之前讲过的数塔问题：\n\n**题目描述:**\n\n![图片描述](./../imgs/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/06b8663e2aceb6c87e0913d2fe0710f2-0.png)\n\n如图数字三角形。如下所示为一个数字三角形。请编一个程序计算从顶到底的某处的一条路径，使该路径所经过的数字总和最大。只要求输出总和。\n\n1. 一步可沿左斜线向下或右斜线向下走；\n2. 三角形行数小于等于 100100；\n3. 三角形中的数字为 0，1，…，990，1，…，99；\n\n测试数据通过键盘逐行输入。\n\n如上例数据应以样例所示格式输入：\n\n**样例:**\n\n```txt\n输入：\n\n5\n7\n3 8\n8 1 0\n2 7 4 4\n4 5 2 6 5\n输出：\n\n30\n```\n\n**运行限制:**\n\n```txt\n1. 最大运行时间：1s\n2. 最大运行内存：128M\n```\n\n**题目分析:**\n\n1. 定义状态 假设 `dp[i][j]` 为处理 `a[i][j]` 后能达到的最大值。\n\n2. 找出状态转移\n\n   `dp[i][j]`怎么转移呢？按照题意他有两条路径可以转移\n\n   `dp[i+1][j]=dp[i][j]+a[i+1][j]` 向下走\n\n   `dp[i+1][j+1]=dp[i][j]+a[i+1][j+1]` 向右下走\n\n   我们有办法知道这两条路径哪条更优吗？\n\n   不能！因为通向了两个不同的决策过程。为什么贪心可以知道，因为贪心处理完之后通向的是同一个决策过程，这里`dp[i+1][j]和dp[i+1][j+1]`明显他们两个所能达到的状态是完全不同的，这就是动态规划和贪心的不同之处。\n\n   那我们怎样处理呢，我们要做的就是达到同一个状态我们才能够判断那个是最优的，这就是最优子结构。\n\n3. 逆推找最优子结构\n\n   虽然我们进行了逆推，但是实际上不是因为我们逆推做了什么，只是因为我们找最优子结构的过程中恰好做了逆推的过程。\n\n   我们要找最优子结构，我们刚才说了，要找到达同一状态的转移才能比较。那我们就考虑什么状态能够转移得到`dp[i][j]`，这时候我们直接看也能看出来是这两条路径`dp[i+1][j]+a[i][j],dp[i+1][j+1]+a[i][j]`。\n\n4. 写出状态转移方程\n\n��[�][�]=�����[�+1][�]+�[�][�],��[�+1][�+1]+�[�][�]*d**p*[*i*][*j*]=*m**a**x**d**p*[*i*+1][*j*]+*a*[*i*][*j*],*d**p*[*i*+1][*j*+1]+*a*[*i*][*j*]\n\n空间优化，已知 `dp[i][j]` 的值只会被覆盖前使用一次，所以可以合并 `dp[i][j]` 和 `a[i][j]` 那么就变成了。\n\n�[�][�]=����[�][�]+�[�+1][�],�[�][�]+�[�+1][�+1]*a*[*i*][*j*]=*m**a**x**a*[*i*][*j*]+*a*[*i*+1][*j*],*a*[*i*][*j*]+*a*[*i*+1][*j*+1]\n\n则 逆推到出发点 `a[1][1]` 为题目所求答案，即第一层到第 `N` 层的最大值。\n\n**答案解析：**\n\n**C++ 解题代码:**\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nint main()\n{\n    int n; //n层\n    int a[101][101]; //路径矩阵\n    cin>>n;\n\n    //输入数字三角形的值\n    for (int i=1; i<=n; i++)\n    {\n        for (int j=1; j<=i; j++)\n        {\n\n        cin>>a[i][j]; //输入原始数据\n\n        }\n    }\n\n    //递推开始\n\n    for (int i=n-1; i>=1; i--)//从最后一层逆推\n    {\n        for (int j=1; j<=i; j++)\n        {\n\n            if (a[i+1][j]>=a[i+1][j+1])\n                a[i][j]+=a[i+1][j];     //路径选择\n\n            else\n                a[i][j]+=a[i+1][j+1];\n        }\n    }\n\n    cout<<a[1][1]<<endl;\n}\n```\n\n**Python 解题代码:**\n\n```python\na = [[0] * 101] * 101\n\nif __name__ == '__main__':\n\n  n = int(input())\n\n  # 输入数字三角形的值\n  for i in range(1, n+1):\n      a[i] = input().split()\n      a[i] = list(map(int, a[i]))  # split 分割后都是 字符 这里是转化成数字\n  #\n  # for i in range(1, n + 1):\n  #     print(a[i])\n\n # a = list(map(int, a)) # split 分割后都是 字符 这里是转化成数字\n\n  # 递推开始\n\n  for i in range(n - 1, 0, -1):\n      # 最后一层逆推\n      for j in range(0, i):\n\n          # 路径选择\n          if a[i + 1][j] >= a[i + 1][j + 1]:\n              a[i][j] += a[i + 1][j]\n\n          else:\n              a[i][j] += a[i + 1][j + 1]\n\n  # for i in range(1, n + 1):\n  #     print(a[i])\n\n  print(a[1][0])\n```\n\n**Java 解题代码**\n\n```java\npackage com.company;\nimport java.util.Scanner;\n\npublic class Main {\n\n  static int [][]a=new int [101][101];\n\n  public static void main(String[] args) {\n\n      int n;\n      Scanner in = new Scanner(System.in);\n      n = in.nextInt();\n\n      //输入数字三角形的值\n      for (int i=1; i<=n; i++)\n      {\n          for (int j=1; j<=i; j++)\n          {\n              a[i][j]=in.nextInt(); //输入原始数据\n          }\n      }\n\n      //递推开始\n\n      for (int i=n-1; i>=1; i--)//从最后一层逆推\n      {\n\n          for (int j=1; j<=i; j++)\n          {\n              if (a[i+1][j]>=a[i+1][j+1])\n                  a[i][j]+=a[i+1][j];     //路径选择\n\n              else  a[i][j]+=a[i+1][j+1];\n          }\n      }\n      System.out.println(a[1][1]);\n  }\n}\n```\n\n其实我们在讲这道题目中所用到的思想就是动态规划。\n\n我们换种方式在理解一遍。\n\n在用动态规划考虑数塔问题时可以自顶向下的分析，自底向上的计算。\n\n从顶点出发时到底向左走还是向右走应取决于是从左走能取到最大值还是从右走能取到最大值，只要左右两道路径上的最大值求出来了才能作出决策。\n\n同样的道理下一层的走向又要取决于再下一层上的最大值是否已经求出才能决策。\n\n这样一层一层推下去，直到倒数第二层时就非常明了。\n\n所以第一步对第五层的 88 个数据，做如下四次决策：\n\n- 如果经过第四层 22，则在第五层的 44 和 55 中，决策选择的肯定是 1919\n- 如果经过第四层 77，则在第五层的 55 和 22 中，决策选择的肯定是 1010\n- 如果经过第四层第一个 44，则在第五层的 22 和 66 中，决策选择的肯定是 66\n- 如果经过第四层第二个 44，则在第五层的 66 和 55 中肯定是 66\n\n经过一次决策，问题降了一阶。55 层数塔问题转换成 44 层数塔问题，经过如此的决策，就将原来问题转换为一阶数塔问题。\n\n于是我们可以用我们上面的递推求解。\n\n这就是递推式法模型。\n\n我们通过这道简单的例题，大家首先要去找感觉，去分解问题的状态，去找决策，去找状态转移，而笔者认为动态规划问题，感觉是最重要的。\n\n有的人 1010 道题就能找到感觉，有的人 100100 道题也找不到感觉。\n\n#### 游戏中的学问 ####\n\n难度: 简单 标签: DP, JSOI, 2013\n\n题目链接：https://www.lanqiao.cn/problems/1436/learning/\n\n**题目描述：**\n\n大家应该都见过很多人手拉手围着篝火跳舞的场景吧？\n\n一般情况下，大家手拉手跳舞总是会围成一个大圈，每个人的左手拉着旁边朋友的右手，右手拉着另一侧朋友的左手。\n\n不过，如果每一个人都随机的拉住两个不同人的手，然后再慢慢散开，事情就变得有趣多了——此时大家依旧会形成圈，不过却可能会形成多个独立的圈。\n\n当然这里我们依然要求一个人的右手只能拉另一个人的左手，反之亦然。\n\n班里一共有 �*N* 个同学，由 11 到 �*N* 编号。Will 想知道，究竟有多少种本质不同的拉手方案，使得最终大家散开后恰好形成 �*k* 个圈呢？\n\n给定两种方案，若存在一个人和他的一只手，满足在这两种方案中，拉着这只手的人的编号不同，则这两种方案本质不同。\n\n**输入描述：**\n\n```c\n输入一行包含三个正整数 N k P\n\n3<=3k<=N<=3000，10^4<=p<=2×10^9\n```\n\n**输出描述：**\n\n输出一行一个整数，表示本质不同的方案数对 p 的余数。保证 p 一定是一个质数。\n\n**输入输出样例：**\n\n- 样例 1： Input：\n\n  ```txt\n  3 1 1000000009\n  ```\n\n  output：\n\n  ```txt\n  2\n  ```\n\n**答案解析：**\n\n题目是说随即的拉住右手，共计 N 个人形成 k 个独立环的可能的情况有多少种。\n\n我们举个例子，A B C 三个人：\n\n![图片描述](./../imgs/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/4e9534885e67b5c512405e7d1d5c182b-0.png)\n\nA 的左手是 C A 的右手是 B B 的左手是 A B 的右手是 C C 的左手是 B C 的右手是 A\n\n![图片描述](./../imgs/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/a0502745d207f9d9d3dfdb4bc2ad841d-0.png)\n\nA 的左手是 B A 的右手是 C B 的左手是 C B 的右手是 A C 的左手是 A C 的右手是 B\n\n这两种是不同的。\n\n最后对 P 取模。\n\n这道题目可以说是记忆化搜索，也可以说是递推法模型。\n\n**定义状态：**\n\n我们设 dp{i,j} 是 i 个人组成 j 个圈有多少种情况的状态\n\n**找初始状态：**\n\n由于最少是三个人围成 1 个圈\n\n所以 dp{3,1}=2\n\n**找状态转移：**\n\n我们考虑 `dp{4,1}` 的时候： 由于一开始三个人之间共计 3 个空位置，它可以见缝插针，所以就有 3×3×dp {3,13,1}，dp{4,14,1} = 3×3×dp{3,13,1}\n\n接着考虑 `dp{x+1,y}` 和 `dp{x,y}` 的关系：\n\n假设 `X` 个人分成了 `y` 个环后每个环得人数是 `X1 X2 ... Xy`\n\n对于第一个环 `X1` 来说共有 `X1` 个空\n\n对于第二个环 `X2` 来说共有 `X2` 个空\n\n共计 `X1+X2+...+Xy=X`\n\n所以共有 `X` 个空，那么第 `X+1` 个人就用 `X` 种选择可以做。\n\n所以 dp{�+1,�*x*+1,*y*} = �×*x*× dp{�,�*x*,*y*}，即 dp{�,�*i*,*j*}=(�−1)×(*i*−1)×dp{�−1,�*i*−1,*j*}\n\n考虑 dp{6,16,1} 和 dp{6,26,2} ：\n\n大家考虑以下我们划分阶段得方式是什么，是圈数吗？\n\n如果是圈数，我们发现好像{6,16,1} 和 {6,26,2} 两个状态之间没有什么关系？\n\n单纯的圈数不存在关系。\n\n我们思考一下，至少需要 `3` 个人才能组成一个圈。\n\n所以第 `i` 个人加入时，要在前 `i-1` 个人中抽出两个人才能组成一个新圈。\n\n所以原本的 dp{�−1,�*i*−1,*j*} 的状态就变成了，dp{�−3,�*i*−3,*j*}了。\n\n由于是从 `i-1` 个人中抽出 `2` 个人所以，共计��−12*C**i*−12的抽取方式，`3` 个人我们已知能组成两种方案。\n\n根据组合数求方案数的方式\n\n2×��−12=2×(�−1)!(�−3)!×22×*C**i*−12=2×(*i*−3)!×2(*i*−1)!\n\n2×��−12=(�−1)!/(�−3)!=(�−1)∗(�−2)2×*C**i*−12=(*i*−1)!/(*i*−3)!=(*i*−1)∗(*i*−2)\n\n所以 `dp{i,j+1}=dp{i-3,j}×(i-1)×(i-2)`\n\n即 `dp{i,j}=dp{i-3,j-1}×(i-1)×(i-2)`\n\n就此我们得到状态转移方程\n\n- `dp{i,j}=dp{i-1,j}×(i-1)`\n- `dp{i,j}=dp{i-3,j-1}×(i-1)×(i-2)`\n\n除此之外，我们还有要考虑的情况，即建不建立新圈都是 `dp{i,j}`的情况，所以这里不是等于，而是求和:\n\n```\ndp{i,j}=dp{i-1,j}×(i-1)\ndp{i,j}=dp{i,j}+dp{i-3,j-1}×(i-1)×(i-2)\n```\n\n比如：\n\n`dp{7,2}`可以由 `dp{6,2}`转移而来\n\n`dp{7,2}`也可以由 `dp{4,1}`转移而来\n\n为什么这两种情况没有重叠，而是绝对异构的：\n\n`dp{6,2}`由 `dp{3,1}`转移而来\n\n`dp{4,1}`由 `dp{3,1}`转移而来\n\n`dp{4,1}`中 `1-4` 号是在同一个圈内的。\n\n`dp{6,2}`中 两个圈中的任意 `3` 个在一个圈内\n\n不可能出现 `1-4` 在一个圈里的这种情况。\n\n所以推导 `dp{i,j}`\n\n`dp{i,j}`由 `dp{i-i,j}`转移而来 `dp{i,j}`也可以由 `dp{i-3,j-1}` 转移而来\n\n```\ndp{i-i,j}`可以由 `dp{i-2,j}`或者 `dp{i-4,j-1}` `dp{i-3,j-1}`可以由 `dp{i-4,j-1}`或者 `dp{i-6,j-2}\n```\n\n最终还是会到 `3,1`。\n\n所以通过 `3`，通过两种方式走向了完全不同的方向。\n\n至此我们轻松写出代码。\n\nC++ 描述：\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\ntypedef long long LL;\nLL DP[3100][3100],mod;\nint n,k;\nint main()\n{\n    cin>>n>>k>>mod;\n    DP[3][1]=2;\n    for(int i=4;i<=n;i++)\n    {\n\n        for(int j=1;3*j<=i&&j<=k;j++)\n        {\n            DP[i][j]=DP[i-1][j]*(i-1)%mod;\n\n            DP[i][j]=(DP[i][j]+DP[i-3][j-1]*(i-1)*(i-2))%mod;\n        }\n    }\n    cout<<DP[n][k];\n    return 0;\n}\n```\n\nPython 语言描述：\n\n```python\nn, k, mod = map(int, input().split())\n\nDP=[[0 for i in range (3100)] for j in range (3100) ]\n\nDP[3][1]=2\n\nfor i in range(4,n+1):\n\n    for j in range(1,k+1):\n\n        if 3*j>i:\n            break\n\n        DP[i][j]=DP[i-1][j]*(i-1)%mod\n\n        DP[i][j]=(DP[i][j]+DP[i-3][j-1]*(i-1)*(i-2))%mod\n\n\nprint(DP[n][k])\n```\n\njava 语言描述：\n\n```java\nimport java.util.Scanner;\n// 1:无需package\n// 2: 类名必须Main, 不可修改\n\npublic class Main {\n    public static long DP[][]=new long [3100][3100];\n\n    public static int n,k;\n\n public static void main (String[] args) throws java.lang.Exception\n {\n     Scanner in = new Scanner(System.in);\n\n     n=in.nextInt();\n\n     k=in.nextInt();\n\n    long mod=in.nextLong();\n\n     DP[3][1]=2;\n        for(int i=4;i<=n;i++)\n        {\n\n            for(int j=1;3*j<=i&&j<=k;j++)\n            {\n                DP[i][j]=DP[i-1][j]*(i-1)%mod;\n\n                DP[i][j]=(DP[i][j]+DP[i-3][j-1]*(i-1)*(i-2))%mod;\n            }\n        }\n  System.out.println(DP[n][k]);\n }\n}\n```\n\n#### 跳跃 ####\n\n难度: 简单 标签: 动态规划, 搜索, 2021, 模拟赛\n\n题目链接：https://www.lanqiao.cn/problems/553/learning/\n\n**题目描述：** 开始时，小蓝站在方格图的左上角，即第 11 行第 11 列。\n\n小蓝可以在方格图上走动，走动时，如果当前在第 �*r* 行第 �*c* 列，他不能走到行号比 �*r* 小的行，也不能走到列号比 �*c* 小的列。\n\n同时，他一步走的直线距离不超过 33。\n\n例如，如果当前小蓝在第 33 行第 55 列，他下一步可以走到\n\n第 33 行第 66 列 第 33 行第 77 列 第 33 行第 88 列 第 44 行第 55 列 第 44 行第 66 列 第 44 行第 77 列 第 55 行第 55 列 第 55 行第 66 列 第 66 行第 55 列 小蓝最终要走到第 �*n* 行第 �*m* 列。\n\n在图中，有的位置有奖励，走上去即可获得，有的位置有惩罚，走上去就要接受惩罚。奖励和惩罚最终抽象成一个权值，奖励为正，惩罚为负。\n\n小蓝希望，从第 11 行第 11 列走到第 �*n* 行第 �*m* 列后，总的权值和最大。请问最大是多少？\n\n**输入描述：**\n\n输入的第一行包含两个整数 �,�*n*,*m*，表示图的大小。\n\n接下来 �*n* 行，每行 �*m* 个整数，表示方格图中每个点的权值。\n\n其中，1≤�≤1001≤*n*≤100，−104≤−104≤权值≤104≤104。\n\n**输出描述：**\n\n输出一个整数，表示最大权值和。\n\n**输入输出样例：**\n\n- 样例 1： Input：\n\n  ```txt\n  3 5\n  -4 -5 -10 -3 1\n  7 5 -9 3 -10\n  10 -2 6 -10 -4\n  ```\n\n  output：\n\n  ```txt\n  15\n  ```\n\n**运行限制:**\n\n- 最大运行时间：1s\n- 最大运行内存: 128M\n\n**答案解析：**\n\n由于这道题目数据较弱，大家可以使用搜索把所有情况都搜索到，每次到终点就保存最大值，知道遍历完所有的情况，然后输出最大值。\n\n大家一定要写一遍 `DFS` 然后在看后边的 `DP` ,有时动态规划要从状态出发，有时动态规划又可以看成暴力搜索的剪枝。\n\n我们先看一下搜索的解法：\n\n因为只能向右下方移动，不存再走回头路的情况，所以不需要设置 `Vis` 数组。\n\nC++ 描述：\n\n```cpp\n#include<iostream>\n#define MAX 105\nusing namespace std;\nint n, m, sum = -0x3f3f3f3f;\nint map[MAX][MAX];\nint nextt[9][2] = { {0,1},{1,0},{0,2},{2,0},{0,3},{3,0},{1,1},{1,2},{2,1} };\nvoid dfs(int x, int y,int value)\n{\n    value += map[x][y];\n    if (x == n && y == m)\n    {\n        sum=max(sum,value);\n        return;\n    }\n\n    for (int i = 0; i < 9; i++)\n    {\n        int tx = x + nextt[i][0];\n        int ty = y + nextt[i][1];\n        if (tx <= n && ty <= m)\n            dfs(tx, ty, value);\n    }\n}\nint main()\n{\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++)\n            cin >> map[i][j];\n    dfs(1, 1, 0);\n    cout << sum;\n    return 0;\n}\n```\n\nPython 语言描述：\n\n```python\nimport os\nimport sys\n\n# 请在此输入您的代码\nn,m = map(int,input().strip().split())\n\nmapTable = [list(map(int,input().strip().split())) for i in range(n)]\n\nnextt = [[0,1],[0,2],[0,3],[1,0],[2,0],[3,0],[1,1],[1,2],[2,1]] #9种走的方式\n\nSum=float('-inf')\n\ndef dfs(x,y,value):\n\n    global Sum\n\n    value+=mapTable[x][y]\n    if x==n-1 and y==m-1 :\n        Sum=max(Sum,value)\n        return\n\n    for i in range(9):\n        tx = x+nextt[i][0]\n        ty = y+nextt[i][1]\n        if  tx<n and  ty<m :\n\n            dfs(tx,ty,value)\ndfs(0,0,0)\nprint(Sum)\n```\n\njava 语言描述：\n\n```java\nimport java.io.*;\nimport java.util.Scanner;\npublic class Main\n{\n\n    public static int n, m, Sum = -0x3f3f3f3f;\n\n    public static int [][] mapTable=new int [105][105];\n\n    public static int nextt[][] ={ {0,1},{1,0},{0,2},{2,0},{0,3},{3,0},{1,1},{1,2},{2,1} };\n\n    public static void dfs(int x, int y,int value)\n    {\n        value += mapTable[x][y];\n        if (x == n && y == m)\n        {\n             // System.out.println(Sum);\n            Sum=Math.max(Sum,value);\n            return;\n        }\n\n        for (int i = 0; i < 9; i++)\n        {\n            int tx = x + nextt[i][0];\n            int ty = y + nextt[i][1];\n            if (tx <= n && ty <= m)\n                dfs(tx, ty, value);\n        }\n    }\n\n public static void main (String[] args) throws java.lang.Exception\n {\n\n    Scanner in =new Scanner(System.in);\n    n=in.nextInt();\n    m=in.nextInt();\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++)\n                mapTable[i][j]=in.nextInt();\n\n       dfs(1, 1, 0);\n\n    System.out.println(Sum);\n }\n}\n```\n\n我们再来看一下 DP 怎么解这个问题。\n\n**定义状态：**\n\n我们设 dp{�,�*i*,*j*} 当走到第 �*i* 行第 �*j* 列的值。\n\n**找初始状态：**\n\ndp{1,11,1}\n\n**找状态转移：**\n\n对于dp{�,�*i*,*j*} 会有 99 种不同的状态转移，我们很难知道当前的选择去怎样影响后续的值，这就是上边的搜索问题，我们难以找到一种 DP 思路去求解这个问题，但是我们反向考虑，既然dp{�,�*i*,*j*} 会有 99 种转移方式，那么当这 99 种状态的值为从这九种状态到达终点的最优解（最大值）时，那么我们就能轻易得到dp{�,�*i*,*j*} 的最大值为这九种最优解的最大值。\n\n继续消解子问题，那么我们得到这 99 种最优子状态，继续根据同样的原理得到这 99 种最优的子状态的最优子状态。\n\n持续消解，发现只有到了 dp{�,�*n*,*m*} 采用终止，这就是一个递归的过程。\n\n```c\nvalue[n+5][m+5]\n\ndp(x,y)\n{\n    if(x==n&&y==m)\n        return value[n][m]\n\n    if(越界)\n        return 负无穷\n\n    value[x][y]=value[x][y]+max(dp(x+1,y)......,dp(2,1))\n    return dp(x,y)\n\n}\n```\n\n这个过程是正推，根据递归写出递推来就变成了逆推，其实并不是根据动态规划写出来的逆推式，而是用正推递归变递推变来的，当然有的同学一眼看出来，那是非常优秀的。\n\n这个题目数据量较小，用递归写不会爆，大家可以根据我的伪代码写写试试。\n\n正推也是可以写出递推式，大家有兴趣可以尝试下。\n\nC++ 描述：\n\n```cpp\n#include<iostream>\n#define MAX 105\nusing namespace std;\nint n, m, sum = -0x3f3f3f3f;\nint map[MAX][MAX];\nint nextt[9][2] = { {0,1},{1,0},{0,2},{2,0},{0,3},{3,0},{1,1},{1,2},{2,1} };\n\nint main()\n{\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++)\n            cin >> map[i][j];\n\n    for(int i=n;i>=1;i--)\n    {\n      for(int j=m;j>=1;j--)\n      {\n        if(i==n&&j==m) continue;\n        int maxTemp=-0x3f3f3f3f;\n        for (int k = 0; k < 9; k++)\n        {\n          int tx = i + nextt[k][0];\n          int ty = j + nextt[k][1];\n          if (tx > n || ty > m) continue;\n          maxTemp=max(maxTemp,map[tx][ty]);\n        }\n        map[i][j]+=maxTemp;\n      }\n    }\n        // for (int i = 1; i <= n; i++){\n        //   for (int j = 1; j <= m; j++)\n        //   cout << map[i][j]<<\" \";\n\n        //   cout<<endl;\n        // }\n          cout << map[1][1];\n    return 0;\n}\n```\n\nPython 语言描述：\n\n```python\nnextt = [[0, 1], [0, 2], [0, 3], [1, 0], [2, 0], [3, 0], [1, 1], [1, 2], [2, 1]]  # 9种走的方式\n\nn, m = map(int, input().split())\n\nDP = [list(map(int, input().split())) for i in range(n)]\n\nfor i in range(n - 1, -1, -1):\n    for j in range(m - 1, -1, -1):\n        if i == n - 1 and j == m - 1:\n            continue\n\n        maxTemp = float('-inf')\n\n        for k in range(9):\n            tx = i + nextt[k][0]\n            ty = j + nextt[k][1]\n\n            if tx >= n or ty >= m:\n                continue\n\n            maxTemp = max(maxTemp, DP[tx][ty])\n\n        DP[i][j] += maxTemp\n\nprint(DP[0][0])\n```\n\njava 语言描述：\n\n```java\nimport java.io.*;\nimport java.util.Scanner;\npublic class test\n{\n\n    public static int n, m, Sum = -0x3f3f3f3f;\n\n    public static int [][] mapTable=new int [105][105];\n\n    public static int nextt[][] ={ {0,1},{1,0},{0,2},{2,0},{0,3},{3,0},{1,1},{1,2},{2,1} };\n\n\n\n public static void main (String[] args) throws java.lang.Exception\n {\n\n      Scanner in =new Scanner(System.in);\n      n=in.nextInt();\n      m=in.nextInt();\n     for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= m; j++)\n                    mapTable[i][j]=in.nextInt();\n\n    for(int i=n;i>=1;i--)\n    {\n      for(int j=m;j>=1;j--)\n      {\n        if(i==n&&j==m) continue;\n        int maxTemp=-0x3f3f3f3f;\n\n        for (int k = 0; k < 9; k++)\n        {\n          int tx = i + nextt[k][0];\n          int ty = j + nextt[k][1];\n          if (tx > n || ty > m) continue;\n          maxTemp=Math.max(maxTemp,mapTable[tx][ty]);\n        }\n        mapTable[i][j]+=maxTemp;\n      }\n    }\n\n  System.out.println(mapTable[1][1]);\n }\n}\n```\n\n------\n\nshow: step version: 1.0 enable_checker: true\n\n------\n\n# 动态规划背包问题 #\n\n## 实验介绍 ##\n\n本节课我们进入动态规划课程的学习，动态规划是一种多阶段的决策过程最优化的问题。\n\n本课程对于算法学习非常重要，但是又比较难，我们讲解分 33 个章节进行动态规划问题的讲解。\n\n今天的课程是动态规划系列的第二个章节。\n\n### 知识点 ###\n\n- 0-1 背包\n- 完全背包\n- 多重背包问题\n\n## 背包问题 ##\n\n我们上一章课程讲解了动态规划算法的基本原理，包括动态规划的“为什么使用动态规划算法”、“多阶段决策过程最优化问题”、“动态规划中的术语解释”，“可解动态鬼规划的性质”等知识点。\n\n今天我们来讲一下，动态规划中的背包问题，背包问题，是比赛中常考的问题，也是动态规划入门的问题，其实动态规划并没有套路，只是这类问题有着明确的特点，如果你做的题足够多的话，你会发现很多问题都会有模板。\n\n背包问题基本都是不可拆分背包，因为可拆分背包是贪心去求解的问题。我们今天讲三种背包的基本模型：1.0-1 背包、2.完全背包、3.多重背包问题。\n\n#### 0-1 背包问题 ####\n\n0-1 背包是背包问题的入门的问题。但是背包问题的模板也是最简单的。\n\n**0-1 背包的问题是什么呢？**\n\n其问题的简单表述为，有 N 件物品，每件物品只有一件。每个物品都有一个价值��*w**i*，每件物品都有一个占一个部分空间��*c**i*,已知你的背包共计可承重 C(Contains),现在让你求你的背包最多装得下多少����*w**M**a**x*，即求你背包中物品的最大价值����*w**M**a**x*。\n\n**对于这个问题我们有以下模板:**\n\n1.定义变量并输入\n\nC++ 语言描述：\n\n```c++\n// 定义V,W用于保存价值和质量\n#define Maxn 5000\n\nint c[Maxn],w[Maxn];\n\nint C;\n\n// 输入\n\nint n;\n\ncin>> n;\n\nfor(int i=0;i<n;i++)\n{\n    cin>>c[i]>>w[i];\n}\n\ncin>>C;\n\n//创建动态规划数组\n\nint dp[Maxn];\n```\n\nPython 语言描述：\n\n```python\nimport os\nimport sys\n\nc = []\nw = []\ndp = []\n\nif __name__ == '__main__':\n\n    n, C = map(int, input().strip().split())\n\n    for i in range(n):\n\n        tempC, tempW = map(int, input().strip().split())\n\n        c.append(tempC)\n\n        w.append(tempW)\n```\n\njava 语言描述：\n\n```java\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nimport static java.lang.Math.max;\n\npublic  class  Main{\n\n    static int []c;\n    static int []w;\n    static int dp[];\n\n   static int C;\n\n    static int n;\n\n    public static void main(String[] args)\n    {\n        Scanner in = new Scanner(System.in);\n\n        n=in.nextInt();\n\n       C=in.nextInt();\n\n       c=new int[n+50];\n\n       w=new int[n+50];\n\n       dp=new int [C+50];\n\n        for (int i = 0; i < n; i++) {\n\n             c[i]=in.nextInt();\n             w[i]=in.nextInt();;\n        }\n\n\n\n    }\n}\n```\n\n2.执行算法\n\n我们先去找到状态转移方程\n\n```\ndp[i][j]=max(dp[i][j],dp[i−1]j−c[i]]+w[i])\n```\n\n含义，选到第 i 件物品，且背包现在重量为 j。\n\n那么考虑这个状态会由什么状态转移而来，肯定是选到第 i-1 件的时候。\n\n如果选了第 i 件，那么就是由 `dp[i−1]j−c[i]]`转移而来。\n\n如果不选第 i 件，那么就是由 `dp[i][j]`转移而来。\n\n那么已知 `dp[i−1]j−c[i]]和 dp[i][j]`都为各自最优的状态，那我们直接取最优状态即可。\n\nC++ 描述：\n\n```c\nfor(int i=0;i<n;i++)\n{\n\n    for(int j=0;j<=C;j++)\n    {\n        if(j>=c[i])\n            dp[i][j]=max(dp[i][j],dp[i-1][j-c[i]]+w[i]);\n    }\n}\n```\n\nPython 语言描述:\n\n```python\n    for i in range(n):\n\n        for j in reversed(C+1):\n\n            dp[i][j]=max(dp[i][j],dp[i-1][j-c[i]]+w[i])\n\n    print(dp[C])\n```\n\nJava 语言描述：\n\n```java\nfor(int i=0;i<n;i++)\n{\n\n    for(int j=0;j<=C;j++)\n    {\n        if(j>=c[i])\n            dp[i][j]=max(dp[i][j],dp[i-1][j-c[i]]+w[i]);\n    }\n}\n\n\n        System.out.println(dp[C]);\n```\n\n空间优化：\n\n因为状态转移每次只与上一层有关，所以用一个一维数组就可以。\n\n为什么从大到小遍历， 看 ��[�]=��[�−�[�]]+�[�]*d**p*[*j*]=*d**p*[*j*−*c*[*i*]]+*w*[*i*] 这一状态转移，是根据小的改大的，如果先把小的改了，那小的还会被用到，数据就不对了，所以从小到大。\n\nC++ 描述；\n\n```c\nfor(int i=0;i<n;i++) //遍历每一件物品\n    for(int j=C;j>=c[i];j--)\n    //遍历背包容量，表示在上一层的基础上，容量为J时，第i件物品装或不装的最优解;\n        dp[j]=max(dp[j-c[i]]+w[i],dp[j]);\n```\n\nPython 语言描述:\n\n```python\n    for i in range(n):\n\n        for j in reversed(range(c[i],C+1)):\n            dp[j] = max(dp[j - c[i]] + w[i], dp[j]);\n\n    print(dp[C])\n```\n\nJava 语言描述：\n\n```java\n        for (int i = 0; i < n; i++) //遍历每一件物品\n        {\n\n            for (int j = C; j >= c[i]; j--)\n                //遍历背包容量，表示在上一层的基础上，容量为J时，第i件物品装或不装的最优解;\n                dp[j] = max(dp[j - c[i]] + w[i], dp[j]);\n        }\n\n\n        System.out.println(dp[C]);\n```\n\n初始化细节：\n\n- 装满 ��[0]=0*d**p*[0]=0，其余赋值 −���−*I**N**F*；\n- 不装满全初始化为 00；\n\nC++ 语言描述：\n\n```c\n//装满\nmemset(dp, 0, sizeof(dp));\n\ndp[0]=0;\n\n//不装满\n\nmemset(dp, -0x3f, sizeof(dp));\n```\n\nPython 语言描述:\n\n```python\n# 装满\nfor i in range(C + 50):\n\n    dp.append(-0x3f3f3f3f)\n\ndp[0]=0\n\n# 不装满\nfor i in range(C + 50):\n\n    dp.append(0)\n```\n\nJava 语言描述：\n\n```java\n//装满\nArrays.fill(dp, -0x3f3f3f3f);\n\ndp[0]=0;\n\n//不装满\n\nmemset(dp, -0x3f, sizeof(dp));\n```\n\n**题目描述:**\n\n题目链接：https://www.lanqiao.cn/problems/1174/learning/\n\n小明有一个容量为 �*V* 的背包。\n\n这天他去商场购物，商场一共有 �*N* 件物品，第 �*i* 件物品的体积为 �*w* ，价值为 �*v*，每种物品都只有一个。\n\n小明想知道在购买的物品总体积不超过 �*V* 的情况下所能获得的最大价值为多少，请你帮他算算。\n\n**输入描述:**\n\n输入第 11 行包含两个正整数 �,�*N*,*V*，表示商场物品的数量和小明的背包容量。\n\n第 2∼�+12∼*N*+1 行包含 22 个正整数 �,�*w*,*v*，表示物品的体积和价值。\n\n**样例:**\n\n```txt\n输入：\n\n5 20\n1 6\n2 5\n3 8\n5 15\n3 3\n输出：\n\n37\n```\n\n**运行限制:**\n\n```txt\n1. 最大运行时间：1s\n2. 最大运行内存：128M\n```\n\n**答案解析：**\n\n**C++ 解题代码**\n\n```cpp\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n#define Maxn 5000\n\n\nint c[Maxn], w[Maxn];\nint dp[Maxn];\nint C;\n\n// 输入\n\nint n;\n\nint main() {\n\n    cin >> n;\n\n    cin >> C;\n\n    for (int i = 0; i < n; i++) {\n\n        cin >> c[i] >> w[i];\n    }\n\n\n    int dp[Maxn];\n\n    memset(dp, 0, sizeof(dp)); //不装满\n\n    //创建动态规划数组\n\n\n\n    for (int i = 0; i < n; i++) //遍历每一件物品\n    {\n\n        for (int j = C; j >= c[i]; j--)\n            //遍历背包容量，表示在上一层的基础上，容量为J时，第i件物品装或不装的最优解;\n            dp[j] = max(dp[j - c[i]] + w[i], dp[j]);\n    }\n\n    cout << dp[C] << endl;\n\n}\n```\n\n**Python 解题代码**\n\n```python\nc = []\nw = []\ndp = []\n\nif __name__ == '__main__':\n\n    n, C = map(int, input().strip().split())\n    for i in range(n):\n        tempC, tempW = map(int, input().strip().split())\n        c.append(tempC)\n        w.append(tempW)\n\n    for i in range(C + 50):\n        dp.append(0)\n\n    for i in range(n):\n        for j in reversed(range(c[i],C+1)):\n            dp[j] = max(dp[j - c[i]] + w[i], dp[j]);\n\n    print(dp[C])\n```\n\n**Java 解题代码**\n\n```java\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nimport static java.lang.Math.max;\n\npublic  class  Main{\n\n    static int []c;\n    static int []w;\n    static int dp[];\n    static int C;\n    static int n;\n\n    public static void main(String[] args)\n    {\n        Scanner in = new Scanner(System.in);\n\n        n=in.nextInt();\n        C=in.nextInt();\n        c=new int[n+50];\n        w=new int[n+50];\n        dp=new int [C+50];\n\n        for (int i = 0; i < n; i++) {\n\n             c[i]=in.nextInt();\n             w[i]=in.nextInt();;\n        }\n\n        Arrays.fill(dp, 0);\n\n        for (int i = 0; i < n; i++) //遍历每一件物品\n        {\n\n            for (int j = C; j >= c[i]; j--)\n                //遍历背包容量，表示在上一层的基础上，容量为J时，第i件物品装或不装的最优解;\n                dp[j] = max(dp[j - c[i]] + w[i], dp[j]);\n        }\n        System.out.println(dp[C]);\n\n    }\n}\n```\n\n#### 完全背包问题 ####\n\n完全背包是背包问题的入门的问题。\n\n根据 `0-1` 背包写出模板也是很简单的。\n\n**完全背包的问题是什么呢？**\n\n其问题的简单表述为，有 �*N* 件物品，每件物品有无数件。每个物品都有一个价值��*w**i*，每件物品都有一个占一个部分空间��*c**i*,已知你的背包共计可承重 �(��������)*C*(*C**o**n**t**a**i**n**s*),现在让你求你的背包最多装得下多少����*w**M**a**x*，即求你背包中物品的最大价值����*w**M**a**x*。\n\n**对于这个问题我们有以下模板:**\n\n1.定义变量并输入\n\n参考 0-1 背包。\n\n2.执行算法\n\n我们先去找到状态转移方程\n\n```\ndp[i][j]=max(dp[i][j],dp[i]j−c[i]]+w[i])\n```\n\n含义，选到第 �*i* 件物品，且背包现在重量为 �*j*。\n\n那么考虑这个状态会由什么状态转移而来，肯定是选到第 �−1*i*−1 件的时候,或者选了若干次第 �*i* 件。\n\n如果不选第 �*i* 种，那么就是由 `dp[i-1][j]`转移而来。\n\n如果选了第 �*i* 件，那么就是由 `dp[i−1]j−c[i]]`转移而来。\n\n或者在某一刻，不在选第 �*i* 件了，那么就是有 `dp[i][j]`转移而来。\n\n那么已知 `dp[i]j−c[i]]`和 `dp[i][j]`都为各自最优的状态，那我们直接取最优状态即可。\n\nC++ 描述：\n\n```c++\nfor(int i=0;i<n;i++){\n    for(int j=0;j<=C;j++){\n        dp[i][j]=dp[i-1][j];\n        if(j>=c[i])  dp[i][j]=max(dp[i][j],dp[i][j-c[i]]+w[i]);\n    }\n}\ncout<<dp[n][C]<<endl;\n```\n\nPython 语言描述:\n\n```python\n    for i in range(n):\n        for j in range(C+1):\n            dp[i][j]=dp[i-1][j];\n            dp[i][j]=max(dp[i][j],dp[i][j-c[i]]+w[i])\n    print(dp[n][C])\n```\n\nJava 语言描述：\n\n```java\nfor(int i=0;i<n;i++){\n    for(int j=0;j<=C;j++){\n        dp[i][j]=dp[i-1][j];\n        if(j>=c[i])dp[i][j]=max(dp[i][j],dp[i][j-c[i]]+w[i]);\n    }\n}\n System.out.println(dp[n][C]);\n```\n\n空间优化：\n\n因为状态转移每次只与上一层有关，所以用一个一维数组就可以。\n\n为什么从小到大遍历， 看 ��[�]=��[�−�[�]]+�[�]*d**p*[*j*]=*d**p*[*j*−*c*[*i*]]+*w*[*i*] 这一状态转移，是根据小的改大的，而此时的含义为选了 `x` 件后的容量与质量，跟 `01` 背包类似，但含义不同，处理方式上也有本质区别，处理完一件后在处理下件。\n\nC++ 描述；\n\n```c\nfor(int i=0;i<n;i++) //遍历每一件物品\n    for(int j=c[i];j<=C;j++)\n    //遍历背包容量，表示在上一层的基础上，容量为J时，第i件物品装或不装的最优解;\n        dp[j]=max(dp[j-c[i]]+w[i],dp[j]);\n```\n\nPython 语言描述:\n\n```python\n    for i in range(n):\n\n        for j in range(c[i],C+1):\n            dp[j] = max(dp[j - c[i]] + w[i], dp[j]);\n\n    print(dp[C])\n```\n\nJava 语言描述：\n\n```java\n        for (int i = 0; i < n; i++) //遍历每一件物品\n        {\n\n            for(int j=c[i];j<=C;j++)\n                //遍历背包容量，表示在上一层的基础上，容量为J时，第i件物品装或不装的最优解;\n                dp[j] = max(dp[j - c[i]] + w[i], dp[j]);\n        }\n\n\n        System.out.println(dp[C]);\n```\n\n初始化细节：\n\n与 `0 - 1`背包相同。\n\n- 装满 ��[0]=0*d**p*[0]=0，其余赋值−���−*I**N**F*；\n- 不装满全初始化为 00；\n\n**题目描述:**\n\n题目链接：https://www.lanqiao.cn/problems/1175/learning/\n\n小明有一个容量为 �*V* 的背包。\n\n这天他去商场购物，商场一共有 �*N* 件物品，第 �*i* 件物品的体积为 �*w* ，价值为 �*v*，每种物品都有无限多个。\n\n小明想知道在购买的物品总体积不超过 �*V* 的情况下所能获得的最大价值为多少，请你帮他算算。\n\n**输入描述:**\n\n输入第 11 行包含两个正整数 �,�*N*,*V*，表示商场物品的数量和小明的背包容量。\n\n第 2∼�+12∼*N*+1 行包含 22 个正整数 �,�*w*,*v*，表示物品的体积和价值。\n\n**样例:**\n\n```txt\n输入：\n\n5 20\n1 6\n2 5\n3 8\n5 15\n3 3\n输出：\n\n120\n```\n\n**运行限制:**\n\n```txt\n1. 最大运行时间：1s\n2. 最大运行内存：128M\n```\n\n**答案解析：**\n\n**C++ 解题代码**\n\n```cpp\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n#define Maxn 5000\n\nint c[Maxn], w[Maxn];\nint dp[Maxn];\nint C;\n// 输入\n\nint n;\nint main() {\n\n    cin >> n;\n    cin >> C;\n\n    for (int i = 0; i < n; i++) {\n\n        cin >> c[i] >> w[i];\n    }\n\n    int dp[Maxn];\n\n    memset(dp, 0, sizeof(dp)); //不装满\n    //创建动态规划数组\n\n    for (int i = 0; i < n; i++) //遍历每一件物品\n    {\n        for(int j=c[i];j<=C;j++)\n            //遍历背包容量，表示在上一层的基础上，容量为J时，第i件物品装或不装的最优解;\n            dp[j] = max(dp[j - c[i]] + w[i], dp[j]);\n    }\n    cout << dp[C] << endl;\n\n}\n```\n\n**Python 解题代码**\n\n```python\nimport os\nimport sys\n\nc = []\nw = []\ndp = []\n\nif __name__ == '__main__':\n\n    n, C = map(int, input().strip().split())\n\n    for i in range(n):\n        tempC, tempW = map(int, input().strip().split())\n        c.append(tempC)\n        w.append(tempW)\n\n    for i in range(C + 50):\n        dp.append(0)\n\n    for i in range(n):\n        for j in range(c[i],C+1):\n            dp[j] = max(dp[j - c[i]] + w[i], dp[j])\n\n    print(dp[C])\n```\n\n**Java 解题代码**\n\n```java\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nimport static java.lang.Math.max;\n\npublic  class  Main{\n\n    static int []c;\n    static int []w;\n    static int dp[];\n    static int C;\n    static int n;\n\n    public static void main(String[] args)\n    {\n        Scanner in = new Scanner(System.in);\n\n        n=in.nextInt();\n        C=in.nextInt();\n        c=new int[n+50];\n        w=new int[n+50];\n        dp=new int [C+50];\n        for (int i = 0; i < n; i++) {\n             c[i]=in.nextInt();\n             w[i]=in.nextInt();;\n        }\n        Arrays.fill(dp, 0);\n        for (int i = 0; i < n; i++) //遍历每一件物品\n        {\n                for(int j=c[i];j<=C;j++)\n                //遍历背包容量，表示在上一层的基础上，容量为J时，第i件物品装或不装的最优解;\n                dp[j] = max(dp[j - c[i]] + w[i], dp[j]);\n        }\n        System.out.println(dp[C])\n    }\n}\n```\n\n#### 多重背包 ####\n\n多重背包是背包问题的入门的问题。 根据 0-1 背包写出模板也是很简单的。\n\n**多重背包的问题是什么呢？**\n\n其问题的简单表述为，有 N 件物品，每件物品有��*s**i*件。每个物品都有一个价值��*w**i*，每件物品都有一个占一个部分空间��*c**i*,已知你的背包共计可承重 C(Contains),现在让你求你的背包最多装得下多少����*w**M**a**x*，即求你背包中物品的最大价值����*w**M**a**x*。\n\n**对于这个问题我们有以下模板:**\n\n1.定义变量并输入\n\n参考 `0-1` 背包。\n\n2.执行算法\n\n这次我们直接空间优化，不再讲解二维做法：\n\n多重背包是可以不选，也可以选 `1` 个，可以选多个，而 `0-1` 背包只能选 `0` 个或者 `1`个。\n\n那就直接把种物品分开，即可比如：\n\n每个盘子 `3` 块钱，我有 `2` 个。每双筷子 `1` 块钱，我有 `10` 双，每对刀叉 `3` 块钱，我有 `3` 个。\n\n那么我就可以拆成，有 `2` 个三块的盘子，每个可以选也可以不选，就变成了 `0-1` 背包。\n\n也就是说，对于每种是可以选多个，那就直接拆分成独立的个体就可以了。\n\nC++ 描述；\n\n```c\nfor(int i=0;i<n;i++)\n//遍历每一个物品\n    for(int j=0;j<=s[i];j++)\n    //遍历物品的数量\n        for(int k=C;k>=c[i];k--)\n        //当做01背包来处理\n        {\n            //取01背包情况的dp[k]和dp[k-c[i]]+w[i]的最大值\n            dp[k]=max( dp[k],dp[k-c[i]]+w[i] );\n        }\n```\n\nPython 语言描述:\n\n```python\n    for i in range(n):\n        for j in range(s[i]+1):\n            for k in reversed(range(c[i],C+1)):\n                dp[k]=max( dp[k],dp[k-c[i]]+w[i] )\n\n    print(dp[C])\n```\n\nJava 语言描述：\n\n```java\nfor(int i=0;i<n;i++)\n//遍历每一个物品\n    for(int j=0;j<=s[i];j++)\n    //遍历物品的数量\n        for(int k=C;k>=c[i];k--)\n        //当做01背包来处理\n        {\n            //取01背包情况的dp[k]和dp[k-c[i]]+w[i]的最大值\n            dp[k]=max( dp[k],dp[k-c[i]]+w[i] );\n        }\n\n\nSystem.out.println(dp[C]);\n```\n\n不顾这样做大概率会超时，我们换一种理解方式：\n\n在这两种问题中，我们需要考虑每个物品选择取或不取的情况，通过动态规划来求解最优解。\n\n0101背包问题中，对于每个物品�*i*，我们有两个选择：选取或不选取。状态转移方程为： [ dp[j] = \\max(dp[j], dp[j - v[i]] + w[i]) ]\n\n多重背包问题中，对于每个物品i，我们可以选择取00个、11个、22个...直到�[�]*s*[*i*]个。状态转移方程为： [ dp[j] = \\max(dp[j], dp[j - v[i] \\cdot k] + w[i] \\cdot k) ] 其中，k的取值范围是[0, 1, 2, ..., s[i]]\n\n这两个问题的解决思路相似，都是通过填充一个二维的动态规划数组��*d**p*，其中��[�]*d**p*[*j*]表示背包容量为j时的最优解。在状态转移时，我们考虑了每个物品的选择情况，求解最终的最优解。\n\n初始化细节：\n\n与 0−10−1 背包相同。\n\n- 装满 ��[0]=0*d**p*[0]=0，其余赋值−���−*I**N**F*；\n- 不装满全初始化为 00；\n\n**题目描述:**\n\n题目链接：https://www.lanqiao.cn/problems/1176/learning/\n\n小明有一个容量为 �*V*的背包。\n\n这天他去商场购物，商场一共有 �*N* 件物品，第 �*i* 件物品的体积为 �*w*，价值为 �*v*，每种物品都有�*s*个。\n\n小明想知道在购买的物品总体积不超过 �*V* 的情况下所能获得的最大价值为多少，请你帮他算算。\n\n**输入描述:**\n\n输入第 11 行包含两个正整数 �,�*N*,*V*，表示商场物品的数量和小明的背包容量。\n\n第 2∼�+12∼*N*+1 行包含 33 个正整数 �,��*w*,*v**s*,表示物品的体积、价值和数量。\n\n**样例:**\n\n```txt\n输入：\n\n3 30\n1 2 3\n4 5 6\n7 8 9\n输出：\n\n39\n```\n\n**运行限制:**\n\n```txt\n1. 最大运行时间：1s\n2. 最大运行内存：128M\n```\n\n**答案解析：**\n\n**C++ 解题代码**\n\n```cpp\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n#define Maxn 5000\n\nint c[Maxn], w[Maxn], s[Maxn];\nint dp[Maxn];\nint C;\n\n// 输入\nint n;\n\nint main() {\n\n    cin >> n;\n    cin >> C;\n    for (int i = 0; i < n; i++) {\n        cin >> c[i] >> w[i] >> s[i];\n    }\n\n\n    int dp[Maxn];\n    memset(dp, 0, sizeof(dp)); //不装满\n\n    //创建动态规划数组\n\n    for (int i = 0; i < n; i++)\n//遍历每一个物品\n    {\n        for(int j=C;j>=c[i];j--)\n        {\n            for(int k=1;k<=s[i] && j>=k*c[i];k++)\n                //遍历物品的数量\n                dp[j]=max(dp[j],dp[j-k*c[i]]+w[i]*k);\n        }\n    }\n\n    cout << dp[C] << endl;\n\n}\n```\n\n**Python 解题代码**\n\n```python\nc = []\nw = []\ns=[]\ndp = []\n\nif __name__ == '__main__':\n\n    n, C = map(int, input().strip().split())\n\n    for i in range(n):\n\n        tempC, tempW ,tempS= map(int, input().strip().split())\n        c.append(tempC)\n        w.append(tempW)\n        s.append(tempS)\n\n    for i in range(C + 50):\n        dp.append(0)\n\n    for i in range(n):\n        for j in reversed(range(c[i],C+1)):\n            for k in range(s[i]+1):\n                if j<k*c[i]:\n                    break;\n                dp[j] = max(dp[j], dp[j - k * c[i]] + w[i] * k)\n\n    print(dp[C])\n```\n\n**Java 解题代码**\n\n```java\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nimport static java.lang.Math.max;\n\npublic  class  Main{\n\n        static int []c;\n        static int []w;\n        static int []s;\n        static int dp[];\n\n        public static void main(String[] args)\n        {\n            Scanner in = new Scanner(System.in);\n            int n=in.nextInt();\n            int C=in.nextInt();\n            c=new int[n+50];\n            w=new int[n+50];\n            s=new int[n+50];\n            dp=new int [C+50];\n\n            for (int i = 0; i < n; i++) {\n\n                c[i]=in.nextInt();\n                w[i]=in.nextInt();\n                s[i]=in.nextInt();\n            }\n\n            Arrays.fill(dp, 0);\n            for (int i = 0; i < n; i++)\n//遍历每一个物品\n            {\n                for(int j=C;j>=c[i];j--)\n                {\n                    for(int k=1;k<=s[i] && j>=k*c[i];k++)\n                        //遍历物品的数量\n                        dp[j]=max(dp[j],dp[j-k*c[i]]+w[i]*k);\n                }\n            }\n\n            System.out.println(dp[C]);\n\n\n    }\n}\n```\n\n------\n\nshow: step version: 1.0 enable_checker: true\n\n------\n\n# 动态规划线性 DP #\n\n## 实验介绍 ##\n\n本课程对于算法学习非常重要，但是又比较难，我们讲解分 33 个章节进行动态规划问题的讲解。\n\n今天的课程是动态规划系列的第 33 个章节。\n\n### 知识点 ###\n\n- 讲解很多经典的动态规划问题，对动态规划初步掌握。\n\n## 普通线性 DP ##\n\n线性 `DP` 是动态规划问题中的一类问题，指状态之间有线性关系的动态规划问题。\n\n这类问题不像是我们讲的背包等问题有固定的模板。\n\n少数常见的线性 `DP` 问题也有模板，比如我们讲的 ���*L**I**S* 和 ���*L**C**S* 问题。\n\n大部分还是需要根据题目进行推导，基本没有什么规律可循。\n\n大部分线性规划的问题，都需要自己首先定义状态，找到决策，推导状态转移方程。\n\n我们再讲解几个题目，让大家找找做最普遍 `DP` 问题的感觉。\n\n#### 蓝肽子序列 ####\n\n题目链接：[蓝肽子序列](https://www.lanqiao.cn/problems/1030/learning/)\n\n**题目描述:**\n\nL 星球上的生物由蛋蓝质组成，每一种蛋蓝质由一类称为蓝肽的物资首尾连接成一条长链后折叠而成。\n\n生物学家小乔正在研究 L 星球上的蛋蓝质。她拿到两个蛋蓝质的蓝肽序列，想通过这两条蓝肽序列的共同特点来分析两种蛋蓝质的相似性。\n\n具体的，一个蓝肽可以使用 11 至 55 个英文字母表示，其中第一个字母大写，后面的字母小写。一个蛋蓝质的蓝肽序列可以用蓝肽的表示顺序拼接而成。\n\n在一条蓝肽序列中，如果选取其中的一些位置，把这些位置的蓝肽取出，并按照它们在原序列中的位置摆放，则称为这条蓝肽的一个子序列。蓝肽的子序列不一定在原序列中是连续的，中间可能间隔着一些未被取出的蓝肽。\n\n如果第一条蓝肽序列可以取出一个子序列与第二条蓝肽序列中取出的某个子序列相等，则称为一个公共蓝肽子序列。\n\n给定两条蓝肽序列，找出他们最长的那个公共蓝肽子序列的长度。\n\n**输入描述:**\n\n输入两行，每行包含一个字符串，表示一个蓝肽序列。字符串中间没有空格等分隔字符。\n\n其中有 ，两个字符串的长度均不超过 10001000。\n\n**输出描述:**\n\n输出一个整数，表示最长的那个公共蓝肽子序列的长度。\n\n**输入输出样例:**\n\n**示例:**\n\n> 输入\n\n```txt\nLanQiaoBei LanTaiXiaoQiao\n```\n\n> 输出\n\n```txt\n2\n```\n\n### 运行限制 ###\n\n- 最大运行时间：1s\n- 最大运行内存: 128M\n\n**答案解析：**\n\n该题目是 ���*L**C**S* 的变形，由原来的一个字符或者一个数字的匹配变成了，一个单词的匹配。\n\n这个题目为先划分字符串变成基本的比较单位。\n\n然后再套用 ���*L**C**S* 模板\n\n即可完成这道题目。\n\n**C++ 解题代码：**\n\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint dp[1005][1005];\nstring s1, s2;\nstring a[1005], b[1005];\nint n=0, m=0;\nint main()\n{\n    cin >> s1 >> s2;\n    int d1 = s1.length(), d2 = s2.length();\n    for (int i = 0; i < d1;)\n    {\n        if (s1[i] >= 'A' && s1[i] <= 'Z')\n        {\n            a[n] += s1[i++];\n            while (s1[i] >= 'a' && s1[i] <= 'z')\n            {\n                a[n] += s1[i++];\n            }\n        }\n        n++;\n    }\n    for (int i = 0; i < d2;)\n    {\n        if (s2[i] >= 'A' && s2[i] <= 'Z')\n        {\n            b[m] += s2[i++];\n            while (s2[i] >= 'a' && s2[i] <= 'z')\n            {\n                b[m] += s2[i++];\n            }\n\n        }\n        m++;\n    }\n     dp[0][0] = 0;\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n        {\n\n            if (a[i] == b[j])\n            {\n                dp[i + 1][j + 1] = dp[i][j] + 1;\n            }\n            else\n            {\n                dp[i + 1][j + 1]=max(dp[i + 1][j], dp[i][j + 1]);\n            }\n        }\n    cout << dp[n][m] << endl;\n}\n```\n\n**Python 解题代码**\n\n```python\nMaxn = 1005\ndp = [[0 for _ in range(Maxn)] for _ in range(Maxn)]\n\nif __name__ == '__main__':\n\n    s1 = input()\n    s2 = input()\n    a = []\n    b = []\n    temp = ''\n\n    for word in s1:\n        if 'A' <= word <= 'Z':\n            if temp != '':\n                a.append(temp)\n            temp = ''\n        temp += word\n    a.append(temp)\n\n    temp = ' '\n\n    for word in s2:\n        if 'A' <= word <= 'Z':\n            if temp != '':\n                b.append(temp)\n            temp = ''\n        temp += word\n    b.append(temp)\n\n    n = len(a)\n    m = len(b)\n\n    for i in range(len(a)):\n        for j in range(len(b)):\n            if a[i] == b[j]:\n                dp[i + 1][j + 1] = dp[i][j] + 1\n\n            else:\n                if dp[i + 1][j] > dp[i][j + 1]:\n                    dp[i + 1][j + 1] = dp[i + 1][j]\n\n                else:\n                    dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])\n\n    print(dp[n][m])\n```\n\n**Java 解题代码**\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n\n\n    static int[][] dp;\n    static String s1;\n    static String s2;\n    static String []a;\n    static String []b;\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n\n        int n=0,m=0;\n\n        s1=in.next();\n        s2=in.next();\n\n        a=new String[1005];\n        b=new String[1005];\n\n        int d1=s1.length();\n        int d2=s2.length();\n\n        dp=new int[1005][1005];\n\n        for (int i = 0; i < d1;n++)\n        {\n\n\n            if (s1.charAt(i) - 'A'>=0 && s1.charAt(i) - 'Z'<=0)\n            {\n                a[n] += s1.charAt(i++);\n                while (i < d1&&s1.charAt(i) -'a'>=0 && s1.charAt(i)-'z' <=0)\n                {\n                    a[n] += s1.charAt(i++);\n                }\n\n            }\n\n        }\n        for (int i = 0; i < d2;m++)\n        {\n\n            if (s2.charAt(i) - 'A'>=0 && s2.charAt(i) - 'Z'<=0)\n            {\n                b[m] += s2.charAt(i++);\n                while (i < d2&&s2.charAt(i) -'a'>=0&& s2.charAt(i)-'z' <= 0)\n                {\n                    b[m] += s2.charAt(i++);\n                }\n\n            }\n\n        }\n        dp[0][0] = 0;\n\n        int Maxn=Math.max(n,m)+50;\n        dp=new int[Maxn][Maxn];\n        dp[0][0]=0;\n\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n            {\n                if (a[i].equals( b[j]))\n                {\n                    dp[i + 1][j + 1] = dp[i][j] + 1;\n                }\n                else\n                {\n                    dp[i + 1][j + 1]=Math.max(dp[i + 1][j], dp[i][j + 1]);\n                }\n            }\n        System.out.println(dp[n][m]);\n\n    }\n}\n```\n\n#### 合唱队形 ####\n\n题目链接：https://www.lanqiao.cn/problems/742/learning/\n\n**题目描述:**\n\n�*N* 位同学站成一排，音乐老师要请其中的 (�−�)(*N*−*K*) 位同学出列，使得剩下的 �*K* 位同学排成合唱队形。\n\n合唱队形是指这样的一种队形：设 �*K* 位同学从左到右依次编号为 1，2，⋯�1，2，⋯*K*，他们的身高分别为 �1，�2，⋯，��*T*1，*T*2，⋯，*T**K*， 则他们的身高满足 �1<⋯<��>��+1>⋯>��(1≤�≤�)*T*1<⋯<*T**i*>*T**i*+1>⋯>*T**K*(1≤*i*≤*K*)。\n\n你的任务是，已知所有 �*N* 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。\n\n**输入描述:**\n\n输入两行。\n\n第一行是一个整数 � (2≤�≤100)*N* (2≤*N*≤100)，表示同学的总数。\n\n第二行有 �*n* 个整数，用空格分隔，第 �*i* 个整数 ��(130≤��≤230)*T**i*(130≤*T**i*≤230) 是第 �*i* 位同学的身高(厘米)。\n\n**输出描述:**\n\n输出一个整数，就是最少需要几位同学出列。\n\n**输入输出样例:**\n\n**示例:** 1\n\n> 输入\n\n```txt\n8 186 186 150 200 160 130 197 220\n```\n\n> 输出\n\n```txt\n4\n```\n\n### 运行限制 ###\n\n- 最大运行时间：1s\n- 最大运行内存: 128M\n\n**答案解析：**\n\n要使得出列最少，那么就要留下最多的，我们想到了 ���*L**I**S* ，但是 ���*L**I**S* 只能处理单调序列最长，所以并不能直接用。\n\n我们看到，这里是两头低，中间高的一种情况。\n\n在这种情况下，最多的话那么就是最高的那个人的左侧加上右侧最高。\n\n到这，我们发现。\n\n在中间那个人左侧，从左到右做了一遍 ���*L**I**S* 。\n\n在那个人的右侧，从右到左的做了一遍 ���*L**I**S* 。\n\n至此，我们好像找了策略。\n\n通过枚举中间那个人，然后看他左侧的 ���*L**I**S* 和他右侧的���*L**I**S* 的值之和的大小，就能将这道题目解出。\n\n**C++ 解题代码：**\n\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint dp1[105],dp2[105],a[105],s[105];\nint main()\n{\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>a[i];\n        dp2[i]=1;\n        dp1[i]=1;\n    }//输入并赋初值\n\n    //预处理，从右往左LIS\n    for(int i=n-1;i>=1;i--)\n    {\n        for(int j=i+1;j<=n;j++)\n        {\n            if(a[i]>a[j]&&dp2[i]<=dp2[j]+1)\n            {\n                dp2[i]=dp2[j]+1;\n            }\n        }\n    }\n    //预处理，从左往右LIS\n    for(int i=2;i<=n;i++)\n    {\n        for(int j=1;j<i;j++)\n        {\n            if(a[i]>a[j]&&dp1[i]<=dp1[j]+1)\n            {\n                dp1[i]=dp1[j]+1;\n            }\n        }\n    }\n\n    int maxx=0;\n    for(int i=1;i<=n;i++)\n    {\n        s[i]=dp2[i]+dp1[i]-1;\n        //自己算了两次，所以-1\n\n\n        if(s[i]>maxx)\n        {\n            maxx=s[i];\n        }\n    }\n\n    cout<<n-maxx;//是求出列的人数\n\n}\n```\n\n**Python 解题代码**\n\n```python\nif __name__ == \"__main__\":\n\n    # 输入并赋初值\n    n = int(input().strip())\n\n    t = list(map(int, input().split()))\n\n    dp1 = [1] * n\n    dp2 = [1] * n\n\n    # 预处理，从左往右LIS\n    for i in range(1, n):\n        for j in range(i):\n            if t[i] > t[j]:\n                dp1[i] = max(dp1[i], dp1[j] + 1)\n\n    # 预处理，从右往左LIS\n    for i in range(n - 1, 0, -1):\n        for j in range(n - 1, i, -1):\n            if t[i] > t[j]:\n                dp2[i] = max(dp2[i], dp2[j] + 1)\n\n\n    maxx = 0\n\n    for i in range(n):\n        maxx = max(maxx, dp1[i] + dp2[i] - 1)\n        # 自己算了两次，所以-1\n\n    print(n - maxx)\n```\n\n**Java 解题代码**\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        Scanner in = new Scanner(System.in);\n\n        int n = in.nextInt();\n\n        int[] a = new int[n];\n        int[] dp1 = new int[n];\n        int[] dp2 = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n            dp2[i]=1;\n            dp1[i]=1;\n        }//输入并赋初值\n\n\n        //预处理，从左往右LIS\n        for (int i = 0; i < n; i++) {\n\n            for (int j = 0; j < i; j++) {\n                if (a[i] > a[j] && dp1[j] + 1 > dp1[i]) {\n                    dp1[i] = dp1[j] + 1;\n                }\n            }\n        }\n\n        //预处理，从右往左LIS\n        for (int i = n - 1; i >= 0; i--) {\n\n            for (int j = n - 1; j > i; j--) {\n                if (a[i] > a[j] && dp2[j] + 1 > dp2[i]) {\n                    dp2[i] = dp2[j] + 1;\n                }\n            }\n        }\n\n        int maxx = 0;\n\n        for (int i = 0; i < n; i++) {\n            maxx = Math.max(maxx, dp1[i] + dp2[i]-1);\n            //自己算了两次，所以-1\n        }\n\n        // 是求出列的人数\n        System.out.println(n - maxx );\n    }\n}\n```\n\n#### 最优包含 ####\n\n题目链接：https://www.lanqiao.cn/problems/239/learning/\n\n**题目描述:** 我们称一个字符串 �*S* 包含字符串 �*T* 是指 �*T* 是 �*S* 的一个子序列，即可以从字符串 �*S* 中抽出若干个字符，它们按原来的顺序组合成一个新的字符串与 �*T* 完全一样。给定两个字符串 �*S* 和 �*T*，请问最少修改 �*S* 中的多少个字符，能使 �*S* 包含 �*T* ？其中，1≤∣�∣≤∣�∣≤10001≤∣*T*∣≤∣*S*∣≤1000。\n\n**输入描述:**\n\n输入两行，每行一个字符串。第一行的字符串为 �*S*，第二行的字符串为 �*T*。两个字符串均非空而且只包含大写英文字母。**输出描述:**\n\n输出一个整数，表示答案。\n\n**输入输出样例:**\n\n**示例:**\n\n> 输入\n\n```txt\nABCDEABCD XAABZ\n```\n\n> 输出\n\n```txt\n3\n```\n\n**运行限制**\n\n- 最大运行时间：1s\n- 最大运行内存: 256M\n\n**答案解析：**\n\n个题目是线性 `DP` 中比较经典的题目。\n\n这个类型就做编辑距离，可以通过 `DFS` 解决，也可以通过 `DP` 解决。\n\n`DP` 的时间复杂度低。\n\n我们先来讲一下，编辑距离。\n\n编辑距离为两个字符串，�*a* 和 �*b* 通过多少次变换，使得 �*a* 变成 �*b*。\n\n我们可以做出 33 种操作。\n\n1.1. 删除操作，将 �[�]*a*[*i*] 从 �*a* 中移除 2.2. 插入操作，在 �[�]*a*[*i*] 后加上 �[�]*b*[*j*] 3.3. 替换操作，将 �[�]*a*[*i*] 修改为 �[�]*b*[*j*]\n\n编辑距离的状态转移类似 LCS ，但有有很大的差别。\n\n初始状态，�=�=0*i*=*j*=0，都在字符串的开头。\n\n然后开始判断 �[�]=?�[�]*a*[*i*]=?*b*[*j*]\n\n- 如果相同，那么就不需要修改，所以��[�+1][�+1]=��[�][�]*d**p*[*i*+1][*j*+1]=*d**p*[*i*][*j*]\n\n  所以在�[�−1]*a*[*i*−1]等于�[�−1]*b*[*j*−1]时，��[�][�]*d**p*[*i*][*j*]这个状态由��[�−1][�−1]*d**p*[*i*−1][*j*−1]转移而来。\n\n  ��[�][�]=��[�−1][�−1]*d**p*[*i*][*j*]=*d**p*[*i*−1][*j*−1]\n\n- 如果不同，那就需要进行三种可能的操作\n\n1. 修改操作：\n\n   �[�]*a*[*i*] 修改为 �[�]*b*[*j*]， 因为编辑了一次，所以+1+1\n\n   ��[�+1][�+1]=��[�][�]+1*d**p*[*i*+1][*j*+1]=*d**p*[*i*][*j*]+1\n\n   所以在�[�−1]*a*[*i*−1]不等于�[�−1]*b*[*j*−1]时，��[�][�]*d**p*[*i*][*j*]这个状态由��[�−1][�−1]*d**p*[*i*−1][*j*−1]转移而来。\n\n   ��[�][�]=��[�−1][�−1]*d**p*[*i*][*j*]=*d**p*[*i*−1][*j*−1]\n\n2. 删除操作，直接把 �[�]*a*[*i*] 删除，此时转移到 ��[�][�+1]*d**p*[*i*][*j*+1] ，因为 �[�]*a*[*i*] 被删除，但是下一个字符到了 �[�]*a*[*i*] 的位置，而对应比较的位置到了�[�+1]*b*[*j*+1]。\n\n   所以此时状态转移到了��[�][�+1]*d**p*[*i*][*j*+1]\n\n   ��[�][�+1]=��[�][�]+1*d**p*[*i*][*j*+1]=*d**p*[*i*][*j*]+1\n\n   因为编辑了一次，所以+1+1\n\n   所以在�[�−1]*a*[*i*−1]不等于�[�−1]*b*[*j*−1]时，��[�][�]*d**p*[*i*][*j*]就有可能通过��[�−1][�]*d**p*[*i*−1][*j*]转移而来。\n\n3. 插入操作，在�[�]*a*[*i*]后添加一个�[�]*b*[*j*]，那么此时�[�+1]*a*[*i*+1]和�[�]*b*[*j*]对应，因为加了一个字符就变成了�[�+1]*a*[*i*+1],而且跟�[�]*b*[*j*]对应，那么下一个状态转移到了��[�+1][�]*d**p*[*i*+1][*j*]\n\n   ��[�+1][�]=��[�][�]+1*d**p*[*i*+1][*j*]=*d**p*[*i*][*j*]+1\n\n   此时状态转移到了 ��[�+1][�]=��[�][�]+1*d**p*[*i*+1][*j*]=*d**p*[*i*][*j*]+1\n\n   因为编辑了一次，所以+1+1\n\n   所以在�[�−1]*a*[*i*−1]不等于�[�−1]*b*[*j*−1]时，��[�][�]*d**p*[*i*][*j*]就有可能通过��[�][�−1]*d**p*[*i*][*j*−1]转移而来。\n\n那么不同时，我们选择他们的最小值即可。\n\n由此我们可以写出模板：\n\n**C++ 解题代码：**\n\n```cpp\n#include<iostream>\n#include<algorithm>\n#include<set>\n#include<string>\n\nusing namespace std;\n#define INF 99999999\nstring s, t;\nint dp[1010][1010];\n\nvoid init(){\n    for (int i = 0; i <= s.size(); i++) dp[i][0] = 0;\n    for (int j = 1; j <= t.size(); j++) dp[0][j] = INF;\n}\n\nint main() {\n    cin >> s >> t;\n\n    init();\n\n    for (int i = 1; i <= s.size(); i++) {\n        for (int j = 1; j <= t.size(); j++) {\n            if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1];\n            else\n                dp[i][j] = min(dp[i - 1][j - 1],min(dp[i - 1][j], dp[i][j - 1])) + 1;\n        }\n    }\n    cout << dp[s.size()][t.size()];\n    return 0;\n}\n```\n\n**Python 解题代码**\n\n```python\ndef init(s,t):\n\n    dp = [[0 for i in range(len(t) + 1)] for j in range(len(s) + 1)]\n    for i in range(len(s) + 1):\n        dp[i][0] = 0\n\n    for j in range(1,len(t) + 1):\n        dp[0][j] = 999999\n\n    return dp\n\nif __name__ == '__main__':\n    s = list(input())\n    t = list(input())\n\n    dp=init(s,t)\n\n    for i in range(len(s)):\n        for j in range(len(t)):\n            if s[i] == t[j]:\n                dp[i + 1][j + 1] = dp[i][j]\n            else:\n                dp[i + 1][j + 1] = min(dp[i][j] + 1, dp[i][j + 1])\n                dp[i + 1][j + 1] = min( dp[i + 1][j + 1] ,dp[j+1][i]+1)\n\n    print(dp[-1][-1])\n```\n\n**Java 解题代码**\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n    public static   int dp[][];\n\n    public static void init(int n,int m){\n\n        dp = new int[n+1][m+1];\n        for (int i = 0; i <= n; i++) dp[i][0] = 0;\n        for (int j = 1; j <= m; j++) dp[0][j] = 99999;\n    }\n\n    public static void main(String[] args) {\n\n        Scanner in = new Scanner(System.in);\n\n        String s = in.nextLine();\n        String t = in.nextLine();\n\n        int n = s.length();\n        int m = t.length();\n\n        init(n,m);\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (s.charAt(i - 1) == t.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1];\n                else  dp[i][j] = min(dp[i - 1][j - 1],min(dp[i - 1][j], dp[i][j - 1])) + 1;\n            }\n        }\n\n        System.out.println(dp[n][m]);\n\n    }\n}\n```\n\n这道题目也比较简单，由于是包含关系，并不是相等关系，所以当 `S` 多余 `T` 是，不需要进行删除操作。\n\n所以这个题目不考虑删除的那个状态转移即可。\n\n**C++ 解题代码**\n\n```cpp\n#include<iostream>\n#include<algorithm>\n#include<set>\n#include<string>\n\nusing namespace std;\n#define INF 99999999\nstring s, t;\nint dp[1010][1010];\n\nvoid init(){\n    for (int i = 0; i <= s.size(); i++) dp[i][0] = 0;\n    for (int j = 1; j <= t.size(); j++) dp[0][j] = INF;\n}\n\nint main() {\n    cin >> s >> t;\n\n    init();\n\n    for (int i = 1; i <= s.size(); i++) {\n        for (int j = 1; j <= t.size(); j++) {\n            if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1];\n            else dp[i][j] = min(dp[i - 1][j - 1] + 1, dp[i - 1][j]);\n\n        }\n    }\n    cout << dp[s.size()][t.size()];\n    return 0;\n}\n```\n\n**Python 解题代码**\n\n```python\ndef init(s,t):\n\n    dp = [[0 for i in range(len(t) + 1)] for j in range(len(s) + 1)]\n    for i in range(len(s) + 1):\n        dp[i][0] = 0\n\n    for j in range(1,len(t) + 1):\n        dp[0][j] = 999999\n\n    return dp\n\nif __name__ == '__main__':\n    s = list(input())\n    t = list(input())\n\n    dp=init(s,t)\n\n    for i in range(len(s)):\n        for j in range(len(t)):\n            if s[i] == t[j]:\n                dp[i + 1][j + 1] = dp[i][j]\n            else:\n                dp[i + 1][j + 1] = min(dp[i][j] + 1, dp[i][j + 1])\n\n    print(dp[-1][-1])\n```\n\n**Java 解题代码**\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n    public static   int dp[][];\n\n    public static void init(int n,int m){\n\n        dp = new int[n+1][m+1];\n        for (int i = 0; i <= n; i++) dp[i][0] = 0;\n        for (int j = 1; j <= m; j++) dp[0][j] = 99999;\n    }\n\n    public static void main(String[] args) {\n\n        Scanner in = new Scanner(System.in);\n\n        String s = in.nextLine();\n        String t = in.nextLine();\n\n        int n = s.length();\n        int m = t.length();\n\n        init(n,m);\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (s.charAt(i - 1) == t.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1];\n                else dp[i][j] = Math.min(dp[i - 1][j - 1] + 1, dp[i - 1][j]);\n\n            }\n        }\n\n        System.out.println(dp[n][m]);\n\n    }\n}\n```\n\n## 实验总结 ##\n\n动态规划的学习是痛苦的，也是快乐，而且是非常重要的。\n\n希望大家努力克服，动态规划都学会了还有什么学不会呢。\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯冲刺营","10.动态规划"]},{"title":"贪心算法","url":"/2024/02/22/贪心算法/","content":"\n# 贪心算法 #\n\n贪心算法（Greedy algorithm），又称贪婪算法。是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而使得问题得到全局最优解。\n\n贪心的算法的设计就是要遵循某种规则，不断地选取当前最优解的算法设计方法。这节实验将会通过多个问题的来讲解贪心算法。\n\n#### 知识点 ####\n\n- 贪心算法的基本概念\n- 贪心算法的适用范围\n- 贪心算法的设计步骤\n- 贪心算法的题目讲解\n\n## 贪心算法基本概念 ##\n\n贪心算法与枚举法的不同之处在于每个子问题都选择最优的情况，然后向下继续进行，且不能回溯。枚举法是将所有情况都考虑然后选出最优的情况。\n\n贪心算法，在解决问题时，不从整体考虑，而是采用一种一眼看到局部最优解的选择方式。并且，贪心算法没有固定的模板可以遵循，每个题目都有不同的贪心策略，所以算法设计的关键在于贪心策略的选择。\n\n贪心算法有一个必须注意的事情。贪心算法对于问题的要求是，所有的选择必须是无后效性的，**即当前的选择不能影响后续选择对于结果的影响**。\n\n贪心算法主要适用于最优化问题，例如：最小生成树问题。有时候贪心算法并不能得到最优答案，但是能得到精确答案的近似结果。有时可以辅助其他算法得到不那么精确的结果。\n\n### 适用范围 ###\n\n**符合贪心策略：**\n\n所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。\n\n贪心选择性质就是指，该问题的每一步选择都在选择最优的情况下能够导致最终问题的答案也是最优。\n\n或者说是无后效性，如果该问题的每一步选择都对后续的选择没有影响，就可以应用贪心算法。\n\n### 贪心算法的设计步骤 ###\n\n按照定义设计：\n\n1. 证明原问题的最优解之一可以由贪心选择得到。\n2. 将最优化问题转化为这样一个问题，即先做出选择，再解决剩下的一个子问题。\n3. 对每一子问题一一求解，得到子问题的局部最优解；\n4. 将子问题的解局部最优解合成原问题的一个解。\n\n**伪代码：**\n\n关于 Question Q：\n\n```java\nwhile(Q.hasNextStep)\n{\n    Select(Q.nowBestSelect);\n    Q.NextStep\n}\n\nSelect(Q.nowBestSelect);\n```\n\n### 贪心相关题目讲解 ###\n\n我们在正式将题目前，聊一个大家都懂的常见的知识，也是一个常见的题目。\n\n#### 找零问题 ####\n\n题目如下：\n\n假设商店老板需要找零 �*n* 元钱。\n\n钱币的面额有：100100 元、5050 元、2020 元、55 元、11 元、如何找零使得所需钱币的数量最少？\n\n注意：�*n* 可能为 00，也能为几百元（别问，问就是来着里微信提现来了）\n\n**输入:**\n\n输入解法:\n\n在第一行给出测试例个数 �*N*。\n\n代表需要找零的钱数。\n\n输入样例：\n\n```txt\n365\n```\n\n**输出：**\n\n输出解法\n\n有 55 行输出数据，每一行输出数据输出找零的金额与数量，详情看样例。\n\n输出样例：\n\n```txt\n100:3\n50:1\n20:0\n5:3\n1:0\n```\n\n**运行限制:**\n\n```txt\n最大运行时间：1s\n最大运行内存：128M\n```\n\n**题目解析：**\n\n关于这个题，如果是正常人都知道从大的钱开始找钱。这就是一种贪心的思想，将大问题转化为一个个小的子问题，每次选择最大的钱数使得总量最小。\n\n其实再生活中贪心思想的例子还有很多，像是“自助餐“这种的都是贪心算法的印证。贪心算法其实离我们很近，掌握不会很困难的。\n\n我们先看一下上一道题目的代码题解是什么。\n\n**答案解析：**\n\nC++ 解法：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include<cstdio>\nusing namespace std;\n\n//面值\nint t[5]={100, 50, 20, 5, 1};\n\n//张数\nint m[5];\n\nvoid change(int n)\n{\n\n    for(int i=0;i<5;i++)\n    {\n        m[i]=n/t[i];\n\n        n=n%t[i];\n\n        //print(\"%d\",n);\n    }\n}\n\nint main()\n{\n    int N;\n\n    cin>>N;\n\n    change(N);\n\n    for(int i=0;i<5;i++)\n    {\n        printf(\"%d:%d\\n\",t[i],m[i]);\n    }\n}\n```\n\n**Python 解法**\n\n```python\nt = [100, 50, 20, 5, 1]\n\n# 钱的面值\n\ndef change(t, n):\n  # m是张数\n  m = [0 for _ in range(len(t))]\n  # print(m) #[0, 0, 0, 0]\n  for i, money in enumerate(t):\n      # print(i) #0 1 2 3\n      # print(money)\n      # i是当前的编号  举个例子 n是376 money是100\n      m[i] = n // money  # 商3\n      # n还剩多少取余\n      n = n % money  # 取余76 76不够100的\n      # print(m)\n      # print(n)\n  return m\n\n\nif __name__ == '__main__':\n  N = int(input())\n\n  m = change(t,N)\n\n  for i in range(len(m)):\n      print(t[i], end=':')\n\n      print(m[i])\n```\n\n**Java 解法**\n\n```java\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\nimport static java.lang.Integer.max;\n\npublic class Main {\n\n\n  //面值\n  static  int t[] = new int[]{100, 50, 20, 5, 1};\n\n  //张数\n  static int m[] = new int[5];\n\n  static void change(int n) {\n\n      for (int i = 0; i < 5; i++) {\n          m[i] = n / t[i];\n\n          n = n % t[i];\n\n          //print(\"%d\",n);\n      }\n\n  }\n\n  public static void main(String[] args) {\n\n      int N;\n\n      Scanner in = new Scanner(System.in);\n\n      N = in.nextInt();\n\n      change(N);\n\n      for (int i = 0; i < 5; i++) {\n          System.out.println(String.format(\"%d:%d\", t[i], m[i]));\n      }\n  }\n}\n```\n\n### 蓝桥大学的小 B 同学宿舍 ###\n\n**题目如下:**\n\n小 `B` 的宿舍楼沿着走廊南北向的两边各有 200200 个房间。\n\n如图所示：\n\n```txt\n[房间1][房间3][房间5][房间7][房间9 ]...[房间399]\n----------------------------------------------\n                   走廊\n----------------------------------------------\n[房间2][房间4][房间6][房间8][房间10]...[房间400]\n```\n\n最近，由于转专业和专业分流的原因，宿舍将迎来新的调整，以便组成新的班级后方便管理。\n\n但是由于走廊狭窄，走廊里只能通过一个搬运的物品（可以同向也可以反向），因此必须指定高效的搬运计划。\n\n老师给了每位同学下达了以下要求，让同学们体现收拾好行李，然后给每位同学 1010 分钟的时间搬运。\n\n当房间 �*i* 搬运行李到 �*j* 时，�*i* 与 �*j* 之间的走廊都会被占用。所以，1010 分钟之内同一段走廊最多11个人同时搬运，不重叠的走廊也可以同时搬运。\n\n小 �*B* 的老师是个数学老师，经过运筹学一通计算他得到了最优的搬运计划。\n\n虽然计划不唯一，但是最优值唯一，请问这个最短时间是多少？\n\n**输入:**\n\n输入解法:\n\n输入数据有 �*T* 组测试例，在第一行给出测试例个数 �*T*。\n\n每个测试例的第一行是一个整数 �*N*（1≤�≤2001≤*N*≤200)，表示要搬运行李的人数。接下来 �*N* 行，每行两个正整数 �*s* 和 �*t*，表示一个人，将行李是从房间号码 �*s* 移到到房间号码 �*t*。\n\n输入样例:\n\n```txt\n3\n4\n10 20\n30 40\n50 60\n70 80\n2\n1 3\n2 200\n3\n10 100\n20 80\n30 50\n```\n\n**输出：**\n\n输出解法\n\n每组输入都有一行输出数据，为一整数 �*T*，表示完成任务所花费的最小时间。\n\n输出样例:\n\n```txt\n10\n20\n30\n```\n\n**运行限制:**\n\n```txt\n最大运行时间：1s\n最大运行内存：128M\n```\n\n**题目解析：**\n\n不难发现，相对应的两个房间其实是占用一段走廊的，我们可以将将房间号映射为走廊号，然后再考虑上面的解析。\n\n该题属于贪心算法，因为它尽可能使搬运办公桌同时进行，以便使单独安排的搬运次数最少。这样用的时间最少，即所用最少时间为不能同时搬运桌子的次数，即某一段走廊使用次数最多（贪心标准）即为即为最少搬运时间。 **答案解析：**\n\nC++ 解法：\n\n```cpp\n#include <cstdio>\n#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int move[200];\n//搬运次数\n    int N;\n    int T;\n    cin>>T;\n    while(T--)\n    {\n        //每次搬运的起点和终点\n        int from, to;\n        int maxAns=0;\n\n        scanf(\"%d\", &N);\n        memset(move, 0, sizeof(move));\n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d%d\", &from, &to);\n//将房间号映射为走廊号\n            from = (from - 1)/2;\n            to = (to - 1)/2;\n//确保from<to，C++使用：swap(from, to)\n            if(from > to)\n            {\n                int temp = from;\n                from = to;\n                to = temp;\n            }\n//统计占用走廊情况，并统计最大值\n            for(int j = from; j <= to; j++)\n            {\n                move[j]++;\n                maxAns=max(maxAns,move[j]);\n            }\n        }\n        cout<<maxAns*10<<endl;\n    }\n}\n```\n\n**Python 解法**\n\n```python\nT = 0\n\nif __name__ == '__main__':\n\n    T = int(input())\n    while (T > 0):\n        # 搬运次数\n        N = 0\n        # 起点与终点\n        From = 0\n        To = 0\n        # 最大搬运次数\n        maxAns = 0\n        T -= 1\n        move = [0] * 205\n        N = int(input())\n        for i in range(N):\n\n            From, To = input().split()\n            From = int(From)\n            To = int(To)\n            From = int((From - 1) / 2)\n            To = int((To - 1) / 2)\n\n            if From > To:\n                temp = From\n                From = To\n                To = temp\n\n            for j in range(From, To + 1):\n                move[j] += 1\n                maxAns = max(move[j], maxAns)\n\n        print(maxAns*10)\n```\n\n**Java 解法**\n\n```java\nimport java.util.Scanner;\nimport static java.lang.Integer.max;\n\n\npublic class Main {\n\n\n  public static void main(String[] args) {\n      Scanner in = new Scanner(System.in);\n//搬运次数\n      int N;\n      int T;\n      T = in.nextInt();\n      while (T > 0) {\n          T--;\n\n          //每次搬运的起点和终点\n          int from, to;\n          int maxAns = 0;\n          N = in.nextInt();\n          int[] move = new int[205];\n\n          for (int i = 0; i < N; i++) {\n              from=in.nextInt();\n              to=in.nextInt();\n//将房间号映射为走廊号\n              from = (from - 1) / 2;\n              to = (to - 1) / 2;\n//确保from<to，C++使用：swap(from, to)\n              if (from > to) {\n                  int temp = from;\n                  from = to;\n                  to = temp;\n              }\n//统计占用走廊情况，并统计最大值\n              for (int j = from; j <= to; j++) {\n                  move[j]++;\n                  maxAns = max(maxAns, move[j]);\n              }\n          }\n          System.out.println( maxAns * 10);\n      }\n  }\n}\n```\n\n### 可拆分背包问题之贪心的自助餐 ###\n\n**题目如下:**\n\n小 �*B* 同学呢，想去吃自助餐，但是他是那种比较节俭的的人，既不想浪费食物，又想尽可能吃的贵一点，他于是私下里做了调查。\n\n小蓝餐厅的自助餐有 �*n* 种食材，每种食材都有它的价格。\n\n而且也能估计出每一份的重量，所以他列了一个表格。\n\n```txt\n红烧牛肉  30元    300g\n油闷大虾  8元     5g\n四喜丸子  4元     8g\n三文鱼    5元     3g\n排骨      18元    200g\n麻辣兔头  20元    120g\n高汤海参  40元    70g\n扇贝粉丝  8元     32g\n牛排      79元    240g\n...\n```\n\n现在小 �*B* 想知道在他到底最多吃多少钱的菜品。\n\n假设自助餐厅的菜品供应同样的菜品每个人只能取一份。\n\n小B的饭量假设为 �*C*，单位为 �*g*。\n\n现在请你设计一个程序帮助小 �*B* 计算他的最多吃了多少钱。\n\n**输入:**\n\n输入解法\n\n第一行输入 �,�（0<=�<=1000）（0<=�<=10000）*n*,*C*（0<=*n*<=1000）（0<=*C*<=10000）\n\n其中 �*n* 为菜品数量，�*C* 为小 �*B* 的肚子容量。\n\n第二行输入两个数 �，�*V*，*W*\n\n第一个数 �[�]*V*[*i*] 是第 �*i* 个菜品的价值（0<=�[�]<=10000）（0<=*v*[*i*]<=10000）\n\n第二个数 �[�]*V*[*i*] 是第 �*i* 个菜品的质量（0<=�[�]<=10000）（0<=*w*[*i*]<=10000）\n\n输入样例:\n\n```txt\n20 1000\n1 22\n2 43\n123 214\n12 2\n123 432\n21 223\n22 16\n77 49\n34 78\n34 9\n43 677\n21 34\n23 23\n12 56\n332 56\n21 99\n123 545\n389 33\n12 999\n23 88\n```\n\n**输出：**\n\n输出一行数据，表示最大的价值，保留三位小数。\n\n输出样例：\n\n```txt\n1204.114\n```\n\n**运行限制:**\n\n```txt\n最大运行时间：1s\n最大运行内存：128M\n```\n\n**题目解析：**\n\n可拆分背包的一般解法为：\n\n这里有 n 种不同值 �[�]*v*[*i*] 和权重 �[�]*w*[*i*] 的对象（如果选择该对象的 �[�]*w*[*i*] 可以获得值 �[�]*v*[*i*]）。\n\n你有一个容器来挑选它们。你可以根据自己的需要把它们分成任意大小的碎片。可以拾取的对象的最大重量给定为 �*w*。请计算您能得到的最大值。\n\n就像是这个题目，要想吃回本就要捡着贵的吃，但是贵只是一方面，人会饱，所以用价格除以质量所获的价格商才是贪心准则，应按照价格商优先进行选取。\n\n于是这个题，就要用的我们之前学的知识了。这里因为要整体排序，所以要先创建一个类，然后自定义 `cmp` 函数，在使用 `sort` 排序。\n\n**答案解析：**\n\nC++ 解法：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include<iomanip>\nusing namespace std;\n\n//需要一个结构体，通过性价比，能够查找到重量和价值。\n\n//做一个排序，需要将性价比由高到底排序，排序的过程中重量和（价值）要对应上\n\nstruct Food\n{\n    double w;\n    double v;\n    double aver;\n\n};\n//C++一般用 struct，因为默认都是public的\n\nbool cmp(Food a, Food b)\n{\n    return a.aver > b.aver;\n    //助记大于号就是从大到小排序，小于号就是从小到大排序\n}\n\n\nint main()\n{\n    Food foods[1009];\n    int n;\n    double C;\n    double Value = 0;\n    cin >> n >> C;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> foods[i].v>>foods[i].w;\n        //求性价比\n        foods[i].aver = foods[i].v / foods[i].w;\n        //cout << foods[i].aver << endl;\n\n    }\n\n\n    //性价比排序\n    sort(foods, foods + n, cmp);\n\n    //当背包（肚子）能装下所有物品（菜）时，直接输出所有的物品（菜品）价值之和\n    //\n    int sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n        sum += foods[i].w;\n    }\n    if (sum <= C)\n    {\n        for (int j = 0; j < n; j++)\n            Value += foods[j].v;\n        //V = floor(V * 1000.0) / 1000.0;\n        cout << setiosflags(ios::fixed) << setprecision(3) <<Value << endl;\n        return 0;\n    }\n\n    //当背包（肚子）不能装下所有物品时应该由性价比的顺序，选择装入的物品\n\n    for (int i = 0; i < n; i++)\n    {\n        if (foods[i].w <= C)\n        {\n            Value =Value + foods[i].v;\n            C = C - foods[i].w;\n        }\n        else\n        {\n            //直接将剩余的C加入即可\n            Value =Value + C * foods[i].aver;\n            C = 0;\n        }\n        if (C == 0)\n            break;\n    }\n    //V = floor(V * 1000.0) / 1000.0;\n    cout << setiosflags(ios::fixed) << setprecision(3) <<Value << endl;\n    return 0;\n}\n```\n\n**Python 解法**\n\n```python\nclass Food:\n\n   def __init__(self, w, v, aver):\n       self.w = w\n       self.v = v\n       self.aver = aver\n\n   def __repr__(self):\n       # print(11)\n       return repr((self.w, self.v, self.aver))\n\n# def cmp(foodA: Food, foodB: Food):\n#     if foodA.aver >= foodB.aver:\n#         return True\n#\n#     else:\n#         return False\n#\n#\n# 当然 python 的 sort 是不需要写 cmp 函数的，这里我们使用 sorted 就不用 cmp 函数了\n\nif __name__ == '__main__':\n\n   foods = []\n   C = 0.0\n   Value = 0.0\n   n, C = map(int, input().split())\n   for i in range(n):\n       food = Food(0, 0, 0)\n       food.v, food.w = map(int, input().split())\n       food.aver = food.v / food.w\n       foods.append(food)\n       # print(food.aver)\n       # print(foods)\n   # 性价比排序\n   foods.sort(key=lambda f: f.aver, reverse=True)\n   # for i in range(n):\n   #     print(foods[i].aver)\n   sum=0\n   for i in range(n):\n       sum+= foods[i].w\n   # 当背包（肚子）能装下所有物品（菜）时，直接输出所有的物品（菜品）价值之和\n   if sum<=C :\n       for i in range(n):\n           Value+=foods[i].v;\n       print(Value)\n   # 当背包（肚子）不能装下所有物品时应该由性价比的顺序，选择装入的物品\n   else:\n       for i in range(n):\n\n           if foods[i].w<=C:\n               Value=Value+foods[i].v\n               C=C-foods[i].w\n           #     直接将剩余的C加入即可\n           else:\n               Value+=C*foods[i].aver\n               C=0\n\n           if C==0:\n               break\n\n       print(\"%.3f\" % Value)\n```\n\n**Java 解法**\n\n```java\npackage com.company;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\nimport static java.lang.Integer.max;\n\npublic class Main {\n\n   static class Food {\n\n       public double w;\n       public double v;\n       public double aver;\n\n       Food(){\n           w=0;\n           v=0;\n           aver=0;\n       }\n   }\n\n   static class MyCmp implements Comparator<Food> {\n\n       @Override\n       public int compare(Food a, Food b) {\n\n           if (a.aver > b.aver){\n               return  -1;\n           }\n           else return 1;\n\n           //助记大于号就是从大到小排序，小于号就是从小到大排序\n\n       }\n   }\n   static Food foods[]=new Food[ 1009];\n   public static void main(String[] args) {\n\n       Scanner in = new Scanner(System.in);\n\n       int n;\n       double C;\n       double Value = 0;\n       n = in.nextInt();\n       C = in.nextDouble();\n       for (int i = 0; i < n; i++) {\n           foods[i]=new Food();\n           foods[i].v = in.nextDouble();\n           foods[i].w = in.nextDouble();\n\n           //求性价比\n           foods[i].aver = foods[i].v / foods[i].w;\n           //cout << foods[i].aver << endl;\n\n       }\n\n       //性价比排序\n\n       Comparator cmp=new MyCmp();\n       Arrays.sort(foods,0,n,cmp);\n\n\n       //当背包（肚子）能装下所有物品（菜）时，直接输出所有的物品（菜品）价值之和\n       //\n       int sum = 0;\n       for (int i = 0; i < n; i++) {\n           sum += foods[i].w;\n       }\n       if (sum < C) {\n           for (int j = 0; j < n; j++)\n               Value += foods[j].v;\n           //V = floor(V * 1000.0) / 1000.0;\n           System.out.print(String.format(\"%.3f\",Value));\n           return ;\n       }\n\n       //当背包（肚子）不能装下所有物品时应该由性价比的顺序，选择装入的物品\n\n       for (int i = 0; i < n; i++) {\n           if (foods[i].w <= C) {\n               Value = Value + foods[i].v;\n               C = C - foods[i].w;\n           } else {\n               //直接将剩余的C加入即可\n               Value = Value + C * foods[i].aver;\n               C = 0;\n           }\n           if (C == 0)\n               break;\n       }\n       //V = floor(V * 1000.0) / 1000.0;\n       System.out.print(String.format(\"%.3f\",Value));\n       return ;\n   }\n}\n```\n\n#### 实验总结 ####\n\n贪心算法的最主要的特征就是无后效性，就像是自助餐那个题目，如果说吃了某一样食物，就不能吃另一个食物了，那么这就有了后效性，那就不能使用贪心算法进行解决问题了。\n\n本节课举了三个贪心算法的例子进行讲解，贪心算法是算法竞赛中最入门的算法。没接触过感觉很深奥，接触过了也就那样，简单的贪心伸伸手就可以写出来，其实非常简单，大家也不要过分的担心\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯冲刺营","9.贪心算法"]},{"title":"工具函数模板","url":"/2024/02/22/工具函数模板/","content":"\n# 内置模板 #\n\n我们前面讲了很多数据结构相关的知识，本节课程，我们主要讲解怎么不自己定义，而是使用我们所使用的编程语言中，已经定义好的数据结构。\n\n之前我们在栈那一节已经讲过栈的内置数据结构的使用，我们本章就不再进行讲解，我们这节课仍然采用那种方式进行讲解。\n\n#### 知识点 ####\n\n- 迭代器讲解\n- 线性表的使用\n- 队列的使用\n- 集合（set）的使用\n- 映射（map）的使用\n\n### 迭代器（Iterator） ###\n\n首先，明确一点迭代器是 `C++` 的知识，并不适用于 `Java` 和 `Python` 这两种语言，但是下面讲容器就要用到这一点，所以我们必须要提前讲一下。迭代器的知识点很复杂，了解即可，当然有余力可以深究，了解就能做题，实现方式看容器讲解。\n\n对于数组我们可以采用指针进行访问，但是对于其他的存储空间连续的数据结构或者说是存储单元我们就需要找到另一种方式来替代指针的行为作用，从而达到对于非数组的数据结构的访问和遍历，于是我们定义了一种新的变量叫做迭代器。\n\n**定义：**\n\n迭代器是一种检查容器内元素并遍历元素的数据类型。\n\n迭代器提供对一个容器中的对象的访问方法，并且定义了容器中对象的范围。\n\n**迭代器和指针的区别：**\n\n容器和`string`有迭代器类型同时拥有返回迭代器的成员。\n\n如：容器有成员 `.begin()` 和 `.end()`，其中 `.begin()` 成员复制返回指向第一个元素的迭代器，即指向第一个元素的“地址”，而 `.end()` 成员返回指向容器尾元素的下一个位置的迭代器。\n\n即 `.begin()` 指向的是第一个合法元素的位置，`.end()` 指向是容器后第一个不合法元素的地址。\n\n相应的还有容器反向迭代器成员 `.rbegin()` `.rend()`，`.rbegin()` 返回容器的元素前最后一个不合法的地址，`rend()` 返回容器的最后一个合法地址。\n\n#### 容器迭代器的使用 ####\n\n每种容器类型都定义了自己的迭代器类型：\n\n```txt\n如 vector：vector<int>::iterator iter;//定义一个名为iter的变量\n```\n\n数据类型是由 `vector<int>` 定义的 `iterator` 类型。简单说就是容器类定义了自己的 `iterator` 类型，用于访问容器内的元素。每个容器定义了一种名为 `iterator` 的类型，这种类型支持迭代器的各种行为。\n\n我么们先讲一下各种迭代器的类型，在讲容器所用的迭代器类型，就可以明白怎么操作。\n\n## 容器 ##\n\n写在前面，由于 `Python` 的语言的特点，所有的数据结构大部分都需要自己实现，但是其 `List` 功能较强，用起来比较简单，当然我们也会再说一遍怎么实现。\n\n在 `Java` 中各种数据结构都是继承于 `list`，所以 `Java` 的 `list` 功能也很强，它的功能有很多，由于篇幅原因我们会挑比较重要的讲解，其他的还需要同学们多去使用。\n\n### Vector 容器（类） ###\n\n线性表中有 `Vector` 和 `list`，两者作用比较相似。\n\n`Vector` 的主要作用就是可变长度的数组，就把他当成数组使用即可。\n\n至于为什么我们选择讲 `Vector` 而不是 `List`，因为 `Vector` 可以当作数组使用，用起来非常简单，也非常方便。\n\n我们先讲解一下 C++ 的 `Vector` 使用：\n\n```cpp\n#include <vector>   //头文件\nvector<int> a;      //定义了一个int类型的vector容器a\nvector<int> b[100]; //定义了一个int类型的vector容器b组\nstruct rec\n{\n    ···\n};\nvector<rec> c;            //定义了一个rec类型的vector容器c\nvector<int>::iterator it; //vector的迭代器，与指针类似\n```\n\n具体操作如下：\n\n```cpp\na.size()           //返回实际长度（元素个数），O(1)复杂度\na.empty()      //容器为空返回1，否则返回0，O(1)复杂度\na.clear()      //把vector清空\na.begin()      //返回指向第一个元素的迭代器，*a.begin()与a[0]作用相同\na.end()        //越界访问，指向vector尾部，指向第n个元素再往后的边界\na.front()      //返回第一个元素的值，等价于*a.begin和a[0]\na.back()       //返回最后一个元素的值，等价于*--a.end()和a[size()-1]\na.push_back(x) //把元素x插入vector尾部\na.pop_back()   //删除vector中最后一个元素\n```\n\n遍历的方式有两种：\n\n1. 迭代器使用与指针类似，可如下遍历整个容器。\n\n```cpp\n for ( vector<int>::iterator it=a.begin() ; it!=a.end() ; it++ )\n cout<<*iterator<<endl;\n```\n\n1. 当成数组使用。\n\n```c\nfor( int i=0;i<a.size();i++) cout<<a[i]<<endl;\n```\n\nJava 中我们一般使用 List，相信大家已经非常熟悉了，我们这里给大家补充一下 Vector 的用法，与 List 的使用方式非常的类似。\n\n```java\n//第一种构造方法创建一个默认的向量，默认大小为 10：\nVector()\n//第二种构造方法创建指定大小的向量。\nVector(int size)\n//第三种构造方法创建指定大小的向量，并且增量用 incr 指定。增量表示向量每次增加的元素数目。\nVector(int size,int incr)\n//第四种构造方法创建一个包含集合 c 元素的向量：\nVector(Collection c)\n```\n\n以下为 `Java Vector` 的 `Api`。\n\n| **修饰符和类型** | **方法和说明**                                               |\n| ---------------- | ------------------------------------------------------------ |\n| boolean          | add(E e)将指定的元素附加到此 Vector 的末尾。                 |\n| void             | add(int index, E element)在此 Vector 的指定位置插入指定元素。 |\n| boolean          | addAll(Collection<? extends E> c)将指定集合中的所有元素追加到末尾 这个向量，按照它们由指定的返回的顺序 集合的迭代器。 |\n| boolean          | addAll(int index, Collection<? extends E> c)将指定 Collection 中的所有元素插入到此 指定位置的向量。 |\n| void             | addElement(E obj)将指定的组件添加到此向量的末尾， 将其大小增加一。 |\n| int              | capacity()返回此向量的当前容量。                             |\n| void             | clear()从此 Vector 中删除所有元素。                          |\n| Object           | clone()返回此向量的克隆。                                    |\n| boolean          | contains(Object o)退货 true 如果此向量包含指定的元素。       |\n| boolean          | containsAll(Collection<?> c)如果此 Vector 包含所有元素，则返回 true 指定的集合。 |\n| void             | copyInto ������*O**b**j**e**c**t* [ ] �������*a**n**A**r**r**a**y*将此向量的分量复制到指定的数组中。 |\n| E                | elementAt(int index)返回指定索引处的组件。                   |\n| Enumeration      | elements()返回此向量的组件的枚举。                           |\n| void             | ensureCapacity(int minCapacity)如有必要，增加此向量的容量，以确保它至少可以容纳由指定的组件数量最小容量参数。 |\n| boolean          | equals(Object o)比较指定的 Object 与此 Vector 是否相等。     |\n| E                | firstElement()返回第一个组件（索引处的项目 0） 的这个向量。  |\n| E                | get(int index)返回此 Vector 中指定位置的元素。               |\n| int              | hashCode()返回此 Vector 的哈希码值。                         |\n| int              | indexOf(Object o)返回指定元素第一次出现的索引 在此向量中，如果此向量不包含该元素，则为 -1。 |\n| int              | indexOf(Object o,int index)返回指定元素第一次出现的索引这个向量，从 index, 或返回 -1 如果 未找到该元素。 |\n| void             | insertElementAt(E obj, int index)将指定对象作为组件插入此向量中的 指定的 index. |\n| boolean          | isEmpty()测试此向量是否没有组件。                            |\n| Iterator         | iterator()以适当的顺序返回此列表中元素的迭代器               |\n| E                | lastElement()返回向量的最后一个组件。                        |\n| int              | lastIndexOf(Object o)返回指定元素最后一次出现的索引在此向量中，如果此向量不包含该元素，则为 -1。 |\n| int              | lastIndexOf(Object o, int index)返回指定元素最后一次出现的索引这个向量，从 index, 或返回 -1 如果 未找到该元素。 |\n| ListIterator     | listIterator()返回此列表中元素的列表迭代器（在适当的顺序）。 |\n| ListIterator     | listIterator(int index)返回此列表中元素的列表迭代器（在适当的序列），从列表中的指定位置开始。 |\n| E                | remove(int index)移除此 Vector 中指定位置的元素。            |\n| boolean          | remove(Object o)移除此 Vector 中第一次出现的指定元素如果 Vector 不包含该元素，则它保持不变。 |\n| boolean          | removeAll(Collection<?> c)从此 Vector 中删除其包含在指定的集合。 |\n| void             | removeAllElements()从此向量中删除所有组件并将其大小设置为零。 |\n| boolean          | removeElement(Object obj)删除参数的第一个（最低索引）出现从这个向量。 |\n| void             | removeElementAt(int index)删除指定索引处的组件。             |\n| protected void   | removeRange(int fromIndex, int toIndex)从此列表中删除索引介于两者之间的所有元素 fromIndex，包括在内，和 toIndex， 独家的。 |\n| boolean          | retainAll(Collection<?> c)仅保留此 Vector 中包含在指定的集合。 |\n| E                | set(int index, E element)将此 Vector 中指定位置的元素替换为指定的元素。 |\n| void             | setElementAt(E obj,int index)将组件设置在指定的位置 index 这个的向量是指定的对象。 |\n| void             | setSize(int newSize)设置此向量的大小。                       |\n| int              | size()返回此向量中的组件数。                                 |\n| List             | subList(int fromIndex,int toIndex)返回此列表中 fromIndex 之间的部分的视图 |\n| Object[]         | toArray()返回一个包含此 Vector 中所有元素的数组以正确的顺序。 |\n| T[]              | ������� �*t**o**A**r**r**a**y* *T*[] 返回一个包含此 Vector 中所有元素的数组正确的顺序; 返回数组的运行时类型指定数组。 |\n| String           | toString()返回此 Vector 的字符串表示形式，包含 每个元素的字符串表示。 |\n| void             | trimToSize()将此向量的容量修剪为向量的电流 尺寸。            |\n\n遍历 Vector\n\n```java\nEnumeration vEnum = v.elements();\nwhile (vEnum.hasMoreElements())\n    System.out.print(vEnum.nextElement() + \" \");\n```\n\n**Python 中，我们直接使用 list 即可来实现。**\n\n## 题目解析 ##\n\n快递员需要对快递进行分拣，现在小李是一名快递员，他想要你帮他设计一个程序用于快递的分拣，按城市分开。\n\n现在有以下输入：\n\n```txt\n单号 省份\n\n请你将单号按照城市分开，并输出。\n\n城市按照输入顺序排序\n\n单号按照输入顺序排序\n```\n\n样例如下：\n\n```txt\n输入\n\n10\n\n10124214 北京\n12421565  上海\nsdafasdg213 天津\nfasdfga124 北京\n145252  上海\n235wtdfsg 济南\n3242356fgdfsg 成都\n23423 武汉\n23423565f 沈阳\n1245dfwfs 成都\n\n输出\n\n北京 2\n10124214\nfasdfga124\n上海 2\n12421565\n145252\n天津 1\nsdafasdg213\n济南 1\n235wtdfsg\n成都 2\n3242356fgdfsg\n1245dfwfs\n武汉 1\n23423\n沈阳 1\n23423565f\n```\n\n下面我们来分析一下解题思路。\n\n首先我们要知道中国城市肯定在 10001000 个以内，但是单号我们不确定，我们不可能每个数组开 1000010000 个，那样内存不够，所以这时候我们就用到了我们的 ������*v**e**c**t**o**r*，他的容量是动态申请的，在比赛中我们可以理解为无限制。\n\n- 第一步：我们创建一个 ������*v**e**c**t**o**r* 用于保存地址\n\n```cpp\nvector<string> city;\n```\n\n- 第二步：我们创建一个 ������*v**e**c**t**o**r* 组用于存放单号\n\n```cpp\nvector<string> dig[1000];\n```\n\n- 第三步：我们定义一个映射函数，因为你的城市可能会再次出现，你需要知道之前有没有。\n- 第四步：我们开始读入操作并按照顺序进行存放\n\n#### 完整代码 ####\n\nC++ 解题代码：\n\n```cpp\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nvector<string> city;\nvector<string> dig[1000];\n\nint Myfind(string s)\n{\n    for(int i=0;i<city.size();i++)\n    {\n        if(city[i]==s) return i;\n    }\n    return -1;\n}\nint main()\n{\n\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++)\n    {\n        string d,c;\n        cin>>d>>c;\n        int flag=Myfind(c);\n        if(flag==-1){\n            city.push_back(c);\n            dig[city.size()-1].push_back(d);\n        }\n        else  dig[flag].push_back(d);\n    }\n    for(int i=0;i<city.size();i++)\n    {\n        cout<<city[i]<<\" \"<<dig[i].size()<<endl;\n        for(int j=0;j<dig[i].size();j++)\n            cout<<dig[i][j]<<endl;\n    }\n}\n```\n\n**Java 解题代码**\n\n```java\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Vector;\n\npublic class Main {\n\n  static Vector city=new Vector<String>();\n  static Vector <Vector<String>> dig= new Vector <Vector<String>>();\n  static int Myfind(String s)\n  {\n      for(int i=0;i<city.size();i++)\n      {\n          if(city.get(i).equals(s)) {\n              return i;\n          }\n      }\n      return -1;\n  }\n\n  public static void main(String[] args) {\n      int n;\n      Scanner in=new Scanner(System.in);\n      n=in.nextInt();\n      for(int i=0;i<n;i++)\n      {\n          String d,c;\n          d=in.next();\n          c=in.next();\n          int flag=Myfind(c);\n          if(flag==-1){\n              city.addElement(c);\n              dig.addElement(new Vector<String>());\n              dig.get(city.size()-1).addElement(d);\n\n          }\n          else   dig.get(flag).addElement(d);\n      }\n      for(int i=0;i<city.size();i++)\n      {\n          System.out.println(city.get(i)+\" \"+dig.get(i).size());\n          for(int j = 0; j< dig.get(i).size(); j++)\n              System.out.println(dig.get(i).get(j));\n      }\n  }\n\n\n}\n```\n\n**Python 实现方式:**\n\n```python\ncity=[]\ndig = [[] for i in range(1000)]\ndef find(s):\n   for i in range(0,len(city)):\n       if (city[i]==s):\n           return i\n   return -1\n\nif __name__ == '__main__':\n   n=int (input())\n   for i in range(0,n):\n       d=input().split()\n       #print(d[1]        )\n       flag=find(d[1])\n       if(flag==-1):\n           city.append(d[1])\n           dig[len(city)-1].append(d[0])\n       else:\n           dig[flag].append(d[0])\n\n   for i in range(0,len(city)):\n       print(city[i],len(dig[i]))\n       for j in range(0,len(dig[i])):\n           print(dig[i][j])\n```\n\n### 队列 Queue ###\n\n队列的讲解在之前的课程中已经讲过了，忘记的快回去复习。\n\n我们直接开始看操作吧。\n\n#### C++ 中的队列 ####\n\n定义方式：在 C++ 里所有容器的定义方式基本一致。\n\n```c++\nqueue<string> myqueue;\nqueue<int> myqueue_int;\n```\n\n成员函数:\n\n- `front()`：返回 `queue` 中第一个元素的引用。\n- `back()`：返回 `queue `中最后一个元素的引用。\n- `push(const T& obj)`：在 `queue` 的尾部添加一个元素的副本。\n- `pop()`：删除 `queue` 中的第一个元素。\n- `size()`：返回 `queue` 中元素的个数。\n- `empty()`：如果 `queue` 中没有元素的话，返回 true。\n\n**Java 中的队列:**\n\n定义方式：\n\n```java\nQueue<String> queue = new LinkedList<String>();\n```\n\n部分成员函数（包括继承的）：\n\n- `add()`: 增加一个元索,如果队列已满，则抛出一个异常\n- `remove()`:移除并返回队列头部的元素，如果队列为空，则抛出一个异常\n- `element()`:返回队列头部的元素，如果队列为空，则抛出一个异常\n- `offer()`:添加一个元素并返回 `true`，如果队列已满，则返回 `false`\n- `poll()`: 移除并返问队列头部的元素，如果队列为空，则返回 `null`\n- `peek()`: 返回队列头部的元素，如果队列为空，则返回 `null`\n- `put()`: 添加一个元素， 如果队列满，则阻塞\n- `take()`: 移除并返回队列头部的元素，如果队列为空，则阻塞\n- `size()`: 返回队列长度。\n\n**Python 中的队列**\n\n定义方式：\n\n```python\nfrom queue import Queue\n\n## maxsize设置队列中，数据上限，小于或等于0则不限制，容器中大于这个数则阻塞，直到队列中的数据被消掉\nq = Queue(maxsize=0)\n```\n\n成员函数：\n\n- `Queue.qsize()` 返回队列的大致大小。\n- `Queue.empty()` 如果队列为空，返回 `True` 否则返回 `False`\n- `Queue.full()` 如果队列是满的返回 `True` ，否则返回 `False`\n- `Queue.put(item, block=True, timeout=None)`\n  - 常用时忽略默认参数，即使用 `Queue.put(item)`。\n  - 将 `item` 放入队列，如果可选参数 `block` 是 `true` 并且 `timeout` 是 `None` (默认)，则在必要时阻塞至有空闲插槽可用。\n  - 如果 `timeout` 是个正数，将最多阻塞 `timeout` 秒，如果在这段时间没有可用的空闲插槽，将引发 `Full` 异常。\n  - 反之 (`block` 是 `false`)，如果空闲插槽立即可用，则把 `item` 放入队列，否则引发 `Full` 异常 ( 在这种情况下，`timeout` 将被忽略)。\n- `Queue.get(block=True, timeout=None)`\n  - 常用时忽略默认参数，即使用 `Queue.get()`。\n  - 从队列中移除并返回一个项目。如果可选参数 `block` 是 `true` 并且 `timeout` 是 `None` (默认值)，则在必要时阻塞至项目可得到。\n  - 如果 `timeout` 是个正数，将最多阻塞 `timeout` 秒，如果在这段时间内项目不能得到，将引发 `Empty` 异常。反之 (`block` 是 `false`)，如果一个项目立即可得到，则返回一个项目，否则引发 `Empty` 异常 (这种情况下，`timeout` 将被忽略)。\n\n#### 题目回顾 ####\n\n> CLZ 的银行。\n\n```txt\n第一行 M 次操作（M<1000）\n\n第二行 到 第M+1行 输入操作\n\n格式：   IN name V\n        OUT V\n        IN name2 N\n        OUT N\n        即 第一个字符串为操作 是IN进入排队和OUT 出队\n            IN 排队 跟着两个字符串为姓名和权限V或N\n            OUT 为出队即完成操作，V和N代表那个窗口完成了操作\n\n输出：M次操作后V队列和N队列中姓名，先输出V队列后输出N队列。\n\n样例：\n\n输入：\n\n5\nIN xiaoming N\nIN Adel V\nIN laozhao N\nOUT N\nIN CLZ V\n\n输出：\n\nAdel\nCLZ\nlaozhao\n```\n\n具体的题目讲解，我们之前就已经讲解过了，这里我们主要是来看一下预置代码的方便性。\n\n#### 完整代码 ####\n\nC++实现：\n\n```cpp\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nqueue<string> V;\nqueue<string> N;\n\nint main()\n{\n    int M;\n    cin>>M;\n\n    while(M--) //\n    {\n        string op,name,type;\n        cin>>op;\n        if(op==\"IN\")\n        {\n            cin>>name>>type;\n\n            if(type==\"V\")\n                V.push(name);\n\n            else\n                N.push(name);\n        }\n        else\n        {\n            cin>>type;\n\n            if(type==\"V\")\n                V.pop();\n            else\n                N.pop();\n\n        }\n    }\n\n    while(V.size())\n    {\n        cout<<V.front()<<endl;\n        V.pop();\n    }\n    while(N.size())\n    {\n        cout<<N.front()<<endl;\n        N.pop();\n    }\n}\n```\n\n**Java 实现**\n\n```java\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n    static Queue<String> V=new LinkedList<String>();\n\n    static Queue<String> N=new LinkedList<String>();\n\n    public static void main(String[] args) {\n\n        int M;\n        Scanner in=new Scanner(System.in);\n        M=in.nextInt();\n        while(M>0) //\n        {\n            M--;\n            String op,name,type;\n            op=in.next();\n            // System.out.println(\"op\"+op);\n            if(op.contains(\"IN\"))\n            {\n                name=in.next();\n                type=in.next();\n                if(type.contains(\"V\")) {\n                    V.offer(name);\n                }\n                else {\n                    N.offer(name);\n                }\n                // System.out.println(\"name:\"+name+\"type:\"+type);\n\n                // System.out.println(Vqueue);\n            }\n            else\n            {\n                type=in.next();\n                if(type.contains(\"V\")){\n                    V.poll();\n                }\n                else {\n                    N.poll();\n                }\n                // System.out.println(\"type\"+type);\n            }\n        }\n\n        while(V.size()!=0)\n        {\n            System.out.println(V.poll());\n        }\n        while(N.size()!=0)\n        {\n            System.out.println(N.poll());\n        }\n    }\n\n}\n```\n\n**Python 实现**\n\n```python\nimport queue\n\nV = queue.Queue()\nN = queue.Queue()\n\nif __name__ == '__main__':\n\n  M = 0\n  M = int(input())\n  while M > 0:\n      M -= 1\n      op = input().split()\n\n      # print(op[0])\n\n      if op[0] == 'IN':\n          if op[2] == \"V\":\n              V.put(op[1])\n          else:\n              N.put(op[1])\n      else:\n          if op[1] == \"V\":\n              V.get()\n          else:\n              N.get()\n          # print('out')\n      # print(\"VVVVV\",Vqueue)\n      # print(\"NNNN\",Nqueue)\n      # print(M)\n\n\n  while not (V.empty()):\n      print(V.get())\n\n  while not (N.empty()):\n      print(N.get())\n```\n\n### Map 映射 ###\n\n在之前我们学习散列表的时候我们就接触过了映射，这里我们要讲的是一种类似的数据结构。\n\n`map` 是一个关联容器，它提供一对一的 `hash`。\n\n- 第一个可以称为关键字(`key`)，每个关键字只能在 `map` 中出现一次\n- 第二个可能称为该关键字的值(`value`)\n\n`map` 以模板（泛型）方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。`Map` 主要用于资料一对一映射（`one-to-one`）的情況，`map` 在 `C++` 的內部的实现自建一颗红黑树，这颗树具有对数据自动排序的功能。在 `map` 内部所有的数据都是有序的。\n\n比如，像是管理班级内的学生，`Key` 值为学号，`Value` 放其他信息的结构体或者类。\n\n#### C++ 中的 map ####\n\n定义方式：\n\n```cpp\nmap<char, int> mymap1;\nmap<string, int> mymap2;\n```\n\n一般用法：\n\n1. 看容量。\n\n```cpp\nint map.size();//查询map中有多少对元素\nbool empty();// 查询map是否为空\n```\n\n1. 插入。\n\n```c\n    map.insert(make_pair(key,value));\n    //或者\n    map.insert(pair<char, int>(key, value))\n    //或者\n    map[key]=value\n```\n\n1. 取值。\n\n```cpp\nmap<int, string> map;\n\n//如果map中没有关键字2233，使用[]取值会导致插入\n//因此，下面语句不会报错，但会使得输出结果结果为空\ncout<<map[2233]<<endl;\n\n//但是使用使用at会进行关键字检查，因此下面语句会报错\nmap.at(2016) = \"Bob\";\n```\n\n1. 遍历操作\n\n```cpp\nmap<string, string>::iterator it;\nfor (it = mapSet.begin(); it != mapSet.end(); ++it)\n{\n    cout << \"key\" << it->first << endl;\n    cout << \"value\" << it->second << endl;\n}\n```\n\n1. 查找操作\n\n```cpp\nm.count(key)：//由于map不包含重复的key，因此m.count(key)取值为0，或者1，表示是否包含。\nm.find(key)：//返回迭代器，判断是否存在。\n```\n\n**Java 中的 map**\n\n定义方法：\n\n```java\nMap m1 = new TreeMap();\n```\n\n这里我们讲的是排序的 `map` 还有不排序的 `map`，`java` 里面叫 `hashmap`，`C++` 里叫 `unordered_map`，除了不排序，用法和功能都一样。\n\n二者相差无几，大家如果不需要排序可以直接使用。\n\n成员方法\n\n| 方法名                          | 方法描述                                                     |\n| ------------------------------- | ------------------------------------------------------------ |\n| void clear( )                   | 从此映射中移除所有映射关系（可选操作）。                     |\n| boolean containsKey(Object k)   | 如果此映射包含指定键的映射关系，则返回 true。                |\n| boolean containsValue(Object v) | 如果此映射将一个或多个键映射到指定值，则返回 true。          |\n| boolean equals(Object obj)      | 比较指定的对象与此映射是否相等。                             |\n| Object get(Object k)            | 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。 |\n| int hashCode( )                 | 返回此映射的哈希码值。                                       |\n| boolean isEmpty( )              | 如果此映射未包含键-值映射关系，则返回 true。                 |\n| Set keySet( )                   | 返回此映射中包含的键的 Set 视图。                            |\n| Object put(Object k, Object v)  | 将指定的值与此映射中的指定键关联                             |\n| Object remove(Object k)         | 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。 |\n| int size( )                     | 返回此映射中的键-值映射关系数。                              |\n| Collection values( )            | 返回此映射中包含的值的 Collection 视图。                     |\n\n**Python 字典**\n\n在 `Python` 中我们不叫映射，也不叫 `map`，我们称作字典。用法跟 `Java` 和 `c++` 都是有一定区别的。\n\n1. 字典的创建。\n\n```python\nmassege={'小李':'123124543643','xiaohua':'17855666','LiMing':'1249699859456'}\n\n#或者创建空的字典\nempty_dict = {}\n#或者使用元组作为key\ngroup_dict = {(60, 99):'good', 100:'nice'}\n```\n\n1. 字典的添加。\n\n```python\n# 如果字典内不含有相应的Key值，则会执行添加操作\ndict[key]=value\n```\n\n1. 字典的修改。\n\n```python\n# 如果字典内含有相应的Key值，则会执行更新操作\ndict[key]=new_value\n\n# 使用update()修改\n# update() 方法可使用一个字典所包含的 key-value 对来更新己有的字典。如果有就修改，没有就添加。\ndict.update({'key':123,'key2':234})\n```\n\n1. 字典的删除。\n\n```python\ndel dict['key']  # 删除键是'key'的条目\ndict.clear()      # 清空字典所有条目\ndel dict          # 删除字典\n```\n\n1. 字典的访问。\n\n```python\ndict = {'Name': 'Zara', 'Age': '7'}\nprint (dict['Name'])\n\n#当然如果key值不存在，将会抛出异常\n#也可以是用get()方法,不存在会返回None，但不会抛出异常\nprint(dict.get('Name'))\n```\n\n### 题目演练 ###\n\n> 《弗里石的的语言》\n>\n> 小发明家弗里想创造一种新的语言，众所周知，发明一门语言是非常困难的，首先你就要克服一个困难就是，有大量的单词需要处理，现在弗里求助你帮他写一款程序，判断是否出现重复的两个单词。\n>\n> 有重复就输出重复单词，重复就输出 `NO`，多个重复输出最先出现的哪一个。\n\n输入：\n\n第 11 行，输入 �*N*，代表共计创造了多少个单词 第 22 行至第 �+1*N*+1 行，输入 �*N* 个单词\n\n格式：\n\n```txt\nfjsdfgdfsg\nfdfsgsdfg\nbcvxbxfyres\n```\n\n现在有以下样例输入：\n\n样例 1\n\n```txt\n输入：\n\n6\n1fagas\ndsafa32j\nlkiuopybncv\nhfgdjytr\ncncxfg\nsdhrest\n\n输出：\n\nNO\n```\n\n样例 2\n\n```txt\n输入：\n\n5\nsdfggfds\nfgsdhsdf\ndsfhsdhr\nsdfhdfh\nsdfggfds\n\n输出：\n\nsdfggfds\n```\n\n这个题的思路在前面我们已经讲过了，这里我们换一种方式解题。\n\n使用映射和字典解题，是的原来的代码减少了超过一半，但是思路还是一样，可以说是非常的巧妙且省力。\n\n#### C++ 解法 ####\n\n```cpp\n #include <iostream>\n #include <map>\n using namespace std;\n\nmap<string,bool> mp;\nint main ()\n{\n\n    int n;\n    string ans=\"NO\";\n    cin>>n;\n    for(int i=0;i<n;i++)\n    {\n        string word;\n        cin>>word;\n        if(mp.count(word)){\n            ans=word;\n            break;\n        }\n\n        else mp[word]=1;\n    }\n    cout<<ans<<endl;\n\n}\n```\n\n**Java 解法**\n\n```java\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class Main {\n\n  static Map mp=new TreeMap();\n\n  public static void main(String[] args)\n  {\n\n      int n;\n      boolean flag=false;\n      Scanner in=new Scanner(System.in);\n      String ans=\"NO\";\n      n=in.nextInt();\n      for(int i=0;i<n;i++)\n      {\n          String word;\n          word=in.next();\n          // System.out.println(Hx(word));\n          if(flag) continue;\n\n          if(mp.containsKey(word)){\n              flag=true;\n              ans=word;\n          }\n          else {\n              mp.put(word,true);\n\n          }\n      }\n      System.out.println(ans);\n  }\n\n}\n```\n\n**Python 解法**\n\n```python\ndict={}\nif __name__=='__main__':\n\n\n  N=int (input())\n  ans = 'NO'\n  flag = False\n  while N>0:\n      N-=1\n      word=input()\n      if(not(flag)) :\n\n          if(dict.get(word)!=None):\n              flag=True\n              ans=word\n          else:\n              dict[word]=True\n  print(ans)\n```\n\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯冲刺营","8.工具函数模板"]},{"title":"二分算法","url":"/2024/02/22/二分算法/","content":"\n# 二分查找算法 #\n\n#### 知识点 ####\n\n- 二分查找原理讲解\n- 在单调递增序列 `a` 中查找 `x` 或 `x` 的后继\n- 在单调递增序列 `a` 中查找 `x` 或 `x` 的前驱\n\n## 二分查找算法讲解 ##\n\n枚举查找即顺序查找，实现原理是逐个比较数组 `a[0:n-1]` 中的元素，直到找到元素 `x` 或搜索整个数组后确定 `x` 不在其中。最坏情况下需要比较 `N` 次，时间复杂度是 `O(n)`，属于线性阶算法。\n\n而二分查找是一种折半查找方法。该方法将 `N` 个元素分成大致相等的两部分，选取中间元素与查找的元素进行比较。如果相等，则查找成功；如果查找元素小于中间元素，则在左半区继续查找；如果查找元素大于中间元素，则在右半区继续查找。每次都将范围缩小至原来的一半，因此时间复杂度是 `O(log2n)`。需要注意的是，二分查找的前提是数组有序，一般是从小到大排列。\n\n**折半查找的基本思想：**\n\n在有序表中（`low, high, low<=high`），取中间记录即 `a[(high+low)/2]` 作为比较对象。\n\n- 若给定值与中间记录的关键码相等，则查找成功。\n- 若给定值小于中间记录的关键码，则在中间记录的左半区继续查找。\n- 若给定值大于中间记录的关键码，则在中间记录的右半区继续查找。\n\n不断重复上述过程，直到查找成功或所查找的区域无记录，查找失败。\n\n**二分查找的特征：**\n\n1. 答案具有单调性。\n2. 二分答案的问题往往有固定的问法，例如：令最大值最小（最小值最大），求满足条件的最大（小）值等。\n\n**折半查找一般过程：**\n\n![图片描述](./../imgs/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/83f052e54f7e7907738ba7730a9b3297-0.png)\n\n下面是对文本的润色：\n\n```plaintext\nStep 1:\n\n假设存在一个有序数组：\n下标[ 0   1   2   3   4   5   6   7   8    9    10   11   12 ]\n数据[ 7   14  18  21  23  29  31  35   38   42   46   49  52 ]\n      ↑                                                   ↑\n    low=0                                              high=12\n\n                            mid=(low+high)/2\n                            mid=(0+12)/2\n                            mid=6\n                            [mid]=31 > 14，所以选择左半部分\n\n操作：\n    此时令low不变，high=mid-1=5\n\nStep 2:\n\n下标[ 0   1   2   3   4   5   6   7   8    9    10   11   12 ]\n数据[ 7   14  18  21  23  29  31  35   38   42   46   49  52 ]\n      ↑                   ↑\n   low=0                 high=5\n\n            mid=(low+high)/2\n            mid=(0+6)/2\n            mid=3\n            [mid]=21 > 14，所以选择左半部分\n\n操作：\n    此时令low不变，high=mid-1=2\n\nStep 3:\n\n下标[ 0   1   2   3   4   5   6   7   8    9    10   11   12 ]\n数据[ 7   14  18  21  23  29  31  35   38   42   46   49  52 ]\n      ↑       ↑\n   low=0    high=2\n\n            mid=(low+high)/2\n            mid=(0+2)/2\n            mid=1\n            [mid]=14 = 14  找到答案\n\n操作：\n    返回下标\n```\n\n这个文本看起来更加清晰，修正了一些不规范的表达。\n\n### 整数二分法常用算法模板 ###\n\n#### C++ 语言描述 ####\n\n```cpp\n// 在单调递增序列a中查找>=x的数中最小的一个（即x或x的后继）\nwhile (low < high)\n{\n    int mid = (low + high) / 2;\n    if (a[mid] >= x)\n        high = mid;\n\n    else\n        low = mid + 1;\n}\n\n// 在单调递增序列a中查找<=x的数中最大的一个（即x或x的前驱）\nwhile (low < high)\n{\n    int mid = (low + high + 1) / 2;\n\n    if (a[mid] <= x)\n        low = mid;\n\n    else\n        high = mid - 1;\n}\n```\n\n**Python 语言描述**\n\n```python\n#在单调递增序列a中查找>=x的数中最小的一个（即x或x的后继）\nwhile low<high:\n\n  mid=(low+high)/2\n\n  if(a[mid]>=x):\n      high=mid\n\n  else:\n      low=mid+1\n\n#在单调递增序列a中查找<=x的数中最大的一个（即x或x的前驱）\nwhile low<high:\n\n  mid=(low+high+1)/2\n\n  if(a[mid]<=x):\n      low=mid\n\n  else:\n      high = mid-1\n```\n\n**Java 语言描述**\n\n```java\n// 在单调递增序列a中查找>=x的数中最小的一个（即x或x的后继）\nwhile (low < high) {\n\n    int mid = (low + high) / 2;\n\n    if (a[mid] >= x)\n      high= mid;\n\n  else\n      low = mid + 1;\n}\n\n// 在单调递增序列a中查找<=x的数中最大的一个（即x或x的前驱）\nwhile (low < high) {\n\n    int mid = (low + high + 1) / 2;\n\n    if (a[mid] <= x)\n      low = mid;\n\n  else\n      high = mid - 1;\n\n}\n```\n\n此处我们先分整数的二分查找法的常用模版，关于实数的部分，我们后面再讲。\n\n> 下面可能会有同学会疑问道：为什么采用这一套代码的而不是采用查找等于的 X？\n>\n> 是因为这样的适用范围更广，当有 X 时这套代码就返回 X 的位置。如果没有 X，就返回 <=x 的数中最大的一个或者 >=x 的数中最小的一个。\n\n### 分巧克力 ###\n\n[2017 年省赛真题链接](https://www.lanqiao.cn/problems/99/learning/)。\n\n**题目描述:** 儿童节那天有 K 位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。\n\n小明一共有 *N* 块巧克力，其中第 *i* 块是 ×*H**i*×*W**i* 的方格组成的长方形。为了公平起见，\n\n小明需要从这 *N* 块巧克力中切出 K 块巧克力分给小朋友们。切出的巧克力需要满足：\n\n1. 形状是正方形，边长是整数;\n2. 大小相同;\n\n例如一块 6x5 的巧克力可以切出 6 块 2x2 的巧克力或者 2 块 3x3 的巧克力。\n\n当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？\n\n**输入描述:**\n\n第一行包含两个整数 ,*N*,*K* (1≤,≤1051≤*N*,*K*≤105)。\n\n以下 N 行每行包含两个整数 ,*H**i*,*W**i* (1≤,≤1051≤*H**i*,*W**i*≤105)。\n\n输入保证每位小朋友至少能获得一块 1x1 的巧克力。\n\n**输出描述:**\n\n输出切出的正方形巧克力最大可能的边长。\n\n**输入输出样例:**\n\n**示例:**\n\n> 输入\n\n```txt\n2 10 6 5 5 6\n```\n\n> 输出\n\n```txt\n2\n```\n\n**运行限制:**\n\n- 最大运行时间：2s\n- 最大运行内存: 256M\n\n注意：\n\n1. 请严格按要求输出，不要画蛇添足地打印类似：“请您输入…”的多余内容。\n2. 不要调用依赖于编译环境或操作系统的特殊函数。\n3. 所有依赖的函数必须明确地在源文件中\n4. 不能通过工程设置而省略常用头文件。\n\n#### 题目分析 ####\n\n简单思路，边长的最大规模为 100000100000；我们可以枚举出所有的情况。按从大到小的顺序进行切割，直到找到满足要求的巧克力边长。\n\n在判断边长是否满足条件时：求一块长方形（ℎ∗）（*h*∗*w*）最多被分成的正方形（∗）（*l**e**n*∗*l**e**n*）巧克力个数为：\n\n=(ℎ/)∗(/)*c**n**t*=(*h*/*l**e**n*)∗(*w*/*l**e**n*)\n\n但是使用朴素算法枚举时间复杂度()∗()=(2)*O*(*n*)∗*O*(*n*)=*O*(*n*2) 会超时，所以改用 22 分查找法，这找到符合要求的最大的一个。\n\n即用在单调递增序列 *a* 中查找 <=<=*x* 的数中最大的一个（即 *x* 或 *x* 的前驱）即可，原本这里的条件是 <=<=*x* ，我们将其换成验证即可。\n\n#### 代码解答 ####\n\nC++ 实现：\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\nconst int MAXN=100010;\nint n,k;\nint h[MAXN],w[MAXN];\n\nbool pd(int l)\n{\n    int sum=0;\n    for(int i=0; i<n; i++)\n    {\n        sum+=(h[i]/l)*(w[i]/l);\n        if(sum>=k)\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    cin>>n>>k;\n    for(int i=0; i<n; i++)\n        cin>>h[i]>>w[i];\n\n    //找到二分查找的上界\n    int high=0;\n\n    for(int i=0; i<n; i++)\n    {\n        high=max(high,h[i]);\n        high=max(high,w[i]);\n    }\n    // 二分下届由题意可得至少为1\n    int low=1;\n\n    // 由于本题目就是求符合要求的Mid 值所以要将mid定义在二分查找外边\n    int mid=0;\n    while(low<high)\n    {\n\n        mid = (low + high+1) / 2;\n        if(pd(mid))\n            low=mid;\n        else\n            high = mid - 1;\n\n//        cout<<low<<\" \"<<high<<endl;\n    }\n\n    //因为low=high所以输出哪一个都一样\n    cout<<low;\n    return 0;\n}\n```\n\n查找上界这里可以直接输入的时候查询，这道题实际上是可以少次操作的，代码如下。\n\n**Python 实现**\n\n```python\nN=K=0\nh=[]\nw=[]\ndef pd(l):\n\n sum1=0\n for i in range(N):\n\n   sum1+= (h[i]//l)* (w[i]//l)\n   # Java C++ 的除法都是自己取整，Python会换成小数，Python的取整除法是//\n\n   if sum1>=K :\n       return True\n\n return False\n\nif __name__ == '__main__':\n\n   inFor = input().split()\n\n   N=int(inFor[0])\n   K=int(inFor[1])\n\n   #找到二分查找的上界\n   high=0\n\n   for _ in range(N):\n       wi, hi = map(int, input().split())\n       w.append(wi)\n       h.append(hi)\n       high=max(high,max((hi,wi)))\n\n   # 二分下届由题意可得至少为1\n   low=1\n   #由于本题目就是求符合要求的Mid 值所以要将mid定义在二分查找外边\n   mid=0\n\n   while low<high :\n\n       mid= int ( (low+high+1)//2)\n       if pd(mid):\n           low=mid\n       else:\n           high=mid-1\n\n   #因为low=high所以输出哪一个都一样\n   print(low)\n```\n\n**Java 实现**\n\n```java\nimport java.util.Scanner;\nimport static java.lang.Integer.max;\n\npublic class Main {\n\n  static int n, k;\n  static int h[] = new int[100005];\n  static int w[] = new int[100005];\n  static boolean pd(int l) {\n      int sum = 0;\n      for (int i = 0; i < n; i++) {\n          sum += (h[i] / l) * (w[i] / l);\n          if (sum >= k) {\n              return true;\n          }\n      }\n      return false;\n  }\n\n  public static void main(String[] args) {\n\n      Scanner in = new Scanner(System.in);\n      n = in.nextInt();\n      k = in.nextInt();\n      //找到二分查找的上界\n      int high = 0;\n\n      for (int i = 1; i <= n; i++) {\n          h[i] = in.nextInt();\n          w[i] = in.nextInt();\n          high = max(high, h[i]);\n          high = max(high, w[i]);\n      }\n\n      // 二分下届由题意可得至少为1\n      int low = 1;\n      // 由于本题目就是求符合要求的Mid 值所以要将mid定义在二分查找外边\n      int mid = 0;\n\n      while (low < high) {\n          mid = (low + high + 1) / 2;\n          if (pd(mid))\n              low = mid;\n          else\n              high = mid - 1;\n          //        cout<<low<<\" \"<<high<<endl\n      }\n      //因为low=high所以输出哪一个都一样\n      System.out.println(low);\n  }\n}\n```\n\n**模板中的 <= 和 => 都可以换成其他判定条件，像上面根据题目分析即可。**\n\n## M 次方根 ##\n\n**题目描述:**\n\n小 A 最近在学高等数学，他发现了一道题，求273327。现在已知，小 A 开始计算，11 的三次方得11，22 的三次方得88，33 的三次方得2727，然后他很高兴的填上了33。\n\n接着他要求16455164。然后他开始11 的三次方得11，22 的三次方得88，33 的三次方得2727...\n\n直到他算到了秃头，也没有找到答案。\n\n这时一旁的小 B 看不下去了，说这题答案又不是个整数。小 A 震惊，原来如此。作为程序高手的小 A，打算设计一个程序用于求解 *M* 次根下*N*的值。\n\n但是由于要考虑精度范围，答案必须要保留 77 位小数，连三次根号下2727都要掰手指的小 A 又怎么会设计呢。请你帮小 A 设计一个程序用于求解 *M* 次根号*N*。\n\n数据范围：\n\n1≤≤151≤*N*≤1*e*5 1≤≤1001≤*M*≤100 且 <*M*<*N*\n\n**要求输入:**\n\n```txt\n输入描述:\n\n第一行输入整数 N 和 M，数据间用空格隔开。\n```\n\n**要求输出：**\n\n```txt\n输出描述:\n\n输出一个整数，并保留 7 位小数。\n```\n\n**样例:**\n\n```txt\n输入样例：\n\n27 3\n\n输出样例：\n\n3.000000\n```\n\n**运行限制:**\n\n```txt\n最大运行时间：1s\n最大运行内存: 256M\n\n注意：\n1. 请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。\n2. 不要调用依赖于编译环境或操作系统的特殊函数。\n3. 所有依赖的函数必须明确地在源文件中。\n4. 不能通过工程设置而省略常用头文件。\n```\n\n#### 题目分析 ####\n\n前面讲的都是整数二分，其实二分法还是可以用于实数。这个题目比较难，很多同学可能想不明白，想不明白就多读题，写写画画理解一下。这个题还有很多解法，现在告诉你了这道理用二分可以解答，请设计一个二分程序。\n\n首先是这道题我们怎么下手：\n\n根据前面的知识，我们要找到一个具有单调性的数列，去二分。这个题的关键是我们要去二分什么，这里可以二分的是 *a**M* 中的 *a*，所以我们要先想办法设计出用于处理实数二分的代码。\n\n这里给大家两个模板，都可以大家选择一个使用即可：\n\nC++ 模版：\n\n```cpp\n//模版一：实数域二分，设置eps法\n\n//令 eps 为小于题目精度一个数即可。比如题目说保留4位小数，0.0001 这种的。那么 eps 就可以设置为五位小数的任意一个数 0.00001- 0.00009 等等都可以。\n\n//一般为了保证精度我们选取精度/100 的那个小数，即设置 eps= 0.0001/100 =1e-6\n\nwhile (l + eps < r)\n{\n    double mid = (l + r) / 2;\n\n    if (pd(mid))\n        r = mid;\n    else\n        l = mid;\n}\n\n//模版二：实数域二分，规定循环次数法\n//通过循环一定次数达到精度要求，这个一般 log2N < 精度即可。N 为循环次数，在不超过时间复杂度的情况下，可以选择给 N 乘一个系数使得精度更高。\n\n    for (int i = 0; i < 100; i++)\n{\n\n    double mid = (l + r) / 2;\n    if (pd(mid))\n        r = mid;\n    else\n        l = mid;\n}\n```\n\n**Python 模版:**\n\n```python\n# 实数域二分，设置eps法\n# 令eps 为小于题目精度一个数即可，比如题目说保留4位小数，0.0001 这种的。那么eps 就可以设置为五位小数的任意一个数 0.00001- 0.00009 等等都可以。一般为了保证精度我们选取精度/100 的那个小数\n\neps = 1e-6\nwhile l + eps < r:\n  mid = (l + r) / 2\n  if (pd(mid)):\n      r = mid\n  else:\n      l = mid\n\n# 实数域二分，规定循环次数法\n# 通过循环一定次数达到精度要求，这个一般 log2N< 精度即可。N 为循环次数，在不超过时间复杂度的情况下，可以选择给N乘一个系数使得精度更高。\n\nfor _ in range(100):\n  mid = (l + r) / 2\n  if (pd(mid)):\n      r = mid\n  else:\n      l = mid\n```\n\n**Java 模版:**\n\n```java\n//令eps 为小于题目精度一个数即可。\n\n//比如题目说保留4位小数，0.0001 这种的。那么eps 就可以设置为五位小数的任意一个数 0.00001- 0.00009 等等都可以。一般为了保证精度我们选取精度 /100 的那个小数，即设置  eps= 0.0001/100 =1e-6。\n\nwhile (l + eps < r) {\n    double mid = (l + r) / 2;\n\n    if (pd(mid))\n      r = mid;\n  else\n      l = mid;\n}\n\n// 实数域二分，规定循环次数法\n\n//通过循环一定次数达到精度要求，这个一般log2N< 精度即可。N为循环次数，在不超过时间复杂度的情况下，可以选择给N乘一个系数使得精度更高。\n\nfor (int i = 0; i < 100; i++) {\n\n    double mid = (l + r) / 2;\n    if (pd(mid))\n      r = mid;\n  else\n      l = mid;\n}\n```\n\n模板讲完了，然后我们就要考虑判定条件了，怎样判定是否存在满足大于平均值的区间。当然这个题你可以使用语言中自带开方软件，但是我们还是联系一下实数的二分代码。\n\n关于判定条件，我们应该设计一个代码用于比较 *a**m* 和 *N* 的大小关系。\n\n在我们代码中：\n\n```cpp\nif (pd(mid))\n    r = mid;\nelse\n    l = mid;\n```\n\n*p**d* 成功的情况，一定是 *p**d* 的 *m**i**d* 符合条件，且小于 *m**i**d* 的一定符合条件。因此我们要在大于 *m**i**d* 中继续查找，找到更大的 *m**i**d*。\n\n所以我们可以设计出如下判定条件:\n\n```cpp\ndouble pd(double a,int m)\n{\n    double c=1;\n    while(m>0)\n    {\n        c=c*a;\n        m--;\n    }\n    if(c>=n)\n        return true;\n    else\n        return false;\n}\n```\n\n#### 代码解答 ####\n\nC++ 实现：\n\n```c++\n#include <cstdio>\n#include <iostream>\n#include<iomanip> //用于浮点数输出\nusing namespace std;\n\ndouble n,l,r,mid;\ndouble eps=1e-8;\n\nbool pd(double a,int m)\n{\n    double c=1;\n    while(m>0)\n    {\n        c=c*a;\n        m--;\n    }\n    if(c>=n)\n        return true;\n    else\n        return false;\n}\n\nint main()\n{\n    int m;\n    cin>>n>>m;\n//设置二分边界\n    l=0,r=n;\n//实数二分\n    while (l + eps < r)\n    {\n        double mid = (l + r) / 2;\n        if (pd(mid,m))\n            r = mid;\n        else\n            l = mid;\n    }\n\n    cout<<fixed<<setprecision(7)<<l;\n    //一般使用print\n    //printf(\"%x.yf\",n)\n    //其中X是固定整数长度，小数点前的整数位数不够，会在前面补0\n    //y是保留小数位数，不够补零\n    //printf(\"%.7f\",l);\n    return 0;\n}\n```\n\n查找上界这里可以直接输入的时候查询，这道题实际上是可以少次操作的，代码如下。\n\n**Python 实现**\n\n```python\nn = 0.0\nm = 0\nl = 0.0\nr = 0.0\nmid = 0.0\neps = 0.00000001\n\ndef pd(a, m):\n  c = 1.0\n  cnt = int(m)\n\n  while cnt > 0:\n      c = c * a\n      cnt -= 1\n\n  if c >= n:\n      return True\n\n  else:\n      return False\n\n\nif __name__ == '__main__':\n\n  n, m = input().split()\n\n  l = 0\n  r=n=int(n)\n\n  while l + eps < r:\n      mid = (l + r) / 2\n      if (pd(mid, m)):\n          r = mid\n      else:\n          l = mid\n\nprint(\"%.7f\" % l)\n```\n\n**Java 实现**\n\n```java\npackage com.company;\nimport java.util.Scanner;\n\npublic class Main {\n\n  static double n, l, r, mid;\n  static double eps = 1e-8;\n\n  static boolean pd(double a, int m) {\n      double c = 1;\n      while (m > 0) {\n          c = c * a;\n          m--;\n      }\n\n      if (c >= n)\n          return true;\n      else\n          return false;\n  }\n\n  public static void main(String[] args) {\n\n      int m;\n      Scanner in =new Scanner(System.in);\n      n=in.nextDouble();\n      m=in.nextInt();\n//设置二分边界\n      l = 0;\n      r = n;\n//实数二分\n      while (l + eps < r) {\n          double mid = (l + r) / 2;\n          if (pd(mid, m))\n              r = mid;\n          else\n              l = mid;\n      }\n      System.out.println(String.format(\"%.7f\",l));\n  /*\n   关于string.format 的应用\n\n  double num = 123.4567899;\n  System.out.print(String.format(\"%f %n\", num)); // 123.456790\n  System.out.print(String.format(\"%a %n\", num)); // 0x1.edd3c0bb46929p6\n  System.out.print(String.format(\"%g %n\", num)); // 123.457\n\n  可用标识：\n\n        -，在最小宽度内左对齐,不可以与0标识一起使用。\n        0，若内容长度不足最小宽度，则在左边用0来填充。\n        #，对8进制和16进制，8进制前添加一个0,16进制前添加0x。\n        +，结果总包含一个+或-号。\n        空格，正数前加空格，负数前加-号。\n        ,，只用与十进制，每3位数字间用,分隔。\n        (，若结果为负数，则用括号括住，且不显示符号。\n\n  可用转换符：\n\n        b，布尔类型，只要实参为非false的布尔类型，均格式化为字符串true，否则为字符串false。\n        n，平台独立的换行符, 也可通过System.getProperty(\"line.separator\")获取。\n        f，浮点数型（十进制）。显示9位有效数字，且会进行四舍五入。如99.99。\n        a，浮点数型（十六进制）。\n        e，指数类型。如9.38e+5。\n        g，浮点数型（比%f，%a长度短些，显示6位有效数字，且会进行四舍五入）\n\n   */\n\n  }\n}\n```\n\n## 总结 ##\n\n二分的题目主要是必须要求是单调的，一般会有条件等字眼。做这种题目主要还是找到递增或者递减的序列，然后关于序列的判定条件。或者通过观察时间复杂度来看是否可以使用二分，二分法的题目相对来说比较明显，设计起来也比较简单，模板不用死记硬背，理解一下，很快就可以独立写出来。\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯冲刺营","7.二分算法"]},{"title":"并查集","url":"/2024/02/22/并查集/","content":"\n# 并查集 #\n\n并查集是我认为最巧妙优雅的一种数据结构，他主要适用于解决元素分组和不相交集合的合并和查询问题。\n\n并查集也非常简单，但是，并查集在比赛中非常常用，能够极大的降低算法复杂度得数据结构，是必须要掌握熟练的。\n\n本节课的难度相对较低，无论是实现方式还是算法原理。\n\n### 知识点 ###\n\n1.并查集的原理与实现方式 2.并查集的路径压缩 3.启发式合并\n\n#### 并查集 ####\n\n并查集是大量的树（单个节点也算是树）经过合并生成一系列家族森林的过程。\n\n每个集合也就是每棵树都是由根节点确定，也可以理解为每个家族的族长就是根节点。\n\n举个数字和字母的例子如下。\n\n**初始森林：** ![图片描述](./../imgs/%E5%B9%B6%E6%9F%A5%E9%9B%86/8d24aa87dbdd7a5823ff707ccd72b82a-0.jpeg)\n\n**经过的一系列合并后的状态（不唯一，举个栗子）：**\n\n![图片描述](./../imgs/%E5%B9%B6%E6%9F%A5%E9%9B%86/626f64ab4d60b09b29e811ff903f10c6-0.jpeg)\n\n**最终合并后的状态：**\n\n注：示意图的位置与存储物理位置无关，只代表逻辑关系。\n\n![图片描述](./../imgs/%E5%B9%B6%E6%9F%A5%E9%9B%86/f4ba4e2ff16c8ffb15e361188d5c71b7-0.jpeg)\n\n#### 并查集的存储结构 ####\n\n并查集采用数组表示整个森林，初始时每个森林的树根为自己。\n\nC++ 存储与初始化：\n\n```c++\n# define Maxn 200\n\n// 假设所需数量为200\n\nint fa[Maxn+1]\n\nvoid init()\n{\n    for(int i =0;i<=Maxn; i++)\n        fa[i]=i;\n}\n```\n\nPython 存储与初始化：\n\n```python\nMaxn = 200\n\n# 假设所需的数量为200\n\nfa = []\n\ndef init():\n\n    for i in range(Maxn + 1):\n\n        fa.append(i)\n```\n\nJava 存储与初始化：\n\n```java\nstatic final int Maxn = 200;\n\nstatic int fa[]=new int[Maxn+1];\n\nstatic void init() {\n\n    for(int i=0 ;i<=Maxn;i++)\n\n        fa[i]=i;\n\n}\n```\n\n#### 查询 ####\n\n一般用递归法实现对代表元素的查询：递归访问父节点，直至根节点（根节点的标志就是父节点是本身）。\n\n根节点相同的两个元素属于同一个集合，上面也说到了。所以判断 `A`，`B` 是否属于一个集合直接判断 `find(A)`和 `find(B)`是否相同即可。\n\n由于代码比较简单，我们先给出查询的代码：\n\nC++ 查询：\n\n```c++\nint find(int x)\n{\n    if(fa[x] == x)\n        return x;\n    else\n        return find(fa[x]);\n}\n```\n\nPython 查询：\n\n```python\ndef find(x):\n\n    if fa[x] == x:\n        return x\n\n    else:\n        return find(fa[x])\n```\n\nJava 查询：\n\n```c++\nstatic  int find(int x)\n{\n    if(fa[x] == x)\n        return x;\n    else\n        return find(fa[x]);\n}\n```\n\n我们这里有一个问题，当树的链很长时，比如：\n\n![图片描述](./../imgs/%E5%B9%B6%E6%9F%A5%E9%9B%86/567d8282a596647b92af905396d88ee4-0.jpeg)\n\n如果每次都查询最后一个，那么他就要经过多次递归，非常消耗时间，这时候我们就要引入路径压缩。\n\n#### 路径压缩 ####\n\n路径压缩是为了解决当树的高度过高的时候，提高查询时效的方法。\n\n解决方式也很简单，在递归的同时将路径压缩，那么上面的图经过一次查询后的效果如下。\n\n![图片描述](./../imgs/%E5%B9%B6%E6%9F%A5%E9%9B%86/58877fc5b4c8482c0c5c44ef1aeb8adf-0.jpeg)\n\n其实，实现方式也非常简单，只需要将查询代码修改即可，代码如下：\n\nC++ 查询带路径压缩：\n\n```c++\nint find(int x)\n{\n    if(x == fa[x])\n        return x;\n\n    else\n    {\n        fa[x] = find(fa[x]);\n        //父节点设为根节点\n\n        return fa[x];\n        //返回父节点\n    }\n}\n```\n\nPython 查询带路径压缩：\n\n```python\ndef find(x):\n\n    if fa[x] == x:\n        return x\n\n    else:\n\n        fa[x] = find(fa[x]);\n        #父节点设为根节点\n\n        return  fa[x]\n        # 返回父节点\n```\n\nJava 查询带路径压缩：\n\n```c++\nstatic  int find(int x)\n{\n    if(x == fa[x])\n        return x;\n\n    else\n    {\n        fa[x] = find(fa[x]);\n        //父节点设为根节点\n\n        return fa[x];\n        //返回父节点\n    }\n}\n```\n\n#### 合并 ####\n\n合并的方式很简单，就是把一颗树的根节点设置为另一棵树的根节点即可。\n\n还有一种方式是按秩合并，但是我们使用路径压缩时间复杂度就已经很低了，如果在引入 `rank` 相对会有些复杂。而且对于我们的使用路径压缩一种方式就已经足够。并且路径压缩和按秩合并一起使用时会影响 `rank` 准确性，所以我们采用普通的合并与优化后的查找即可。\n\n![图片描述](./../imgs/%E5%B9%B6%E6%9F%A5%E9%9B%86/15fd5c72e7f73740bd1cc2ab4c0e3bf7-0.jpeg)\n\n合并后：\n\n![图片描述](./../imgs/%E5%B9%B6%E6%9F%A5%E9%9B%86/29a76e16a78eec6765c066f0158b236b-0.jpeg)\n\nC++ 合并：\n\n```c++\nvoid merge(int i, int j)\n{\n    fa[find(i)] = find(j);\n}\n```\n\nPython 合并：\n\n```python\ndef merge(x,y):\n\n    fa[find(x)] = find(y)\n```\n\nJava 合并：\n\n```c++\nstatic void merge(int i, int j)\n{\n    fa[find(i)] = find(j);\n}\n```\n\n**合并优化：**\n\n除此之外还有一个优化是启发式合并，其实这个启发式是泛指有很多的合并算法都叫启发式合并，我们这里讲其中一种常用的启发式合并。合并时，选择哪棵树的根节点作为新树的根节点会影响未来操作的复杂度。我们可以按照子树大小去合并，小的合并到大的，以免发生退化。所以启发式合并的原理是在集合合并时将小的集合合并到大的集合里，也可以使 `find` 操作复杂度降低到  �(����)*O*(*l**o**g**n*)，在集合合并时还要增加一个更新集合大小的操作。\n\n```c\nC++\nvoid merge(int x,int y)//启发式合并\n{\n    x=find(x);\n    y=find(y);\n    if(x!=y)\n    {\n        if(sz[x]<sz[y])\n            swap(x,y);\n        sz[x]+=sz[y];\n        fa[y]=x;\n    }\n}\n\n\nJava\n    public void merge(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x != y) {\n            if (sz[x] < sz[y]) {\n                swap(x, y);\n            }\n            sz[x] += sz[y];\n            fa[y] = x;\n        }\n    }\n\npython\n\ndef merge(x, y, sz, fa):\n    x = find(x, fa)\n    y = find(y, fa)\n    if x != y:\n        if sz[x] < sz[y]:\n            swap(x, y, fa)\n        sz[x] += sz[y]\n        fa[y] = x\n```\n\n如果是一般的并查集题目用路径压缩就可以了，当然两种优化都用的话复杂度可以降得更低。两种优化都使用的话单次操作的复杂度才是  �(�)*O*(*α*)\n\n### 并查集相关题目讲解 ###\n\n#### 合根植物 ####\n\n[题目链接](https://www.lanqiao.cn/problems/110/learning/)\n\n难度: 简单\n\n标签: 并查集, 2017, 国赛\n\n**题目描述:**\n\n```txt\nw 星球的一个种植园，被分成 m×n 个小格子（东西方向 m 行，南北方向 n 列）。每个格子里种了一株合根植物。\n\n这种植物有个特点，它的根可能会沿着南北或东西方向伸展，从而与另一个格子的植物合成为一体。\n\n如果我们告诉你哪些小格子间出现了连根现象，你能说出这个园中一共有多少株合根植物吗？\n```\n\n**输入描述:**\n\n```txt\n第一行，两个整数 m,n，用空格分开，表示格子的行数、列数（1≤m,n≤1000）。\n\n接下来一行，一个整数 k (0≤k≤105 )，表示下面还有 k 行数据。\n\n接下来 k 行，每行两个整数 a，b，表示编号为 a 的小格子和编号为 b 的小格子合根了。\n\n格子的编号一行一行，从上到下，从左到右编号。\n\n比如：5×4 的小格子，编号：\n```\n\n| 行列 | ①    | ②    | ③    | ④    |\n| ---- | ---- | ---- | ---- | ---- |\n| ①    | 1    | 2    | 3    | 4    |\n| ②    | 5    | 6    | 7    | 8    |\n| ③    | 9    | 10   | 11   | 12   |\n| ④    | 13   | 14   | 15   | 16   |\n| ⑤    | 17   | 18   | 19   | 20   |\n\n**输出描述:**\n\n```txt\n输出植物数量。\n```\n\n**输入输出样例:**\n\n**示例:**\n\n**输入:**\n\n```txt\n5 4\n16\n2 3\n1 5\n5 9\n4 8\n7 8\n9 10\n10 11\n11 12\n10 14\n12 16\n14 18\n17 18\n15 19\n19 20\n9 13\n13 17\n```\n\n**输出:**\n\n```txt\n5\n```\n\n样例图例如下：\n\n![图片描述](./../imgs/%E5%B9%B6%E6%9F%A5%E9%9B%86/uid1580206-20210202-1612249467438.png)\n\n**运行限制:**\n\n```txt\n    最大运行时间：1s\n    最大运行内存: 256M\n```\n\n**题目解析：**\n\n这个题就是一个模板并查集的题目，每次合根就是一次 `Merge`。\n\n最后答案就是看有多少个根即可，那么就是看有多少个`fa[x]=x`即可。\n\n直接按照题目编写即可，部分解析直接写进题目。\n\n**答案解析：**\n\nC++ 描述：\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n# define Maxn 2000000\n\n// 假设所需数量为200\nint fa[Maxn+1];\nvoid init()\n{\n    for(int i =0; i<=Maxn; i++)\n        fa[i]=i;\n}\nint find(int x)\n{\n    if(x == fa[x])\n        return x;\n    else\n    {\n        fa[x] = find(fa[x]);\n        //父节点设为根节点\n        return fa[x];\n        //返回父节点\n    }\n}\nvoid merge(int i, int j)\n{\n    fa[find(i)] = find(j);\n}\nint n,m; //n行，m列\nint k; //k次合根\nint main()\n{\n    init();\n    cin>>n>>m>>k;\n    int a,b;\n    for(int i=1; i<=k; i++)\n    {\n        cin>>a>>b;\n        merge(a,b); //合根\n    }\n\n    int ans=0;\n    for(int i=1; i<=n*m; i++)\n    {\n        if(fa[i]==i) //找根节点\n        {\n            ans++;\n        }\n    }\n    cout<<ans;\n    return 0;\n}\n```\n\nPython 描述：\n\n```python\nMaxn = 2000000\n# 假设所需的数量为200\nfa = []\n\ndef init():\n    for i in range(Maxn + 1):\n        fa.append(i)\n\ndef find(x):\n\n    if fa[x] == x:\n        return x\n    else:\n\n        fa[x] = find(fa[x])\n        #父节点设为根节点\n        return  fa[x]\n        # 返回父节点\n\ndef merge(x,y):\n\n    fa[find(x)] = find(y)\nif __name__ == '__main__':\n\n    n,m=input().split()\n    k=input()\n    n=int(n)\n    m=int(m)\n    k=int(k)\n    Maxn=m*n+100\n    init()\n    for _ in range(k):\n        a,b= input().split()\n        a=int(a)\n        b=int(b)\n        merge(a,b)\n    ans=0\n\n    for i in range(m*n): #从0开始\n        index=i+1 #调整一下，应该是从1开始\n        if(fa[index]==index):\n            ans+=1\n\n    print(ans)\n```\n\nJava 描述：\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n\n    static  int Maxn;\n    static int fa[];\n    static void init() {\n\n        for(int i=0 ;i<=Maxn;i++)\n            fa[i]=i;\n\n    }\n    static  int find(int x)\n    {\n        if(x == fa[x])\n            return x;\n\n        else\n        {\n            fa[x] = find(fa[x]);\n            //父节点设为根节点\n            return fa[x];\n            //返回父节点\n        }\n    }\n    static void merge(int i, int j)\n    {\n        fa[find(i)] = find(j);\n    }\n\n    static int n,m; //n行，m列\n    static int k; //k次合根\n    public static void main(String[] args) {\n\n        Scanner in = new Scanner(System.in);\n        n=in.nextInt();\n        m=in.nextInt();\n        k=in.nextInt();\n        Maxn=m*n;\n        fa=new int[Maxn+100];\n        init();\n        int a,b;\n        for(int i=1; i<=k; i++)\n        {\n            a=in.nextInt();\n            b=in.nextInt();\n            merge(a,b);\n        }\n\n        int ans=0;\n        for(int i=1; i<=n*m; i++)\n        {\n            if(fa[i]==i)\n            {\n                ans++;\n            }\n        }\n        System.out.println(ans);\n    }\n}\n```\n\n#### 修改数组 ####\n\n[题目链接](https://www.lanqiao.cn/problems/185/learning/)\n\n难度: 中等\n\n标签: 并查集, 2019, 省赛\n\n**题目描述:** 给定一个长度为 �*N* 的数组 �=[�1,�2,⋅⋅⋅,��]*A*=[*A*1,*A*2,⋅⋅⋅,*A**N*]，数组中有可能有重复出现的整数。\n\n现在小明要按以下方法将其修改为没有重复整数的数组。小明会依次修改�2,�3,⋅⋅⋅,��*A*2,*A*3,⋅⋅⋅,*A**N*。\n\n当修改 ��*A**i* 时，小明会检查 ��*A**i* 是否在 �1*A*1 ∼ ��−1*A**i*−1 中出现过。如果出现过，则小明会给 ��*A**i* 加上 1 ；如果新的 ��*A**i* 仍在之前出现过，小明会持续给 ��*A**i* 加 1 ，直 到 ��*A**i* 没有在 �1*A*1 ∼ ��−1*A**i*−1 中出现过。\n\n当 ��*A**N* 也经过上述修改之后，显然 �*A* 数组中就没有重复的整数了。\n\n现在给定初始的 �*A* 数组，请你计算出最终的 �*A* 数组。\n\n**输入:**\n\n第一行包含一个整数 �*N*。\n\n第二行包含 �*N* 个整数 �1,�2,⋅⋅⋅,��*A*1,*A*2,⋅⋅⋅,*A**N*。\n\n其中，1≤�≤105，1≤��≤1061≤*N*≤105，1≤*A**i*≤106。\n\n**输出：**\n\n输出 �*N* 个整数，依次是最终的 �1,�2,⋅⋅⋅,��*A*1,*A*2,⋅⋅⋅,*A**N*。\n\n**输入输出样例:**\n\n输入\n\n```txt\n5\n2 1 1 3 4\n```\n\n输出\n\n```txt\n2 1 3 4 5\n```\n\n**运行限制:**\n\n```txt\n最大运行时间：1s\n最大运行内存: 128M\n```\n\n**题目解析：**\n\n第一步，先初始化并查集。\n\n第二步，读入数组并作如下处理：\n\n如果这数字在之前没出现过那么他的值应该就是自己，并将其加入集合，此后再出现这个数字那么就要输出这个数字加 11，所以将这个数字的根节点设置为这个数字+1+1 即可。\n\n如果这个数字之前出现过那么这个数字应该变成根节点的值，根节点的值是之前出现过的值加+1+1。\n\n然后重复简单的逻辑即可，现在是维护一个之前出现过的集合，每个出现过的数字会把根节点设置为比他大 11 的数字，重复这个过程即可完成题意。\n\n我们之前说过，因为输入输出是分开的，这里直接输出就行，不必在使用数组存储。\n\n比如样例：\n\n```txt\n2 1 1 3 4\n\n首先因为 2 没出现过现在，所以初始化后的 fa[2] 等于2\n\n所以直接输出2 即可。\n\n此时 2 已经出现过了，下次遇见2就要输出3，所以这里我们使fa[2]等于3\n\n或者使用merge(2,3);\n\n然后输入1，因为1 也没有出现过，所以重复 2 的操作即可。\n\n输出fa[1]。\n\n令fa[1]=2，但是fa[2]=3,因为2也出现过\n\n这样fa[1]=fa[2]=3\n\n当然这里只需要执行merge(2,3)\n\n\n然后输入1，因为1 之前出现过，而且他的值我们之前也处理好了，直接输出即可。\n\n输出fa[1],即3。\n\n使用merge(3,4)\n\n然后重复上述过程，代码如下：\n\n        输入X :Input(X)\n\n        找到根节点: X=find(X);\n\n        输出应该是多少：Print(X)\n\n        将根节点加+1处理：merge(X,X+1);\n```\n\n**答案解析：**\n\nC++ 描述：\n\n```cpp\n #include <bits/stdc++.h>\nusing namespace std;\n\n# define Maxn 2000000\n// 假设所需数量为2000000\n\nint fa[Maxn+1];\nvoid init()\n{\n    for(int i =0; i<=Maxn; i++)\n        fa[i]=i;\n}\nint find(int x)\n{\n    if(x == fa[x])\n        return x;\n    else\n    {\n        fa[x] = find(fa[x]);\n        //父节点设为根节点\n        return fa[x];\n        //返回父节点\n    }\n}\nvoid merge(int i, int j)\n{\n    fa[find(i)] = find(j);\n}\nint main()\n{\n\n    init();\n    int n;\n    cin>>n;\n    for(int i=0; i<n; i++)\n    {\n        int t;\n        cin>>t;\n        t=find(t);\n        cout<<t<<\" \";\n        merge(t,t+1);\n    }\n    return 0;\n}\n```\n\nPython 描述：\n\n```python\nMaxn = 2000000\n# 假设所需的数量为200\nfa = []\ndef init():\n    for i in range(Maxn + 1):\n        fa.append(i)\ndef find(x):\n    if fa[x] == x:\n        return x\n    else:\n        fa[x] = find(fa[x]);\n        #父节点设为根节点\n        return  fa[x]\n        # 返回父节点\n\ndef merge(x,y):\n    fa[find(x)] = find(y)\n\nif __name__ == '__main__':\n\n    n=input()\n    A=input().split()\n    A=list(map(int,A))\n    Maxn=len(A)+100\n    init()\n    for i in range(len(A)):\n\n        t=find(A[i])\n        print(t,end=\" \")\n        merge(t,t+1)\n```\n\nJava 描述：\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n    static  int Maxn=1000005;\n    static int fa[];\n    static void init() {\n\n        for(int i=0 ;i<=Maxn;i++)\n            fa[i]=i;\n    }\n    static  int find(int x)\n    {\n        if(x == fa[x])\n            return x;\n        else\n        {\n            fa[x] = find(fa[x]);\n            //父节点设为根节点\n            return fa[x];\n            //返回父节点\n        }\n    }\n    static void merge(int i, int j)\n    {\n        fa[find(i)] = find(j);\n    }\n\n    static int n,m; //n行，m列\n    static int k; //k次合根\n    public static void main(String[] args) {\n\n        Scanner in = new Scanner(System.in);\n        n=in.nextInt();\n        fa=new int[Maxn+100];\n        init();\n        for(int i=1; i<=n; i++)\n        {\n            int t;\n            t=in.nextInt();\n            t=find(t);\n            System.out.print(t+\" \");\n            merge(t,t+1);\n        }\n    }\n}\n```\n\n## 总结 ##\n\n并查集的思想非常简单，但是我们也看到了题目有点复杂，稍微一点改变就是另一种方向。并查集代码实现非常简单，但重点还是看对于题目的把握，这个数据结构不仅直接出题目，并且也会杂糅到别的算法里面，所以他的应用非常广泛，需要我们牢牢地掌握。\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯冲刺营","6.并查集"]},{"title":"差分与前缀和","url":"/2024/02/22/差分与前缀和/","content":"\n# 差分与前缀和 #\n\n差分与前缀和是一对互逆的操作，常常用于处理区间问题，差分法是解决区间加减问题，前缀和是解决区间求和问题的常用办法。\n\n#### 知识点 ####\n\n- 差分算法\n- 前缀和算法\n\n## 差分法 ##\n\n差分法的应用主要是用于处理区间问题。当某一个数组要在很多不确定的区间，加上相同的一个数。我们如果每个都进行加法操作的话，那么复杂度 �(��)*O*(*n**m*) 是平方阶的，非常消耗时间。\n\n如果我们采用差分法，将数组拆分，构造出一个新的拆分数组，通过对数组区间的端点进行加减操作，最后将数组和并就能完成原来的操作。\n\n这样处理后，时间复杂度降低为 �(�)*O*(*N*)，虽然感觉操作变得更加复杂了，但是只用对边界操作确实比操作一整个区间的方法要优秀的多。\n\n听到这里也是吊足了胃口，那到底怎么对区间操作呢，请大家跟随我的讲解，慢慢理解。\n\n**差分法的特点：**\n\n1. 将对于区间的加减操作转化为对于端点的操作；\n2. 时间复杂度为 �(�)*O*(*n*)；\n3. 用于维护区间的增减但不能维护乘除；\n4. 差分后的序列比原来的数组序列多一个数。\n\n**差分算法解题的基本思路：**\n\n1. 设定 �[1]=�[1]*b*[1]=*a*[1]；\n2. 对于第 2 项到第 n 项，利用差分式 �[�]=�[�]−�[�−1]*b*[*i*]=*a*[*i*]−*a*[*i*−1]；\n3. 对于区间端点进行加减操作；\n4. 进行差分还原（即前缀和）；\n5. 注意，这里从 1 开始。如果从 0 开始，还需讨论 �=0*i*=0 的情况。使用 1 的话，�[1]=�[1]−�[0]=�[1]*b*[1]=*a*[1]−*a*[0]=*a*[1]。\n\n**递推算法的一般步骤：**\n\n假设有一个数组：\n\n```plaintext\na = [1, 2, 3, 4, 5, 7, 2]\n```\n\n差分后：\n\n```plaintext\nb = [1, 1, 1, 1, 1, 2, -5]\n```\n\n一般应用场景是对区间 [�,�][*l*,*r*] 进行 �*N* 次加减操作。例如：\n\n- 从第二个元素到第五个元素每个加 33\n- 从第二个元素到第四个元素每个减 22\n- 从第一个元素到第三个元素每个加 11\n\n对于每个 [�,�][*l*,*r*] 区间的加减操作都可转化为对端点 �*l* 和 �+1*r*+1 的操作。例如，从第二个元素到第五个元素每个加 33，可转化为 [�][*l*] 加 33 且 [�+1][*r*+1] 减 33。\n\n原序列变成了：\n\n```plaintext\n1 1 1 1 1 2 -5\n1 4 1 1 1 -1 -5\n```\n\n然后按照 �[�]=�[�]+�[�−1]*b*[*i*]=*b*[*i*]+*b*[*i*−1] 复原：\n\n```plaintext\n1 5 6 7 8 7 2\n```\n\n去掉最后一项，跟原序列对比：\n\n```plaintext\n1 2 3 4 5 7 2\n1 5 6 7 8 7 2\n```\n\n确实是都加上了 33。\n\n继续操作：\n\n从第二个元素到第四个元素每个减 22，可转化为 [�][*l*] 减 22 且 [�+1][*r*+1] 加 22。\n\n序列变成了：\n\n```plaintext\n1 4 1 1 1 -1 -5\n1 2 1 1 3 -1 -5\n```\n\n然后按照 �[�]=�[�]+�[�−1]*b*[*i*]=*b*[*i*]+*b*[*i*−1] 复原：\n\n```plaintext\n1 3 4 5 8 7 2\n```\n\n与上次复原后对比：\n\n```plaintext\n1 5 6 7 8 7 2\n1 3 4 5 8 7 2\n```\n\n确实是按照操作执行了。\n\n注意，不需要每次都复原，只需在最后一次复原即可。\n\n最后直接做三次，最后还原：\n\n- 从第二个元素到第五个元素每个加 33\n- 从第二个元素到第四个元素每个减 22\n- 从第一个元素到第三个元素每个加 11\n\n原序列差分后：\n\n```plaintext\nb = [1 1 1 1 1 2 -5]\n```\n\n- 第 2 个元素加 3\n- 第 6 个元素减 3\n- 第 2 个元素减 2\n- 第 5 个元素加 2\n- 第 1 个元素加 1\n- 第 4 个元素减 1\n\n差分序列变成：\n\n```plaintext\n2 2 1 0 3 -1 -5\n```\n\n复原后：\n\n```plaintext\n2 4 5 5 8 7 5\n```\n\n与原序列对比：\n\n```plaintext\n1 2 3 4 5 7 2\n2 4 5 5 8 7 5\n```\n\n所以，差分算法是非常方便快捷的。\n\n差分与前缀和是逆操作，常在一起出现，但是先做差分还是先做前缀和就是两种不同的算法，做不做另一种操作也决定了算法不同，所以大家要根据题目分析，具体学会使用。\n\n### 大学里的树木要打药 ###\n\n**题目描述:**\n\n教室外有 N 棵树，根据不同的位置和树种，学校要对其上不同的药。\n\n因为树的排列成线性，且非常长，我们可以将它们看作一条直线给他们编号。\n\n树的编号从 00 ~ �−1*N*−1 且 �<1�6*N*<1*e*6。\n\n对于树的药是成区间分布，比如 3−53−5 号的树靠近下水道，所以他们要用驱蚊虫的药， 20−2620−26 号的树，他们排水不好，容易涝所以要给他们用点促进根系的药。\n\n诸如此类，每种不同的药要花不同的钱。\n\n现在已知共有 �*M* 个这样的区间，并且给你每个区间花的钱，请问最后，这些树木花了多少药费。\n\n**输入:**\n\n输入描述:\n\n每组输入的第一行有两个整数 �（1<=�<=1000000）*N*（1<=*N*<=1000000）和 �（1<=�<=100000）*M*（1<=*M*<=100000）。\n\n�*N* 代表马路的共计多少棵树，�*M*代表区间的数目，�*N* 和 �*M* 之间用一个空格隔开。\n\n接下来的 �*M* 行每行包含三个不同的整数，用一个空格隔开，表示一个区域的起始点 �*L* 和终止点 �*R* 的坐标，以及花费。\n\n输入样例:\n\n```txt\n500 3\n150 300 4\n100 200 20\n470 471 19\n```\n\n**输出描述:**\n\n输出包括一行，这一行只包含一个整数，所有的花费。\n\n**输出样例:**\n\n```txt\n2662\n```\n\n**样例:**\n\n**输入样例:**\n\n```txt\n3000 8\n150 1130 2\n1020 1200 3\n470 2071 1\n1123  211 6\n12 222 2\n13 23 2\n1  213 4\n1232  2523 6\n```\n\n**输出样例:**\n\n```txt\n2662\n```\n\n**运行限制:**\n\n```txt\n1. 最大运行时间：1s\n2. 最大运行内存：128M\n```\n\n**题目解析：**\n\n1. 利用�[�]=�[�]−�[�−1]*b*[*i*]=*a*[*i*]−*a*[*i*−1] 差分式。\n\n   这里由于开始时都是 00，可以用，但是用完都还是 00，所以没有意义，所以直接跳过即可。\n\n2. 依次读入区间的值，然后将对于区间的操作转化为对于区间端点操作加减。 由于我们从 11 开始，所以数目整体区间要右移 11 位。\n\n   对于每个 [�,�][*l*,*r*] 区间的加减操作都转化为对端点 �,�+1*l*,*r*+1 的操作。\n\n3. 差分还原(前缀和)。\n\n```cpp\nfor (int i = 1; i < n; i++)\n     b[i] = a[i] - a[i - 1]\n```\n\n差分算法解决区间加减问题通用框架如下：\n\n```cpp\n//读入原始数据 n,m,a\n\n输入n,m\n\nfor(int i=1;i<=n;i++){\n\n    输入a[i]\n}\n\n//差分\nfor(int i=1;i<=n;i++)\n\n    b[i]=a[i]-a[i-1]\n\n//区间操作\nwhile(m--)\n{\n    输入l,r,value\n    b[l]+value\n    b[r+1]-value\n}\n\n//前缀和还原\nfor(int i=1;i<n;i++)\n\n    b[i]=b[i]+b[i-1]\n```\n\n#### 答案解析 ####\n\nC++ 代码：\n\n```cpp\n#include <iostream>\nusing namespace std;\nint b[100005];\nint main()\n{\n    int n; //n层\n    int m; // m个区间\n    cin >> n >> m;\n\n    while (m--)\n    {\n        int l, r, value;\n        cin >> l >> r >> value;\n        b[l+1] += value;\n        b[r + 1+1] -= value;\n    }\n    for (int i = 1; i <= n; i++)\n        b[i] = b[i] + b[i - 1];\n    int sum = 0;\n    for (int i = 1; i <= n; i++)\n        sum += b[i];\n    /*\n    也可以一次性搞定\n    int sum=b[1];\n    for(int i=1; i<=n; i++){\n    b[i]=b[i]+b[i-1];\n    sum+=b[i]\n    }\n    */\n    cout << sum << endl;\n}\n```\n\n**Python 解题代码**\n\n递推算法代码：\n\n```py\nb = [0] * 100005\n\nif __name__ == '__main__':\n\n    nm = input().split()\n    n = int(nm[0])\n    m = int(nm[1])\n    while (m > 0):\n        m -= 1\n        lrv = input().split()\n        l = int(lrv[0])\n        r = int(lrv[1])\n        value = int(lrv[2])\n        b[l+1] += value\n        b[r + 1+1] -= value\n\n    for i in range(1, n+1):\n        b[i] = b[i - 1] + b[i]\n    sum = 0\n    for i in range(1,n+1):\n        sum += b[i]\n    print(sum)\n\n    #或者一次性解决\n    # sum = a[0]\n    #\n    # for i in range(1, n+1):\n    #\n    #     a[i] = a[i - 1] + a[i]\n    #\n    #     sum += a[0]\n    # print(sum)\n```\n\n**Java 解题代码**\n\n```java\nimport java.util.Scanner;\npublic class Main {\n  static int b[]=new int [100005];\n  public static void main(String[] args) {\n      Scanner in = new Scanner(System.in);\n      int n; //n层\n      int m; // m个区间\n      n = in.nextInt();\n      m = in.nextInt();\n      while(m>0)\n      {\n          m--;\n          int l,r,value ;\n          l = in.nextInt();\n          r = in.nextInt();\n          value = in.nextInt();\n          b[l+1]+=value;\n          b[r+1+1]-=value;\n      }\n      for(int i=1; i<=n; i++)\n          b[i]=b[i]+b[i-1];\n\n      int sum=0;\n      for(int i=1;i<=n;i++)\n          sum+=b[i];\n  /*\n\n  也可以一次性搞定\n  int sum=a[0];\n  for(int i=1; i<n; i++){\n  a[i]=a[i]+a[i-1];\n  sum+=a[i]\n  }\n  */\n      System.out.println(sum);\n  }\n}\n```\n\n## 前缀和 ##\n\n前缀和法的应用主要也是用于处理区间问题。\n\n前缀和是指某序列的前 �*n* 项和，可以把它理解为数学上的数列的前 �*n* 项和。当对于某一数组区间进行多次询问，[�,�][*L*,*r*] 的和时，如果正常处理，那么我们每次都要 [�,�][*l*,*r*]。查询 �*N* 次，那么时间复杂度也是 �(��)*O*(*n**m*) 也是平方阶的。\n\n如果我们采用前缀和，构造出一个前缀和数组，通过对于端点的值的减法操作就能 �(1)*O*(1) 的求出 [�,�][*l*,*r*] 的和。然后 �*N* 次查询的，就将复杂度降低为 �(�)*O*(*n*)。\n\n同差分一样，感觉操作变得更加复杂了，但是只用对端点值的操作确实比一整个区间相加的方法要优秀的多。听到这里大家很期待了，我们接着进行讲解。\n\n**前缀和的特点：**\n\n1. 将对于区间的求和操作转化为对于端点值的减法的操作；\n2. 区间求和操作的时间复杂度为 �(1)*O*(1)；\n3. 数组存放时要从 11 开始；\n4. 前缀和数组比原来的数组序列多一个数，第 00 个元素为 00。\n\n**前缀和算法解题的基本思路：**\n\n1. 利用 sum[�]=�[�]+sum[�−1]sum[*i*]=*a*[*i*]+sum[*i*−1] 差分式；\n2. 从第 1 项到 �*n* 项，且第 00 项无数据默认为 00；\n3. 对于区间求和的操作转化为端点值相减。\n\n**前缀和的一般解题过程：**\n\n```txt\n首先假设有一个数组：\n\n1 2 3 4 5 7 2\n\n前缀和后：\n\n0 1 3 6 10 15 22 24\n\n一般应用场景：\n\n让你对区间 [l,r] 求和操作N次\n\n如：\n\n从第二个元素到第五个元素的和\n从第二个元素到第四个元素的和\n从第一个元素到第三个元素的和\n....\n\n这里我们先演示前三个：\n\n对于每个 [l,r] 区间的求和操作转化为区间端点的加减操作\n\nsum[l,r] =[r]-[l-1]\n\n从第二个元素到第五个元素的和：\n\n转化为：[5]-[1]\n\n那么Sum[2,5]=[5]-[1]=14\n\n且 2+3+4+5=14\n\n确实是相等的，就是这么神奇。\n\n我们继续操作：\n\n从第二个元素到第四个元素的和\n\n转化为：[4]-[1]\n\n那么Sum[2,4]=[4]-[1]=9\n\n且 2+3+4=9\n\n我们继续操作：\n\n从第一个元素到第三个元素的和\n\n转化为：[3]-[0]\n\n那么Sum[1,3]=[3]-[0]=6\n\n且 1+2+3=6\n\n符合题意，验证结束，咱么做个题目看一看\n```\n\n### 大学里的树木要维护 ###\n\n**题目描述:**\n\n教室外有 �*N* 棵树，根据不同的位置和树种，学校已经对其进行了多年的维护。因为树的排列成线性，且非常长，我们可以将它们看作一条直线给他们编号。\n\n树的编号从 1−�1−*N* 且 �<1�6*N*<1*e*6。由于已经维护了多年，每一个树都由学校的园艺人员进行了维护费用的统计。\n\n每棵树的前期维护费用各不相同，但是由于未来需要要打药，所以有些树木的维护费用太高的话，就要重新种植。由于维护费用也称区间分布，所以常常需要统一个区间里的树木的维护开销。\n\n现在园艺人员想知道，某个区间内的树木维护开销是多少。共计 �*M* 个区间需要查询。\n\n**输入描述:**\n\n每组输入的第一行有两个整数 �（1<=�<=1000000）*N*（1<=*N*<=1000000）和 �（1<=�<=100000）*M*（1<=*M*<=100000）。\n\n�*N* 代表马路的共计多少棵树，�*M* 代表区间的数目，�*N* 和 �*M* 之间用一个空格隔开。接下来的一行，包含 �*N* 个数，每个数之间用空格隔开。\n\n接下来的�*M*行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点�*L*和终止点�*R*的坐标。\n\n**输入样例:**\n\n```txt\n10 3\n7 5 6 4 2 5 0 8 5 3\n1 5\n2 6\n3 7\n```\n\n**输出描述:**\n\n输出包括 �*M* 行，每一行只包含一个整数，所有的花费。\n\n**输出样例:**\n\n```txt\n24\n22\n17\n```\n\n**样例:**\n\n<details style=\"box-sizing: border-box; display: block; margin-bottom: 16px; margin-top: 0px; color: rgb(36, 41, 46); font-family: &quot;Helvetica Neue&quot;, Arial, &quot;Hiragino Sans GB&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, Song, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"box-sizing: border-box; touch-action: manipulation; display: list-item; cursor: pointer; outline: none;\">输入样例</summary><pre style=\"box-sizing: border-box; font-family: SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; font-size: 14px; margin-bottom: 1rem; margin-top: 0px; overflow: visible; color: rgb(33, 37, 41); display: block; position: relative; word-break: break-all; border-radius: 4px; white-space: pre-wrap;\"><code class=\"language-txt hljs plaintext\" style=\"box-sizing: border-box; font-family: &quot;Source Code Pro&quot;, Consolas, monospace; font-size: inherit; overflow-wrap: break-word; color: rgb(248, 248, 242); word-break: normal; background: rgb(35, 36, 31); display: block; overflow-x: auto; padding: 0.5em;\"></code><div class=\"btn-copy\" style=\"box-sizing: border-box; align-items: center; cursor: pointer; display: flex; flex-direction: column; opacity: 0; position: absolute; right: 8px; top: 8px; transition: opacity 0.3s linear 0s; white-space: normal; width: 18px; word-break: normal;\"><img class=\"icon-copy\" title=\"copy\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAALCElEQVR4Xu2dXchlZRXH/+uiyDAV7SIm+pg+MBvxow9IpNTArFCbQrS6iKhJ+zCwspu8UKOb6MML+8BREypTCCslI6xw1IiCbMopSTCxEiSKagy8qIsVD52hSXrfs85+zrP3c/b6bTjMxbvW86z1X//fu8857569TRwogAJbKmBogwIosLUCAII7UGAbBQAEe6AAgOABFBimAGeQYbqRlUQBAEkyaNocpgCADNONrCQKAEiSQdPmMAUAZJhuZCVRAECSDJo2hykAIMN0IyuJAgCSZNC0OUwBABmmG1lJFOgGEHc/RdJuScce9joiyRx6bfMOSfea2f29Fti6rkkBcfcTJF0s6WxJu1o3y/qDFfi4mX12cPYGJ04CiLs/Q9LHJF0u6ZgN1i9T6a81sx9narj0Ojog7n6upE9KOjWb2Bve78/M7DUb3sPK5Y8KiLt/SNIXVq6ShF4U2Glmj/ZSzBh1jAaIu39A0pfGaIo9mikAIC2kdffXSbqnxdqsOZoCB8zspNF262Sj5mcQdz9R0p2Snt9Jz5QxTIGrzeyqYambmzUGINctvsrdXJWo/JtmdmFGGZoC4u6vlPTzgcI+IukPA3NJW48CZQY/MrNvrGe5zVulNSCrnj3uk3STpPvM7OHNk5OK56ZAM0DcvVwm8tjispGIbinf40aEIWY6BVoC8jZJtwVb22FmjwdjCUOB0RRoCcj1kvYEOuHMERCJkGkUaAnIAUnlK97tjiclvYSzxzTDZ9flCrQE5J+SnrakhP1m9orlZRKBAtMo0AQQd3+RpN8FWrrFzN4ZiCMEBSZRoBUgZ0q6O9ARnz8CIhEynQIAMp327LwBCgDIBgyJEqdTAECm056dN0ABANmAIVHidAoAyHTas/MGKAAgGzAkSpxOAQCZTnt23gAFUgLi7i+XVP6vyvGSXibpuA2Y1ZxLLJccPXToZWb7emk2DSDu/kZJZ0g6j5vU9WK/Lev48+JK8HvM7NYpq509IO5+uqQPS7poSqHZe7AC5bane81s7+AVKhJnDYi7f17SRyr0IbUfBQool4/99mu2gLj7TySd1s98qWQNCvxL0hvGhGSWgLi7r2EYLNGvArvM7MExypsdIO5+syQuoR/DPdPuMQokswLE3T8l6Ypp58buIynwG0kXtj6TzAYQd399uYfTSMNhmz4UKN9uXdKylDkBUm5v+uaWYrF2lwq8quUTsGYBiLu/V9INK4zvL5I+LekBSb8ysz+tkEvomhVw9yMllRtjl1d54tgqz45pehaZCyB3LR7jFhlduXvjbjP7aySYmPEVcPdV5nlQ0gvMrPy79mPjAXH3561wD9/bzOyCtavIgmtXwN2vkXRZcOF3mdnXgrErhc0BkEslXRvsmjs4BoXqIczd90sqTz9edjT7xTcHQD4n6aPLFJTEHVQCIvUU4u7nS7o9UNMvzKxcnb32Yw6AlLvBvzugzDlmVt7bcmyIAu7+dEnlyt6jlpT8qJntbNHWHAApD7svl7BvdzxhZke3EJA12yrg7t+XdM5U850DIOUGdeVGddsd+8zsrLajZPUWCrh7eezblcvWNrMmXm6yqLuPdmdFdweQZe7Z4J8DSOWDIQFkg90fKB1AACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whcwXkKEkHA2M9z8y+G4jbMsTd75Z05pI19pnZWTX7kDuNArMEpEjp7rdLOn+JrDvM7PEa6QGkRr3+c+cMSPmtXn67b3XsNbNLakcEILUK9p0/W0AWZ5H3S/qMpCOfMoarrfKzx6H1AKRvg9dWN2tAFpCcLOlUSS+U9EdJvzezH9YKByDrUrDvdWYPSGv5OYO0Vnja9QGkUn8AqRSw83QAqRwQgFQK2Hk6gFQOCEAqBew8HUAqBwQglQJ2ng4glQMCkEoBO08HkMoBAUilgJ2nA0jlgACkUsDO0wGkckAAUilg5+kAUjkgAKkUsPN0AKkcEIBUCth5OoBUDghAKgXsPB1AKgcEIJUCdp4OIJUDApBKATtPB5DKAQFIpYCdpwNI5YAApFLAztMBpHJAAFIpYOfpAFI5IACpFLDzdACpHBCAVArYeTqAVA4IQCoF7DwdQCoH5O53STp7yTKPmNmLK7cifQIF3P0aSZct2fqgmR3TojxrseiYa7r7LZLeHtjzpWb2cCCOkI4UcPf9kk5ZUtIBMzupRdlzAORaSZcGxHmPmd0UiCOkEwXc/XhJvw2Uc6eZnRuIWzlkDoBcJenKQOc/NbPTAnGEdKKAu18n6eJAOWu5S+f/22cOgJTTbzkNR44bzOx9kUBiplXA3d8k6XvBKtZ2p86n7rfxgJSG3P3XknYFxXyHmd0ajCVsAgXc/URJB4JbPynp5FafL+cCSOSbjsP1/qqkvZIeMLN/BAdBWGMF3L3covYCSZ9YYavrzSzyNmyFJf8bOhdAyle490raMUCFhyRVPYJhwJ6k/K8Cz5J0gqRnDhDmDDMrs29yzAKQxdusD0r6YhOVWLRXBb5jZm9tWdxsAFlA8m1Ju1sKxtrdKPB3Saeb2YMtK5obIM9efLh7TkvRWLsLBfaY2Y2tK5kVIIuzSHkeyS9bC8f6kypwo5ntGaOC2QGygKR8aL9f0tFjiMgeoyrwZTMrnzdHOWYJyAKSYyV9RdJbRlGSTVor8DdJF5nZD1pvdPj6swXkUJPufoWk8jpiTGHZa60KfKtc0Wtm5RF+ox6zB2RxNnn1AhLOJqPaq2qz8hfymyV9veXfOZZVmAKQw84mz5VUrvEpr52Syrdexw38A9Uybfl5XIEnFg94fUzSoVcBY/L/npAKkPi8iESB/ygAIDgBBbZRAECwBwoACB5AgWEKcAYZphtZSRQAkCSDps1hCgDIMN3ISqIAgCQZNG0OUwBAhulGVhIFACTJoGlzmAIAMkw3spIoACBJBk2bwxQAkGG6kZVEAQBJMmjaHKbAvwGyE7Iy90AbtwAAAABJRU5ErkJggg==\" style=\"box-sizing: initial; border-style: none; vertical-align: middle; max-width: 100%; background: rgb(35, 35, 30); border-radius: 4px;\"></div></pre></details>\n\n<details style=\"box-sizing: border-box; display: block; margin-bottom: 16px; margin-top: 0px; color: rgb(36, 41, 46); font-family: &quot;Helvetica Neue&quot;, Arial, &quot;Hiragino Sans GB&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, Song, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"box-sizing: border-box; touch-action: manipulation; display: list-item; cursor: pointer; outline: none;\">输出样例</summary><pre style=\"box-sizing: border-box; font-family: SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; font-size: 14px; margin-bottom: 1rem; margin-top: 0px; overflow: visible; color: rgb(33, 37, 41); display: block; position: relative; word-break: break-all; border-radius: 4px; white-space: pre-wrap;\"><code class=\"language-txt hljs plaintext\" style=\"box-sizing: border-box; font-family: &quot;Source Code Pro&quot;, Consolas, monospace; font-size: inherit; overflow-wrap: break-word; color: rgb(248, 248, 242); word-break: normal; background: rgb(35, 36, 31); display: block; overflow-x: auto; padding: 0.5em;\"></code><div class=\"btn-copy\" style=\"box-sizing: border-box; align-items: center; cursor: pointer; display: flex; flex-direction: column; opacity: 0; position: absolute; right: 8px; top: 8px; transition: opacity 0.3s linear 0s; white-space: normal; width: 18px; word-break: normal;\"><img class=\"icon-copy\" title=\"copy\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAALCElEQVR4Xu2dXchlZRXH/+uiyDAV7SIm+pg+MBvxow9IpNTArFCbQrS6iKhJ+zCwspu8UKOb6MML+8BREypTCCslI6xw1IiCbMopSTCxEiSKagy8qIsVD52hSXrfs85+zrP3c/b6bTjMxbvW86z1X//fu8857569TRwogAJbKmBogwIosLUCAII7UGAbBQAEe6AAgOABFBimAGeQYbqRlUQBAEkyaNocpgCADNONrCQKAEiSQdPmMAUAZJhuZCVRAECSDJo2hykAIMN0IyuJAgCSZNC0OUwBABmmG1lJFOgGEHc/RdJuScce9joiyRx6bfMOSfea2f29Fti6rkkBcfcTJF0s6WxJu1o3y/qDFfi4mX12cPYGJ04CiLs/Q9LHJF0u6ZgN1i9T6a81sx9narj0Ojog7n6upE9KOjWb2Bve78/M7DUb3sPK5Y8KiLt/SNIXVq6ShF4U2Glmj/ZSzBh1jAaIu39A0pfGaIo9mikAIC2kdffXSbqnxdqsOZoCB8zspNF262Sj5mcQdz9R0p2Snt9Jz5QxTIGrzeyqYambmzUGINctvsrdXJWo/JtmdmFGGZoC4u6vlPTzgcI+IukPA3NJW48CZQY/MrNvrGe5zVulNSCrnj3uk3STpPvM7OHNk5OK56ZAM0DcvVwm8tjispGIbinf40aEIWY6BVoC8jZJtwVb22FmjwdjCUOB0RRoCcj1kvYEOuHMERCJkGkUaAnIAUnlK97tjiclvYSzxzTDZ9flCrQE5J+SnrakhP1m9orlZRKBAtMo0AQQd3+RpN8FWrrFzN4ZiCMEBSZRoBUgZ0q6O9ARnz8CIhEynQIAMp327LwBCgDIBgyJEqdTAECm056dN0ABANmAIVHidAoAyHTas/MGKAAgGzAkSpxOAQCZTnt23gAFUgLi7i+XVP6vyvGSXibpuA2Y1ZxLLJccPXToZWb7emk2DSDu/kZJZ0g6j5vU9WK/Lev48+JK8HvM7NYpq509IO5+uqQPS7poSqHZe7AC5bane81s7+AVKhJnDYi7f17SRyr0IbUfBQool4/99mu2gLj7TySd1s98qWQNCvxL0hvGhGSWgLi7r2EYLNGvArvM7MExypsdIO5+syQuoR/DPdPuMQokswLE3T8l6Ypp58buIynwG0kXtj6TzAYQd399uYfTSMNhmz4UKN9uXdKylDkBUm5v+uaWYrF2lwq8quUTsGYBiLu/V9INK4zvL5I+LekBSb8ysz+tkEvomhVw9yMllRtjl1d54tgqz45pehaZCyB3LR7jFhlduXvjbjP7aySYmPEVcPdV5nlQ0gvMrPy79mPjAXH3561wD9/bzOyCtavIgmtXwN2vkXRZcOF3mdnXgrErhc0BkEslXRvsmjs4BoXqIczd90sqTz9edjT7xTcHQD4n6aPLFJTEHVQCIvUU4u7nS7o9UNMvzKxcnb32Yw6AlLvBvzugzDlmVt7bcmyIAu7+dEnlyt6jlpT8qJntbNHWHAApD7svl7BvdzxhZke3EJA12yrg7t+XdM5U850DIOUGdeVGddsd+8zsrLajZPUWCrh7eezblcvWNrMmXm6yqLuPdmdFdweQZe7Z4J8DSOWDIQFkg90fKB1AACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whAAIged0f6BxAACRgk7whcwXkKEkHA2M9z8y+G4jbMsTd75Z05pI19pnZWTX7kDuNArMEpEjp7rdLOn+JrDvM7PEa6QGkRr3+c+cMSPmtXn67b3XsNbNLakcEILUK9p0/W0AWZ5H3S/qMpCOfMoarrfKzx6H1AKRvg9dWN2tAFpCcLOlUSS+U9EdJvzezH9YKByDrUrDvdWYPSGv5OYO0Vnja9QGkUn8AqRSw83QAqRwQgFQK2Hk6gFQOCEAqBew8HUAqBwQglQJ2ng4glQMCkEoBO08HkMoBAUilgJ2nA0jlgACkUsDO0wGkckAAUilg5+kAUjkgAKkUsPN0AKkcEIBUCth5OoBUDghAKgXsPB1AKgcEIJUCdp4OIJUDApBKATtPB5DKAQFIpYCdpwNI5YAApFLAztMBpHJAAFIpYOfpAFI5IACpFLDzdACpHBCAVArYeTqAVA4IQCoF7DwdQCoH5O53STp7yTKPmNmLK7cifQIF3P0aSZct2fqgmR3TojxrseiYa7r7LZLeHtjzpWb2cCCOkI4UcPf9kk5ZUtIBMzupRdlzAORaSZcGxHmPmd0UiCOkEwXc/XhJvw2Uc6eZnRuIWzlkDoBcJenKQOc/NbPTAnGEdKKAu18n6eJAOWu5S+f/22cOgJTTbzkNR44bzOx9kUBiplXA3d8k6XvBKtZ2p86n7rfxgJSG3P3XknYFxXyHmd0ajCVsAgXc/URJB4JbPynp5FafL+cCSOSbjsP1/qqkvZIeMLN/BAdBWGMF3L3covYCSZ9YYavrzSzyNmyFJf8bOhdAyle490raMUCFhyRVPYJhwJ6k/K8Cz5J0gqRnDhDmDDMrs29yzAKQxdusD0r6YhOVWLRXBb5jZm9tWdxsAFlA8m1Ju1sKxtrdKPB3Saeb2YMtK5obIM9efLh7TkvRWLsLBfaY2Y2tK5kVIIuzSHkeyS9bC8f6kypwo5ntGaOC2QGygKR8aL9f0tFjiMgeoyrwZTMrnzdHOWYJyAKSYyV9RdJbRlGSTVor8DdJF5nZD1pvdPj6swXkUJPufoWk8jpiTGHZa60KfKtc0Wtm5RF+ox6zB2RxNnn1AhLOJqPaq2qz8hfymyV9veXfOZZVmAKQw84mz5VUrvEpr52Syrdexw38A9Uybfl5XIEnFg94fUzSoVcBY/L/npAKkPi8iESB/ygAIDgBBbZRAECwBwoACB5AgWEKcAYZphtZSRQAkCSDps1hCgDIMN3ISqIAgCQZNG0OUwBAhulGVhIFACTJoGlzmAIAMkw3spIoACBJBk2bwxQAkGG6kZVEAQBJMmjaHKbAvwGyE7Iy90AbtwAAAABJRU5ErkJggg==\" style=\"box-sizing: initial; border-style: none; vertical-align: middle; max-width: 100%; background: rgb(35, 35, 30); border-radius: 4px;\"></div></pre></details>\n\n**运行限制:**\n\n```txt\n1. 最大运行时间：1s\n2. 最大运行内存：128M\n```\n\n**题目解析：**\n\n1. 利用���[�]=�[�]+���[�−1]*s**u**m*[*i*]=*a*[*i*]+*s**u**m*[*i*−1] 前缀和式在输入时求出前缀和；\n2. 依次读入区间的值，然后将对于区间的求和操作转化为对于区间端点操作加减，对于每个 [l,r] 区间的求和操作都转化为对端点[r]-[l-1]的操作。\n3. 输出答案。\n\n**前缀和一般解题过程：**\n\n```cpp\n输 入 N 和 M\n\n输入 N 个值 并计算前缀和\nfor( int i=1;i<=N;i++)\n    输入a[i]\n    并计算sum[i]=sum[i-1]+a[i]\n\n输入 M 个区间，计算结果\n\nwhile(M)\n    M-=1\n    输入 L , R\n    计算 [r]-[l-1]，并输出\n```\n\n#### 答案解析 ####\n\nC++ 代码：\n\n```cpp\n#include <iostream>\nusing namespace std;\nint a[100005];\nint sum[100005];\n\n\nint main()\n{\n    int n;\n    int m;\n    cin >> n >> m;\n\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        sum[i] = a[i] + sum[i - 1];\n    }\n\n    while (m > 0)\n    {\n        m -= 1;\n        int l, r;\n        cin >> l >> r;\n        cout << sum[r] - sum[l - 1] << endl;\n    }\n}\n```\n\n这个代码有个问题，虽然是能通过的，但是他是一个输入对应一个输出的，我们之前讲过，这对大部分的测评机是没问题。\n\n终端输出：\n\n```txt\n10 3\n7 5 6 4 2 5 0 8 5 3\n1 5\n24\n2 6\n22\n3 7\n17\n\nProcess returned 0 (0x0)   execution time : 1.741 s\nPress any key to continue.\n```\n\n但是如果有想要规规矩矩的处理，或者说题目要求必须全部读入后输出。我们可这样操作。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint a[100005];\nint sum[100005];\nvector<int>ss;\nint main()\n{\n\n    int n ;\n    int m;\n    cin>>n>>m;\n\n    for(int i=1;i<=n;i++)\n    {\n        cin>>a[i];\n        sum[i]=a[i]+sum[i-1];\n\n    }\n\n    while(m>0)\n    {\n        m-=1;\n        int l,r;\n        cin>>l>>r;\n        ss.push_back(sum[r]-sum[l-1]);\n    }\n\n    for(auto sss:ss) cout<<sss<<endl;\n}\n```\n\n终端输出：\n\n```txt\n10 3\n7 5 6 4 2 5 0 8 5 3\n1 5\n2 6\n3 7\n24\n22\n17\n\nProcess returned 0 (0x0)   execution time : 6.235 s\nPress any key to continue.\n```\n\n都可以，大家看自己需求和心情选择即可。\n\n**Python 解题代码**\n\n普通代码：\n\n```python\na = [0] * 100005\nsum1 = [0] * 100005\nif __name__ == '__main__':\n\n    nm = input().split()\n    n = int(nm[0])\n    m = int(nm[1])\n    a = input().split()\n    a = list(map(int, a))\n    # split 分割后都是 字符 这里是转化成数字\n    #print(a)\n    for i in range(1, n + 1):\n        # print(i)\n        sum1[i] = sum1[i - 1]\n        sum1[i] += a[i - 1]  # 分割完后，a[]是从0开始,所以要减1\n\n    while m > 0:\n\n        m -= 1\n        lrv = input().split()\n        l = int(lrv[0])\n        r = int(lrv[1])\n        print(sum1[r] - sum1[l - 1])\n```\n\n特殊代码：\n\n```python\na = [0] * 100005\nsum1 = [0] * 100005\nif __name__ == '__main__':\n\n    nm = input().split()\n    n = int(nm[0])\n    m = int(nm[1])\n    a = input().split()\n\n    a = list(map(int, a))\n    # split 分割后都是 字符 这里是转化成数字\n    # print(a)\n    for i in range(1, n + 1):\n        # print(i)\n        sum1[i] = sum1[i - 1]\n        sum1[i] += a[i - 1]  # 分割完后，a[]是从0开始,所以要减1\n\n    ans = []\n    while m > 0:\n\n        m -= 1\n        lrv = input().split()\n        l = int(lrv[0])\n        r = int(lrv[1])\n        ans.append(sum1[r] - sum1[l - 1])\n\n    for i in ans:\n        print(i)\n```\n\n**Java 解题代码**\n\n普通算法：\n\n```java\nimport java.util.Scanner;\npublic class Main {\n\n    static int a[]=new int [100005];\n    static int sum[]=new int [100005];\n\n    public static void main(String[] args) {\n\n        Scanner in = new Scanner(System.in);\n        int n; //n层\n        int m; // m个区间\n        n = in.nextInt();\n        m = in.nextInt();\n\n        for(int i=1;i<=n;i++)\n        {\n            a[i]= in.nextInt();\n            sum[i]=a[i]+sum[i-1];\n\n        }\n\n        while(m>0)\n        {\n            m--;\n            int l,r;\n            l = in.nextInt();\n            r = in.nextInt();\n            System.out.println((sum[r]-sum[l-1]));\n        }\n    }\n}\n```\n\n特殊代码：\n\n```java\nimport java.util.Scanner;\nimport java.util.Vector;\n\npublic class Main {\n\n\n    static int a[]=new int [100005];\n    static int sum[]=new int [100005];\n    static Vector ans=new Vector<Integer>();\n\n    public static void main(String[] args) {\n\n        Scanner in = new Scanner(System.in);\n\n        int n; //n层\n        int m; // m个区间\n        n = in.nextInt();\n        m = in.nextInt();\n\n        for(int i=1;i<=n;i++)\n        {\n             a[i]= in.nextInt();\n            sum[i]=a[i]+sum[i-1];\n\n        }\n\n        while(m>0)\n        {\n            m--;\n            int l,r;\n            l = in.nextInt();\n            r = in.nextInt();\n            ans.addElement(sum[r]-sum[l-1]);\n        }\n\n        for(Object ab:ans){\n            System.out.println(ab);\n        }\n    }\n}\n```\n\n### 总结 ###\n\n我们这节课讲了差分和前缀和的知识点，并且也讲了怎样使用差分，怎样使前缀和，也讲了差分和前缀和最常见的两种情况。\n\n差分和前缀和是很多思维题的解题技巧，必须要掌握熟练才能拿到简单题目的全部分数。\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯冲刺营","5.差分与前缀和"]},{"title":"枚举和尺取法","url":"/2024/02/22/枚举和尺取法/","content":"\n# 枚举法与尺取法 #\n\n在之前的课程中，我们深入讨论了打表法与模拟法的暴力解法。提到暴力，我们通常会首先想到枚举。然而，枚举实际上是一门技术，要确保能够穷尽所有可能的情况并不容易。因此，在本节课中，我们将详细介绍枚举法的技巧，以确保能够完整地列举出所有情况，不漏一种。\n\n#### 知识点 ####\n\n- 枚举法\n  - 简单型枚举\n  - 组合型枚举\n  - 排列型枚举\n  - 指数型枚举\n- 尺取算法\n\n## 枚举法 ##\n\n**枚举算法的思想：**\n\n枚举算法的核心思想是将问题的所有可能成为答案的解一一列举，然后根据问题给定的条件判断这些解是否合适。对于符合条件的解，保留；反之则舍弃。\n\n**枚举算法解题的基本思路：**\n\n1. **确定枚举解的范围和判断条件：** 在开始解题之前，需要明确枚举的解范围，并定义问题的判断条件。\n2. **选取合适的枚举方法：** 选择适当的枚举方式进行逐一枚举，确保覆盖所有可能的解。避免遗漏任何真正的解，同时注意防止重复。\n3. **使用判断条件检验解：** 在枚举过程中，应用事先确定的判断条件验证每个解的合法性，保留符合要求的解。\n\n**枚举算法的一般步骤：**\n\n1. **确定范围和枚举方式：** 根据题目确定枚举的范围，并选择合适的枚举方式。确保不遗漏任何真正的解，同时避免重复。\n2. **优化解空间：** 查看是否存在优化的可能性，以缩小可能成为解的答案范围，提高解决问题的效率。\n3. **定义准确验证条件：** 根据问题找到准确、易编码的验证条件，用于检验每个可能的解。\n4. **枚举和判断：** 逐一枚举解并验证是否符合事先确定的条件，保留符合条件的解。\n5. **输出结果：** 按照要求输出枚举过程中留下的符合条件的解。\n\n枚举法包含多种技巧和方法，本节课将深入探讨其中几种方法。\n\n### 简单型枚举 ###\n\n简单型枚举是通过简单的 `for` 循环嵌套解决的问题类型。在之前的课程中，我们所讨论的题目通常属于简单型枚举的范畴。因此，简单型枚举是一种相对简单且大家接触最多的枚举方式。\n\n这种枚举方式没有特定的固定枚举模式，而且相对简单。只需按照题目的要求设计代码即可完成解题。\n\n让我们通过一个示例题目来复习一下。\n\n### 42 点问题 ###\n\n**题目描述:**\n\n众所周知在扑克牌中，有一个老掉牙的游戏叫做 2424 点，选取 44 张牌进行加减乘除，看是否能得出 2424 这个答案。\n\n现在小蓝同学发明了一个新游戏，他从扑克牌中依次抽出 66 张牌，注意不是一次抽出，进行计算，看是否能够组成 4242 点，满足输出 *Y**E**S*，反之输出 *N**O*。\n\n最先抽出来的牌作为第一个操作数，抽出牌做第二个操作数，运算结果在当作第一个操作数，继续进行操作。\n\n除不尽的情况保留整数。\n\n请设计一个程序对该问题进行解答。\n\n**样例:**\n\n```txt\n输入：\n\nK A Q 6 2 3\n\n输出：\n\nYES\n```\n\n对于上面的样例我们进行了如下计算；\n\n```txt\n1. K*A=K 即 13*1=13\n2. 13/12=1 保留整数\n3. 1+6=7\n4. 7*2=14\n5. 14*3=42\n```\n\n**运行限制:**\n\n```txt\n最大运行时间：1s\n最大运行内存: 128M\n```\n\n**题目解析：**\n\n这个题目我们可以依次枚举数字，然后在枚举数字间的符号即可。由于到结果之间进行了三步计算，所以我们这里需要进行一个递归操作，利用了上节课讲解的知识。\n\n两重循环即可解决问题，伪代码如下：\n\n```txt\nop1 赋值为 第一个数\n\nop(op[1] op[2])\n{\n\n    for op in [+ - * /]\n       ans = 第一个操作数op1 操作 第二个操作数op2\n\n        如果是第六个操作数，就检验是否符合要要求 ==42？ 如果是就返回True\n\n        如果op(ans , op[3]) 返回 True，就返回True 因为找到了答案，否则就继续进行\n\n    没有找到答案返回False\n}\n```\n\n但是这样写，思路感觉很清晰，写起来却非常的复杂，我们使用我们讲过的 `Vector` 来优化这个枚举方式。\n\n我们创建 5 个 `Vector` ，分别用来存放 1−51−5 次的运算结果，非常简单。我们答案就采用这种方式。\n\n#### 答案解析 ####\n\nC++ 代码：\n\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nint a[10];\nvector <int> ans[10];\nint main()\n{\n    for(int i=0; i<6; i++)\n    {\n        char c;\n        cin>>c;\n        if(c=='A')\n            a[i]=1;\n        else if(c=='J')\n            a[i]=11;\n        else if(c=='Q')\n            a[i]=12;\n        else if(c=='K')\n            a[i]=13;\n        else\n            a[i]=(c-'0');\n        //cout<<a[i]<<endl;\n    }\n    ans[0].push_back(a[0]);\n    for(int i=1; i<=5; i++)\n    {\n        for(int j=0; j<ans[i-1].size(); j++)\n        {\n            ans[i].push_back(ans[i-1][j]+a[i]);\n            ans[i].push_back(ans[i-1][j]-a[i]);\n            ans[i].push_back(ans[i-1][j]*a[i]);\n            ans[i].push_back(ans[i-1][j]/a[i]);\n        }\n    }\n    //cout<<ans[5].size()<<endl;\n    int flag=0;\n    for(int i=0; i<ans[5].size(); i++)\n    {\n        if(ans[5][i]==42)\n        {\n            flag=1;\n            break;\n        }\n    }\n    if(flag==1)\n        cout<<\"YES\"<<endl;\n    else\n        cout<<\"NO\"<<endl;\n}\n```\n\n**Python 解题代码**\n\n```python\nans = [[] for i in range(10)]\na = ['0']*10\nif __name__ == '__main__':\nc = input().split()\nfor i in range(6):\n    if c[i] == 'A':\n        a[i] = 1\n    elif c[i] == 'J':\n        a[i] = 11\n    elif c[i] == 'Q':\n        a[i] = 12\n    elif c[i] == 'K':\n        a[i] = 13\n    else:\n        a[i] = ord(c[i]) - ord('0')\n\nans[0].append(a[0])\nfor i in range(1, 6):\n    for j in range(len(ans[i - 1])):\n        ans[i].append(ans[i - 1][j] + a[i])\n        ans[i].append(ans[i - 1][j] - a[i])\n        ans[i].append(ans[i - 1][j] * a[i])\n        ans[i].append(int(ans[i - 1][j] / a[i]))\nflag = 0\nfor j in range(len(ans[5])):\n    if ans[5][j] == 42:\n        flag = 1\n        break\nif flag == 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```\n\n**Java 解题代码**\n\n```java\nimport java.util.Scanner;\nimport java.util.Vector;\n\npublic class Main {\n\n  static int[] a = new int[10];\n  static Vector<Vector<Integer>> ans = new Vector<Vector<Integer>>();\n  public static void main(String[] args) {\n      Scanner in = new Scanner(System.in);\n      for (int i = 0; i < 6; i++) {\n\n          String c;\n          c = in.next();\n\n//            System.out.println(c);\n\n          if (c.charAt(0) == 'A')\n              a[i] = 1;\n          else if (c.charAt(0) == 'J')\n              a[i] = 11;\n          else if (c.charAt(0) == 'Q')\n              a[i] = 12;\n          else if (c.charAt(0) == 'K')\n              a[i] = 13;\n          else\n              a[i] = (c.charAt(0) - '0');\n//            System.out.println(a[i]);\n      }\n      ans.addElement(new Vector<Integer>());\n      ans.get(0).addElement(a[0]);\n      for(int i=1; i<=5; i++)\n      {\n          ans.addElement(new Vector<Integer>());\n          for(int j = 0; j< ans.get(i - 1).size(); j++)\n          {\n              ans.get(i).addElement(ans.get(i - 1).get(j) +a[i]);\n              ans.get(i).addElement(ans.get(i - 1).get(j)-a[i]);\n              ans.get(i).addElement(ans.get(i - 1).get(j)*a[i]);\n              ans.get(i).addElement(ans.get(i - 1).get(j)/a[i]);\n          }\n      }\n      //cout<<ans[5].size()<<endl;\n      int flag=0;\n      for(int i = 0; i< ans.get(5).size(); i++)\n      {\n          if(ans.get(5).get(i)==42)\n          {\n              flag=1;\n              break;\n          }\n      }\n      if(flag==1)\n          System.out.println(\"YES\");\n      else\n          System.out.println(\" NO\");\n  }\n}\n```\n\n### 组合型枚举 ###\n\n排列组合是大家都接触过的概念，而组合型枚举则是在 *n* 个元素中随机选出 *m* 个元素的问题。对于每一种可能的选择方案，我们需要确定选择了哪 *m* 个元素，这就是组合型枚举。\n\n具体而言，组合型枚举解决的是 *C**n**m* 问题，即从 *n* 个元素中选择 *m* 个元素的组合数量。\n\n组合型枚举有一套固定的流程和算法模板，需要大家进行记忆。\n\n```python\nchosen = []\nn = 0\nm = 0\n\ndef calc(x):\n  if len(chosen) > m:\n      return\n  if len(chosen) + n - x + 1 < m:\n      return\n  if x == n + 1:\n      for i in chosen:\n          print(i,end=' ')\n      print('')\n      return\n\n  chosen.append(x)\n  calc(x + 1)\n  chosen.pop()\n  calc(x + 1)\n\nif __name__ == '__main__':\n\n  tem = input().split()\n  n = int(tem[0])\n  m = int(tem[1])\n  calc(1)\nimport java.util.Scanner;\nimport java.util.Vector;\npublic class Main {\n\n    static  int n;\n    static int m;//选m个数\n    static Vector<Integer> chosen = new Vector<Integer>();\n    static  void calc(int x) {\n        if (chosen.size() > m || chosen.size() + (n - x + 1) < m) //剪枝\n            return;\n        if (x == n + 1) { //选够了m个数输出\n            String ansTem = \"\";\n            for (int i = 0; i < chosen.size(); i++)\n                System.out.print(chosen.get(i)+\" \");\n            System.out.println(\"\");\n            return;\n        }\n        chosen.addElement(x);\n        calc(x + 1);\n        chosen.remove((Object)x);\n        calc(x + 1);\n    }\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        m = in.nextInt();\n        calc(1);\n    }\n}\n#include<bits/stdc++.h>\nusing namespace std;\nint n;//共计N个数\nint m;//选m个数\nvector<int> chosen;\nstring s[1000];\nvoid calc(int x) {\n    if (chosen.size() > m || chosen.size() + (n - x + 1) < m) //剪枝\n        return;\n    if (x == n + 1) { //选够了m个数输出\n        for (int i = 0; i < chosen.size(); i++)\n            cout<< s[chosen[i]]<<\" \";//也可以不输出，存放起来也是可以的，主要是看题目。\n        puts(\"\");\n        return;\n    }\n    chosen.push_back(x);\n    calc(x + 1);\n    chosen.pop_back();//消除痕迹\n    calc(x + 1);\n}\nint main()\n{\n    cin>>n>>m;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>s[i];\n    }\n    calc(1);\n}\n```\n\n大家有个疑虑，我这里全是数字而且是从 11 开始的能好用吗，我题目要是字母怎么办，那么请看下面的题目。\n\n### 公平抽签 ###\n\n**题目描述:**\n\n小 A 的学校，蓝桥杯的参赛名额非常有限，只有 *m* 个名额，但是共有 *n* 个人报名，其中 ≤*m*≤*n*。作为老师非常苦恼，他不知道该让谁去，他在寻求一个绝对公平的方式。于是他准备让大家抽签决定，即 *m* 个签是去，剩下的是不去。\n\n小 A 非常想弄明白最后的抽签结果是什么样子的，到底有多少种结果。\n\n请设计一个程序帮助小 A。最后输出各种情况的人名即可，一行一种情况，每种情况的名字按照报名即输入顺序排序。\n\n第一行 输入 ,*N*,*M*。\n\n第二行 到 第 +1*N*+1 行 共输入 *N* 个人名\n\n每种情况输出 *M* 个人名，空格隔开。\n\n**样例:**\n\n```txt\n输入：\n\n3  2\nxiaowang\nxiaoA\nxiaoli\n输出：\n\nxiaowang xiaoA\nxiaowang xiaoli\nxiaoA xiaoli\n```\n\n**运行限制:**\n\n```txt\n1. 最大运行时间：1s\n2. 最大运行内存：128M\n```\n\n**题目解析：**\n\n实际上还是组合型枚举，但是输出元素为人名，我们可以将人名存起来，输出的时候，根据数字下标找到提前存好的人名，直接输出即可。\n\n#### 答案解析 ####\n\nC++ 代码：\n\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n; //共计N个数\nint m; //选m个数\nvector<string> name;\nvector<string> ans;\nvector<int> chosen;\nvoid calc(int x)\n{\n\n    if (chosen.size() > m || chosen.size() + (n - x + 1) < m) //剪枝\n        return;\n\n    if (x == n + 1)\n    { //选够了m个数输出\n        string ansTem = \"\";\n        for (int i = 0; i < chosen.size(); i++)\n            ansTem += name[chosen[i] - 1] + \" \";\n\n        ans.push_back(ansTem);\n        return;\n    }\n    chosen.push_back(x);\n    calc(x + 1);\n\n    chosen.pop_back(); //消除痕迹\n    calc(x + 1);\n\n}\nint main()\n{\n\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        string s;\n        cin >> s;\n        name.push_back(s);\n    }\n    calc(1);\n    for (int i = ans.size() - 1; i >= 0; i--)\n        cout << ans[i] << endl;\n}\n```\n\n**Python 解题代码**\n\n```py\nname = []\nans = []\nchosen = []\nn = 0\nm = 0\n\ndef calc(x):\n    if len(chosen) > m:\n        return\n\n    if len(chosen) + n - x + 1 < m:\n        return\n    if x == n + 1:\n        ansTem = \"\"\n\n        for i in chosen:\n            ansTem = ansTem + name[i - 1] + ' '\n        # print(ansTem)\n        ans.append(ansTem)\n        return\n    chosen.append(x)\n    calc(x + 1)\n    chosen.pop()\n    calc(x + 1)\n\nif __name__ == '__main__':\n\n    tem = input().split()\n    n = int(tem[0])\n    m = int(tem[1])\n    # print(n,\" \",m)\n\n    for i in range(n):\n        s = input()\n        name.append(s)\n\n    # print(name)\n    calc(1)\n\n    for i in range((len(ans) - 1), -1, -1):\n        print(ans[i])\n```\n\n**Java 解题代码**\n\n```java\nimport java.util.Scanner;\nimport java.util.Vector;\n\npublic class Main {\n\n  static  int n;\n  static int m;//选m个数\n  static Vector<String> name = new Vector<String>();\n  static Vector<String> ans = new Vector<String>();\n  static Vector<Integer> chosen = new Vector<Integer>();\n\n  static <object> void calc(int x) {\n\n      if (chosen.size() > m || chosen.size() + (n - x + 1) < m) //剪枝\n          return;\n\n      if (x == n + 1) { //选够了m个数输出\n          String ansTem = \"\";\n          for (int i = 0; i < chosen.size(); i++)\n              ansTem += name.get(chosen.get(i) - 1) + \" \";\n          ans.addElement(ansTem);\n          return;\n      }\n      chosen.addElement(x);\n      calc(x + 1);\n      chosen.remove((Object)x);\n      calc(x + 1);\n  }\n\n\n  public static void main(String[] args) {\n\n      Scanner in = new Scanner(System.in);\n      n = in.nextInt();\n      m = in.nextInt();\n      for (int i = 0; i < n; i++) {\n         String s;\n         s=in.next();\n         name.addElement(s);\n      }\n      calc(1);\n      for (int i = ans.size() - 1; i >= 0; i--)\n          System.out.println(ans.get(i) );\n  }\n}\n```\n\n### 排列型枚举 ###\n\n上面说过，组合型枚举就是让你在 *n* 个中，随机选出 *m* 个 ，问你有多少种方案，而且每一种方案选择了哪 $m ￥ 个，这就是组合型枚举。\n\n而排列型枚举相对组合型枚举就简单了一点，就是 *n* 个的全排列，即从 *n* 个中选取 *n* 个但是关心内部的顺序。\n\n相比较组合只关心有多少个集合，而排列是关心集合内的排列方式。即排列型枚举就是寻找 *A**n**n* 问题。\n\n而且排列型枚举也是有着比较成熟的模板需要大家进行记忆。\n\n```cpp\nint n; //共计N个数\nint order[20];\nbool chosen[20];\nvoid calc(int k)\n{\n    if (k == n + 1)\n    {\n        for (int i = 1; i <= n; i++)\n            cout << order[i] << \" \";\n\n        puts(\"\");\n\n        return;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        if (chosen[i])\n            continue;\n        order[k] = i;\n        chosen[i] = 1;\n        calc(k + 1);\n        chosen[i] = 0;\n        order[k] = 0;\n    }\n}\nint main()\n{\n    cin >> n;\n    calc(1);\n}\n```\n\n**Python 写法**\n\n```python\norder = [0] * 20\nchosen = [0] * 20\nn = 0\ndef calc(x):\n  if x == n + 1:\n      ansTem = ''\n      for i in range(1, n + 1):\n          print(order[i],end=' ')\n      print('')\n      return\n  for i in range(1,n+1):\n      if(chosen[i]==1) :\n          continue\n      order[x]=i\n      chosen[i]=1\n      calc(x+1)\n      chosen[i]=0\n      order[x]=0\nif __name__ == '__main__':\n  n = int(input())\n  # print(name)\n  calc(1)\n```\n\n**Java 写法**\n\n```java\n  static  int n;\n  static int[] order =new int[20];\n  static boolean[] chosen =new boolean[20];\n  static <object> void calc(int x) {\n      if (x == n + 1) { //选够了m个数输出\n          String ansTem = \"\";\n          for (int i = 1; i <=n ; i++)\n              System.out.println(order[i]);\n          return;\n      }\n      for (int i = 1; i <= n; i++) {\n          if (chosen[i]) continue;\n          order[x] = i;\n          chosen[i] =true;\n          calc(x + 1);\n          chosen[i] = false;\n          order[x] = 0;\n      }\n  }\n  public static void main(String[] args) {\n      Scanner in = new Scanner(System.in);\n      n = in.nextInt();\n      for (int i = 0; i < n; i++) {\n         String s;\n          s=in.next();\n          name.addElement(s);\n      }\n      calc(1);\n  }\n```\n\n不少同学问我 2020 够不够，排列问题是阶乘阶的时间复杂度，如果超过这个复杂度，那么这个题也就不用做了，算不出来。\n\n所以肯定够用。\n\n```txt\n4\n1 2 3 4\n1 2 4 3\n1 3 2 4\n1 3 4 2\n1 4 2 3\n1 4 3 2\n2 1 3 4\n2 1 4 3\n2 3 1 4\n2 3 4 1\n2 4 1 3\n2 4 3 1\n3 1 2 4\n3 1 4 2\n3 2 1 4\n3 2 4 1\n3 4 1 2\n3 4 2 1\n4 1 2 3\n4 1 3 2\n4 2 1 3\n4 2 3 1\n4 3 1 2\n4 3 2 1\n```\n\n44 的排列就已经这么多了，大家可以尝试跑一下 1010。\n\n同样，我们再来看一个的问题来进行加深理解。\n\n### 座次问题 ###\n\n**题目描述:**\n\n小 *A* 的学校，老师好不容易解决了蓝桥杯的报名问题，现在老师又犯愁了。现在有 *N* 位同学参加比赛，但是老师想给他们排座位，但是排列方式太多了。老师非常想弄明白最后的排座次的结果是什么样子的，到底有多少种结果。\n\n请设计一个程序帮助老师。\n\n最后输出各种情况的人名即可，一行一种情况，每种情况的名字按照报名即输入顺序排序。\n\n第一行 输入 *N*； 第二行 到 第 +1*N*+1 行 共输入 *N* 个人名。\n\n由于小 A 学校承办能力实在有限，所以其中 *N* 小于等于 1010 人。\n\n**样例:**\n\n```txt\n输入：\n\n3\nxiaowang\nxiaoA\nxiaoli\n输出：\n\nxiaowang xiaoA xiaoli\nxiaowang xiaoli xiaoA\nxiaoA xiaowang xiaoli\nxiaoA xiaoli xiaowang\nxiaoli xiaowang xiaoA\nxiaoli xiaoA xiaowang\n```\n\n**运行限制:**\n\n```txt\n1. 最大运行时间：1s\n2. 最大运行内存：128M\n```\n\n**题目解析：**\n\n实际上还是排列型枚举，但是输出元素为人名，我们可以将人名存起来，输出的时候，根据数字下标找到提前存好的人名，就是按照上一道题的方式处理即可。\n\n#### 答案解析 ####\n\nC++ 代码：\n\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n; //共计N个数\nvector<string> name;\nint order[20];\nbool chosen[20];\nvoid calc(int k)\n{\n    if (k == n + 1)\n    {\n        for (int i = 1; i <= n; i++)\n            cout << name[order[i] - 1] << \" \";\n\n        puts(\"\");\n\n        return;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        if (chosen[i])\n            continue;\n        order[k] = i;\n        chosen[i] = 1;\n        calc(k + 1);\n        chosen[i] = 0;\n        order[k] = 0;\n    }\n}\n\nint main()\n{\n\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        string s;\n        cin >> s;\n        name.push_back(s);\n    }\n    calc(1);\n}\n```\n\n**Python 解题代码**\n\n```python\nname = []\n\norder = [0] * 20\nchosen = [0] * 20\nn = 0\n\ndef calc(x):\n\n  if x == n + 1:\n      ansTem = ''\n\n      for i in range(1, n + 1):\n          ansTem = ansTem + name[order[i]-1] + ' '\n\n      print(ansTem)\n\n      return\n  for i in range(1,n+1):\n      if(chosen[i]==1) :\n          continue\n\n      order[x]=i\n      chosen[i]=1\n      calc(x+1)\n      chosen[i]=0\n      order[x]=0\n\n\nif __name__ == '__main__':\n\n  n = int(input())\n  for i in range(n):\n      s = input()\n\n      name.append(s)\n\n  # print(name)\n  calc(1)\n```\n\n**Java 解题代码**\n\n```java\npackage com.company;\n\nimport java.util.Scanner;\nimport java.util.Vector;\n\npublic class Main {\n\n  static  int n;\n  static Vector<String> name = new Vector<String>();\n  static int[] order =new int[20];\n  static boolean[] chosen =new boolean[20];\n\n  static <object> void calc(int x) {\n\n      if (x == n + 1) { //选够了m个数输出\n          String ansTem = \"\";\n\n          for (int i = 1; i <=n ; i++)\n\n              ansTem += name.get(order[i]-1) + \" \";\n\n          System.out.println(ansTem);\n          return;\n      }\n\n      for (int i = 1; i <= n; i++) {\n          if (chosen[i]) continue;\n          order[x] = i;\n          chosen[i] =true;\n          calc(x + 1);\n          chosen[i] = false;\n          order[x] = 0;\n      }\n  }\n\n  public static void main(String[] args) {\n\n      Scanner in = new Scanner(System.in);\n\n      n = in.nextInt();\n\n      for (int i = 0; i < n; i++) {\n\n         String s;\n          s=in.next();\n          name.addElement(s);\n      }\n      calc(1);\n  }\n}\n```\n\n## 尺取法 ##\n\n尺取法（双指针法、two pointers）是一种常用的优化技巧，特别适用于解决序列的区间问题。它的操作简单，易于编程，是一种线性高效的算法。\n\n尺取法的核心思想是维护一个区间（,*L*,*R*），其中 *L* 为起点，*R* 为终点，该区间是序列内以 *L* 为起点的最短合法区间。关键在于 *R* 随着 *L* 的增大而增大。通过不断枚举 *L*，同时求解相应的 *R*，可以高效地解决问题。\n\n具体的实现步骤是，不断移动 *L* 指针，同时更新 *R* 指针，直到 *R* 随着 *L* 的增大而增大。因为 *R* 随着 *L* 的增大而增大，所以总的时间复杂度为 ()*O*(*n*)。\n\n通过维护两个指针，即左指针 *l* 和右指针 *r*。通过不断确定区间的左端点，让右指针 *r* 不断向右移动，直到满足条件停下，然后维护答案。这个过程重复进行，直到左指针 *l* 超过右指针 *r* 或满足其他特定情况（根据题目而定）。\n\n尺取法的应用范围广泛，特别适用于需要寻找满足某种条件的连续子序列的问题。通过灵活运用尺取法，可以在保持算法简洁的同时，提高解题效率。\n\n### 例题 奇怪的的动物园 ###\n\n#### 题目描述 ####\n\n动物园正在展出由世上最受欢迎的 *m* 种动物组成的精彩展览。\n\n游客在购买门票时必须说明两个数字，*a* 和 *b*，代表他们希望观看的展览范围，从第 *a* 种动物到第 *b* 种动物（包含 ,*a*,*b*）。门票的价格是按照观看的动物数量计算的，即每种动物一元。\n\n小明希望在最小化购票花费的同时，能够欣赏到所有受欢迎的动物。\n\n请计算他应该选择哪些动物范围，即 *a* 和 *b*。\n\n若存在多组解，输出其中 *a* 最小的那组。\n\n#### 输入格式 ####\n\n第一行包含两个整数 *n* 和 *m*，分别表示动物园内的动物总数以及受欢迎的动物种类数量。\n\n第二行包含 *n* 个整数 *a**i*，表示第 *i* 种动物的种类。\n\n#### 输出格式 ####\n\n一行包含两个整数 ,*a*,*b*。\n\n样例输入\n\n```txt\n12 5\n2 5 3 1 3 2 4 1 1 5 4 3\n```\n\n样例输出\n\n```txt\n2 7\n```\n\n### 思路与算法 ###\n\n这是一道使用尺取法（Two Pointers）的题目。我们维护两个指针 `l` 和 `r`，分别表示当前选择区间的左右端点。通过不断调整右指针 `r`，保证区间内包含所有受欢迎的动物。在滑动窗口的过程中，记录最小购票范围。\n\n具体的实现细节如下：\n\n1. 使用 `I` 函数加入第 `x` 种动物的画，同时更新相应的计数和唯一动物数量。\n2. 使用 `D` 函数删除第 `x` 种动物的画，同时更新相应的计数和唯一动物数量。\n3. 不断移动右指针 `r`，并在保证区间内包含所有受欢迎的动物的前提下，更新最小购票范围。\n4. 移动左指针 `l`，直到无法再删除动物，保证区间仍然包含所有受欢迎的动物。\n\n#### 复杂度分析 ####\n\n由于每个动物最多被插入和删除一次，算法的时间复杂度为 ()*O*(*n*)，其中 *n* 是动物的数量。\n\n#### 代码 ####\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1000005;\n\nint n, m, a[MAXN], b[MAXN], cnt, ans, ansl, ansr;\n\n// 加入第x种动物\ninline void I(int x) {\n    if (b[x] == 0) cnt++; // 如果该动物没有在当前区间中出现过，增加唯一动物数量\n    b[x]++; // 动物x的数量加1\n}\n\n// 删除第x种动物\ninline void D(int x) {\n    if (b[x] == 1) cnt--; // 如果删除后该动物不再在当前区间中出现，减少唯一动物数量\n    b[x]--; // 动物x的数量减1\n}\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]); // 读取每种动物的种类\n\n    ans = n;\n    for (int r = 1, l = 1; r <= n; r++) {\n        I(a[r]); // 首先插入a[r]的动物\n\n        while (true) {\n            D(a[l]); // 先删a[l]的动物\n            if (cnt == m) l++; // 如果删了没事，加l\n            else {\n                I(a[l]);\n                break; // 删了有事，还留着\n            }\n        }\n\n        if (cnt == m && r - l + 1 < ans) {\n            ans = r - l + 1;\n            ansl = l;\n            ansr = r;\n        }\n    }\n\n    if (ansl != 0) printf(\"%d %d\", ansl, ansr);\n    else printf(\"1 %d\", n); // 输出+特判：选择任意一个≤n的区间不满足要求，则只好选择区间[1,n]\n\n    return 0;\n}\nMAXN = 1000005\na = [0]*MAXN\nb = [0]*MAXN\ncnt=0\nansl=0\nansr=0\n\ndef I(x):\n    global cnt\n    if b[x] == 0:\n        cnt += 1\n    b[x] += 1\n\ndef D(x):\n    global cnt\n    if b[x] == 1:\n        cnt -= 1\n    b[x] -= 1\n\nn, m = map(int, input().split())\na[1:n+1] = map(int, input().split())\n\nans = n\nl = 1\nfor r in range(1, n+1):\n    I(a[r])\n    while True:\n        D(a[l])\n        if cnt == m:\n            l += 1\n        else:\n            I(a[l])\n            break\n    if cnt == m and r - l + 1 < ans:\n        ans = r - l + 1\n        ansl = l\n        ansr = r\n\nif ansl != 0:\n    print(ansl, ansr)\nelse:\n    print(1, n)\nimport java.util.Scanner;\n\npublic class Main {\n    static final int MAXN = 1000005;\n    static int[] a ;\n    static int[] b;\n    static int cnt = 0;\n\n    static void I(int x) {\n        if (b[x] == 0) cnt++;\n        b[x]++;\n    }\n\n    static void D(int x) {\n        if (b[x] == 1) cnt--;\n        b[x]--;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        a=new int[n+10];\n        b=new int[n+10];\n        int m = scanner.nextInt();\n        for (int i = 1; i <= n; i++) a[i] = scanner.nextInt();\n\n        int ans = n;\n        int ansl = 0, ansr = 0;\n        for (int r = 1, l = 1; r <= n; r++) {\n            I(a[r]);\n            while (true) {\n                D(a[l]);\n                if (cnt == m) l++;\n                else {\n                    I(a[l]);\n                    break;\n                }\n            }\n            if (cnt == m && r - l + 1 < ans) {\n                ans = r - l + 1;\n                ansl = l;\n                ansr = r;\n            }\n        }\n\n        if (ansl != 0) System.out.println(ansl + \" \" + ansr);\n        else System.out.println(\"1 \" + n);\n    }\n}\n```\n\n这个算法通过维护两个指针，实现了在 ()*O*(*n*) 的时间复杂度内找到最小购票范围的目标。尺取法的思想在滑动窗口的过程中，通过不断调整左右指针来满足特定条件。\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯冲刺营","4.枚举和尺取法"]},{"title":"搜索算法","url":"/2024/02/22/搜索算法/","content":"\n# 深度优先搜索 #\n\nDepth First Search 即 DFS，意为深度优先搜索，是所有的搜索手段之一。它是从某个状态开始，不断进行状态转移，直到不能转移后，向后回退，一直到遍历完所有的状态。\n\n本章题目难度较大，请大家仔细研读讲解和代码。\n\n## 知识点 ##\n\n1.DFS 算法设计原理与实现方法 2.经典题型精讲\n\n## 深度优先搜索基本概念 ##\n\n作为搜索算法的一种，DFS 主要是用于解决 `NP` 完全问题。但是，深度优先搜索算法的时间复杂度较高，深度优先搜索是 (!)*O*(*n*!) 的阶乘级算法，它的效率非常低，在数据规模变大时，此算法就难以解决当前的问题了。\n\n所以搜索算法使用于状态节点较小规模的问题。\n\n## DFS 的设计步骤 ##\n\n按照定义设计：\n\n1. 确定该题目的状态（包括边界）\n2. 找到状态转移方式\n3. 找到问题的出口，计数或者某个状态\n4. 设计搜索\n\n伪代码：\n\n```c\nint check(参数)\n{\n    if(满足条件)\n        return 1;\n    return 0;\n}\nbool pd(参数){\n    相应操作\n}\nvoid dfs(int step)\n{\n        判断边界pd()\n        {\n            不在边界内，即回溯\n        }\n        尝试每一种可能\n        {\n               满足check条件\n\n               标记\n\n               继续下一步dfs(step+1)\n\n               恢复初始状态（回溯的时候要用到）\n        }\n}\n```\n\n## DFS 题目讲解 ##\n\n### 状态搜索代表： N 皇后问题 ###\n\n[题目链接](https://www.lanqiao.cn/problems/1508/learning/)\n\n难度: 简单\n\n标签: DFS\n\n**题目描述:**\n\n在 ×*N*×*N* 的方格棋盘放置了 *N* 个皇后，使得它们不相互攻击（即任意 22 个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成 4545 角的斜线上。你的任务是，对于给定的 *N*，求出有多少种合法的放置方法。\n\n**输入描述:**\n\n输入中有一个正整数 ≤10*N*≤10，表示棋盘和皇后的数量\n\n**输出描述:**\n\n为一个正整数，表示对应输入行的皇后的不同放置数量。\n\n**输入输出样例:**\n\n**示例:**\n\n**输入:**\n\n```txt\n5\n```\n\n**输出:**\n\n```txt\n10\n```\n\n**运行限制:**\n\n```txt\n    最大运行时间：1s\n    最大运行内存: 256M\n```\n\n**解题思路:**\n\n下面是用递归的深度优先搜索求解 *n* 皇后问题的算法描述：\n\n这里用一个 ×*N*×*N* 的矩阵来表示棋盘，但是我们不需要定义这样的数组，只要心中有 ×*N*×*N* 的期盼即可。\n\n1. **算法开始：**\n\n   当前行设为第一行，当前列设为第一列，从第一行第一列开始搜索，即只能让皇后从第一行放到第 *n* 行。\n\n   这样在每次判断是否满足情况时我们不用去判断是否皇后在相同行。\n\n   我们只用判断之前的 11 到 −1*a*−1 个皇后的位置和当前第 *a* 个皇后的位置是否属于同一列或者斜线，判断是否同一列。\n\n2. **判断边界：**\n\n   在当前行，当前列的位置上判断是否满足条件(即保证经过这一点的行,列与斜线上都没有两个皇后)，若不满足，跳到第 55 步，即不符合边界条件。\n\n   首先说一下，什么叫不符合边界条件，不只是跳出了搜索范围，剪枝也可以从这里开始，比如这里不满足条件，向下继续搜索也不会再有结果。\n\n   这可以理解为超出边界的剪枝，我们的边界只得可能存在解的范围，这里已经超出有解的范围，必然要被踢出。\n\n   判断条件：\n\n   我们用数组 []=*x*[*a*]=*i* 来表示第 *a* 个皇后的位置在第 *a* 行第 *i* 列，我们不用考虑是否在同一行的问题你，我们只用判断之前的 11 到 −1*a*−1 个皇后的位置和当前第 *a* 个皇后的位置是否属于同一列或者斜线。\n\n   判断是否属于同一列： 就判断 []*x*[*a*] 是否等于 []*x*[*i*]; 判断是否属于同一斜线：等同于判断行之差是否等于列之差也，即 ([]−[])≠(−)*a**b**s*(*x*[*k*]−*x*[*i*])=*a**b**s*(*k*−*i*)。\n\n3. **搜索过程：**\n\n   调用 `Check` 函数。\n\n   如果 边界条件，就继续调用放下一个皇后的位置\n\n4. **`Check` 函数:**\n\n   如果当搜索到第 +1*N*+1 行的时候，即代表前 *N* 行已经搜索完了，所以这个时候正好求出了一个解，记录加一。\n\n5. 在当前位置上不满足条件的情形，进行回溯。\n\nC++ 语言描述:\n\n```cpp\n#include <iostream>\n#include <cstdio>\nusing namespace std;\nint x[15] = {0};\nint sum,n;\n\nint PD(int k)\n{\n\n    for(int i=1; i<k; i++)\n    {\n        if(abs(k-i)==abs(x[k]-x[i]))\n            return 0;\n        else if (x[k]==x[i])\n            return 0;\n        //即判断是否符合条件来放,i表示皇后所在的行数，x[i]表示所在的列数，\n        //所以前面那个条件用来判断两个皇后是否在对角线上,后面用来判断是否在同一列上。\n        //行数不需要判断，因为他们本身的i就代表的是行数\n    }\n    return 1;\n}\n\nbool check(int a)\n{\n\n    if(a>n)\n        sum++;\n    else\n        return 0;\n    return 1;\n}\n\nvoid DFS(int a)\n{\n    if(check(a))\n        return ;\n    else\n        for(int i=1; i<=n; i++)\n        {\n            x[a]=i;\n                //第a个皇后放的列数\n            if(PD(a))\n                    //判断是否能放这步\n                DFS(a+1);\n                    //能的话进行下一个皇后的放置\n            else continue ;\n                    //不能就下一列\n        }\n}\nint main()\n{\n    cin>>n;\n    //表示几个皇后\n    DFS(1);\n    //每次都从第一个皇后开始\n    cout<<sum<<endl;\n    return 0;\n}\n```\n\nPython 语言描述：\n\n```py\n x = [0] * 15\nn = 0\nsum = 0\ndef pd(k):\n    for i in range(1, k):\n        if abs(k - i) == abs(x[k] - x[i]):\n            return 0\n        elif x[k] == x[i]:\n            return 0\n        # 即判断是否符合条件来放,i表示皇后所在的行数，x[i]表示所在的列数，\n        # 所以前面那个条件用来判断两个皇后是否在对角线上,后面用来判断是否在同一列上。\n        # 行数不需要判断，因为他们本身的i就代表的是行数\n    return 1\n\ndef check(a):\n    if a > n:\n        global sum\n        sum += 1\n    else:\n        return False\n    return True\n\n\ndef DFS(a):\n\n    if check(a):\n        return\n    else:\n        for i in range(1, n + 1):\n            x[a] = i\n            # 第a个皇后放的列数\n            if pd(a):\n                # 判断是否能放这步\n                DFS(a + 1)\n                # 能的话进行下一个皇后的放置\n            else:\n                continue\n                #   不能就下一列\n\nif __name__ == '__main__':\n\n    n = int(input())\n    # 不能就下一列\n    DFS(1)\n    # 每次都从第一个皇后开始\n    print(sum)\n```\n\nJava 语言描述:\n\n```java\nimport java.util.Scanner;\nimport static java.lang.Math.abs;\npublic class Main {\n    static int x[] = new int[15];\n    static int sum, n;\n    static boolean PD(int k) {\n        for (int i = 1; i < k; i++) {\n            if (abs(k - i) == abs(x[k] - x[i]))\n                return false;\n            else if (x[k] == x[i])\n                return false;\n            //即判断是否符合条件来放,i表示皇后所在的行数，x[i]表示所在的列数，\n            //所以前面那个条件用来判断两个皇后是否在对角线上,后面用来判断是否在同一列上。\n            //行数不需要判断，因为他们本身的i就代表的是行数\n\n        }\n        return true;\n    }\n\n    static boolean check(int a) {\n\n        if (a > n)\n            sum++;\n        else\n            return false;\n        return true;\n    }\n\n    static void DFS(int a) {\n        if (check(a))\n            return;\n        else\n            for (int i = 1; i <= n; i++) {\n                x[a] = i;\n                //第a个皇后放的列数\n                if (PD(a))\n                    //判断是否能放这步\n                    DFS(a + 1);\n                    //能的话进行下一个皇后的放置\n                else continue;\n                //不能就下一列\n            }\n    }\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        //表示几个皇后\n        DFS(1);\n        //每次都从第一个皇后开始\n        System.out.println(sum);\n    }\n}\n```\n\n### 图的路径搜索代表-路径之谜 ###\n\n[题目链接](https://www.lanqiao.cn/problems/89/learning/)\n\n难度: 中等\n\n标签: DFS, 2016, 国赛\n\n**题目描述:**\n\n小明冒充 *X* 星球的骑士，进入了一个奇怪的城堡。\n\n城堡里边什么都没有，只有方形石头铺成的地面。\n\n假设城堡地面是 ×*n*×*n* 个方格。如下图所示。\n\n![地图](./../imgs/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/uid1580206-20210202-1612248935564.png)\n\n按习俗，骑士要从西北角走到东南角。可以横向或纵向移动，但不能斜着走，也不能跳跃。每走到一个新方格，就要向正北方和正西方各射一箭。（城堡的西墙和北墙内各有 *n* 个靶子）同一个方格只允许经过一次。但不必走完所有的方格。如果只给出靶子上箭的数目，你能推断出骑士的行走路线吗？有时是可以的，比如上图中的例子。\n\n本题的要求就是已知箭靶数字，求骑士的行走路径（测试数据保证路径唯一）\n\n**输入:**\n\n第一行一个整数 *N* (0≤≤200≤*N*≤20)，表示地面有 ×*N*×*N* 个方格。\n\n第二行 *N* 个整数，空格分开，表示北边的箭靶上的数字（自西向东）\n\n第三行 *N* 个整数，空格分开，表示西边的箭靶上的数字（自北向南）\n\n**输出：**\n\n输出一行若干个整数，表示骑士路径。\n\n为了方便表示，我们约定每个小格子用一个数字代表，从西北角开始编号: 0,1,2,3 ⋯⋯\n\n**输入输出样例：**\n\n输入\n\n```txt\n4\n2 4 3 4\n4 3 3 3\n```\n\n比如，上图中的方块编号为：\n\n| 箭靶 | 2    | 4    | 3    | 4    |\n| ---- | ---- | ---- | ---- | ---- |\n| 4    | 0    | 1    | 2    | 3    |\n| 3    | 4    | 5    | 6    | 7    |\n| 3    | 8    | 9    | 10   | 11   |\n| 3    | 12   | 13   | 14   | 15   |\n\n输出\n\n```txt\n0 4 5 1 2 3 7 11 10 9 13 14 15\n```\n\n**运行限制:**\n\n```txt\n最大运行时间：1s\n最大运行内存: 128M\n```\n\n**解题思路:**\n\n这里用一个 ×*N*×*N* 的矩阵来表示城堡的位置，横向、纵向标号 1−1−*N*。\n\n我们采用逆推法，既然原题目是走到哪里射一支箭，那我们就走到那里之后拔一支箭，如果最后得到所有的靶子上都没有箭了，由于题目的路径唯一，那就证明我们找到了题目所要求的路径。\n\n1. 算法开始：\n\n   当前行设为第一行，当前列设为第一列，从第一行第一列开始搜索。\n\n   然后从左上角初始位置，按照题目意思进行寻路。\n\n2. 判断边界：\n\n   在当前行，当前列的位置上判断是否满足条件，若不满足，跳到第 55 步，即不符合边界条件。 判断条件如下：\n\n   - [][]*f**l**a**g*[*x*][*y*]==1 标记数组已经被标记,已被走过，不能再走，超出边界\n   - <1*x*<1 从左侧走出方格。\n   - >*x*>*n* 从右侧走出方格。\n   - <1*y*<1 从上侧走出方格。\n   - >*y*>*n* 从下侧走出方格。\n   - []<=0*c**o**l*[*x*]<=0 没走到右下角，箭用完了。\n   - []<=0*r**o**l*[*y*]<=0 没走到右下角，箭用完了\n\n3. 搜索过程：\n\n   调用 `Check` 函数。 如果边界条件满足，就继续调用搜索，找到下一步的位置\n\n4. check(参数):\n\n   如果当搜索到 =,=*x*=*n*,*y*=*n* 时，且靶子上的箭都没了，按就找到了答案。\n\n   按照题目输出即可。\n\n5. 在当前位置上不满足条件的情形，进行回溯，并还原现场\n\nC++ 语言描述:\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct PII\n{\n    int first;\n    int second;\n};\n\nconst int N = 30;\nint rol[N];\nint col[N];\nint n;//格子数 长宽从1到n\nbool flag[N][N]; //用来标记是否走过\nvector<PII> res;\n\n\n//---------图的路径搜索常用方向移动表示-------\n\nint dx[4]= {0,1,-1,0};\nint dy[4]= {1,0,0,-1};\n\n// 两两组合形成上下左右四个方向\n//      1------------------> x\n//      |\n//      |\n//      |\n//      |\n//      |\n//      |\n//      |\n//      ↓\n//      y\n\n// dx[0]=0 dy[0]=1 那么代表向下的方向\n// dx[1]=1 dy[1]=0 那么代表向右的方向\n// dx[2]=-1 dy[0]=0 那么代表向左的方向\n// dx[3]=0 dy[1]=-1 那么代表向上的方向\n\n//--------------------------------------------\n\nbool  check(int x, int y) //判断走过的路径的箭靶数是否与目标相同\n{\n    if(x==n && y==n)\n    {\n        for(int i=1; i<=n; i++)\n        {\n            if(col[i]!=0)\n            {\n                return false;\n            }\n            //如果箭靶上的数目不为0，根据逆推，我们通过当前路径得不到箭靶上的结果\n        }\n        for(int i=1; i<=n; i++)\n        {\n            if(rol[i]!=0)\n            {\n                return false;\n            }\n            //如果箭靶上的数目不为0，根据逆推，我们通过当前路径得不到箭靶上的结果\n        }\n        for(int i=0; i<res.size(); i++)\n        {\n            int x=res[i].first;\n            //x 轴坐标\n            int y=res[i].second;\n            //y 轴坐标\n            int sum=n*(x-1)+y-1 ;\n            // 通过计算的到为题目要求的坐标系\n            cout <<sum<< \" \";\n        }\n        cout << endl;\n        return false;\n        // 成功终止\n    }\n    return true; //继续搜索\n    //关于终止还是继续我们交给判定即可\n}\nbool pd(int x2,int y2) //边界判断\n{\n    if(flag[x2][y2]==1)\n        return 0;\n    //已被走过，不能再走，超出边界\n    else if(x2<1)\n        return 0;\n    //从左侧走出方格\n    else if(x2>n)\n        return 0;\n    //从右侧走出方格\n    else if(y2<1)\n        return 0;\n    //从上侧走出方格\n    else if(y2>n)\n        return 0;\n    //从下侧走出方格\n    else if(col[x2]<=0)\n        return 0;\n    //没走到右下角，箭用完了\n    else if(rol[y2]<=0)\n        return 0;\n    //没走到右下角，箭用完了\n    else return 1;\n    //符合边界条件，可以继续执行搜索\n}\n\nvoid dfs(int x,int y)\n{\n    if(!check(x,y))\n    {\n        return ;\n        //包含不符合规则的地方，回溯，用于剪枝\n    }\n    else\n    {\n        for(int i=0; i<4; i++)\n        {\n            int xt=dx[i]+x;\n            int yt=dy[i]+y;\n            if(!pd(xt,yt))\n            {\n                continue ;\n                //不符合要求继续换方向搜索\n            }\n            else\n            {\n                //因为要进行位置转移，我们给它起个名字，叫作案现场\n                //比如向下移动\n                flag[xt][yt]=true;\n                col[xt]--;\n                rol[yt]--;\n                res.push_back({xt,yt});\n                dfs(xt,yt);\n                //搜索回溯后，因为没有找到正确答案，所以要回复作案现场，返回到搜索之前\n                res.pop_back();\n                flag[xt][yt]=false;\n                col[xt]++;\n                rol[yt]++;\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin >> n;\n    for(int i=1; i<=n; i++)\n        cin >> rol[i];\n    for(int i=1; i<=n; i++)\n        cin >> col[i];\n    flag[1][1]=true;\n    col[1]--;\n    rol[1]--;\n    res.push_back({1,1});\n    dfs(1,1);\n    return 0;\n}\n```\n\nPython 语言描述:\n\n```python\nn = 0\nflag = [[0 for i in range(26)] for i in range(27)]\nresX = [0 for i in range(1000)]\nresY = [0 for i in range(1000)]\nresCount = 0\n\n# ---------图的路径搜索常用方向移动表示-------\n\ndx = [0, 1, -1, 0]\ndy = [1, 0, 0, -1]\n\n# 两两组合形成上下左右四个方向\n#      1------------------> x\n#      |\n#      |\n#      |\n#      |\n#      |\n#      |\n#      |\n#      ↓\n#      y\n\n# dx[0]=0 dy[0]=1 那么代表向下的方向\n# dx[1]=1 dy[1]=0 那么代表向右的方向\n# dx[2]=-1 dy[0]=0 那么代表向左的方向\n# dx[3]=0 dy[1]=-1 那么代表向上的方向\n# --------------------------------------------\n\n\ndef check(x, y):\n    global n\n    if x == n & y == n:\n        # print(\"check point1\")\n        for i in range(1, n + 1):\n            if (col[i] != 0):\n                return False\n                # 如果箭靶上的数目不为0，根据逆推，我们通过当前路径得不到箭靶上的结果\n        for i in range(1, n + 1):\n            if (rol[i] != 0):\n                return False\n        for i in range(0, resCount):\n            x2 = resX[i]\n            # x 轴坐标\n            y2 = resY[i]\n            # y 轴坐标\n            sum = n * (x2 - 1) + y2 - 1\n            # 通过计算的到为题目要求的坐标系\n            print(sum, end=\" \")\n\n        return False\n        # 成功终止\n    else:\n        return True  # 继续搜索\n        # 关于终止还是继续我们交给判定即可\n\ndef pd(x2, y2):\n    global n\n    # print(\"x2 :\", x2,\"y2 :\", y2, \" n \", n)\n    if flag[x2][y2] == 1:\n        # print(\"checkPoint3\")\n        return False\n        # 已被走过，不能再走，超出边界\n    elif x2 < 1:\n        # print(\"checkPoint5\")\n        return False\n    # 从左侧走出方格\n    elif x2 > n:\n        # print(\"checkPoint6\")\n        return False\n    # 从右侧走出方格\n    elif col[x2] <= 0:\n        # print(\"checkPoint8\")\n        return False\n    # 没走到右下角，箭用完了\n    elif y2 < 1:\n        # print(\"checkPoint7\")\n        return False\n    # 从上侧走出方格\n    elif y2 > n:\n        # print(\"y2 :\",y2,\" n \",n)\n        return False\n    # 从下侧走出方格\n    elif rol[y2] <= 0:\n        # print(\"checkPoint9\")\n        return False\n    # 没走到右下角，箭用完了\n    else:\n        return True\n\n# 符合边界条件，可以继续执行搜索\ndef dfs(x, y):\n    if not check(x, y):\n        return\n    # 包含不符合规则的地方，回溯，用于剪枝\n    else:\n        for i in range(0, 4):\n            xt = dx[i] + x\n            yt = dy[i] + y\n            # print(xt, yt)\n            if not pd(xt, yt):\n                # print(\"CheckPoint\", xt, yt)\n                continue\n                # 不符合要求继续换方向搜索\n\n            else:\n\n                # 因为要进行位置转移，我们给它起个名字，叫作案现场\n                # 比如向下移动\n                col[xt] -= 1\n                rol[yt] -= 1\n                flag[xt][yt] = 1\n                global resCount\n                resX[resCount] = xt\n                resY[resCount] = yt\n                resCount += 1\n                # print(\"---------123-------\")\n                # print(flag)\n                # print(\"----------------\")\n                dfs(xt, yt)\n\n                # 搜索回溯后，因为没有找到正确答案，所以要回复作案现场，返回到搜索之前\n\n                resCount -= 1\n                flag[xt][yt] = 0\n                # print(\"--------321--------\")\n                # print(flag)\n                # print(\"----------------\")\n                col[xt] += 1\n                rol[yt] += 1\n\nif __name__ == '__main__':\n    n = int(input())\n    # print(\"----------------\")\n    # print(flag)\n    # print(\"----------------\")\n    rol = input().split()\n    rol = list(map(int, rol))\n    rol = [0] + rol\n    col = input().split()\n    col = list(map(int, col))\n    col = [0] + col\n    flag[1][1] = 1\n    # print(\"----------------\")\n    # print(flag)\n    # print(\"----------------\")\n    col[1] -= 1\n    rol[1] -= 1\n    resX[resCount] = 1\n    resY[resCount] = 1\n    resCount += 1\n    dfs(1, 1)\n```\n\n然而需要注意的是上面代码会超时，我们要对其进行优化，因为同样的计算 Python 运行时间相比 C++ 要长很多，这里给 C++ 和 Python 相同的时间，确实是难为 Python 了。 因为上面是为了给大家系统的将一个框架，而这道题目的时间复杂度相对较高，Python 的运行时间是 C++ 10 倍甚至几十倍，这个题目，同样的复杂度，Python 给的时间是不好通过这个题目的，我优化了十几遍，确实通过不了。\n\nJava 语言描述:\n\n```java\nimport java.util.Scanner;\nimport java.util.Vector;\n\nimport static java.lang.Math.abs;\n\npublic class Main {\n\n    static final int N = 30;\n    static int rol[]=new int [N];\n    static int col[]=new int [N];\n    static int n;//格子数 长宽从1到n\n    static  boolean flag[][]=new boolean[N][N]; //用来标记是否走过\n    static int resX[]=new int [1000];\n    static int resY[]=new int [1000];\n    static int resCount=0;\n\n//---------图的路径搜索常用方向移动表示-------\n\n    static int dx[]= {0,1,-1,0};\n    static  int dy[]= {1,0,0,-1};\n\n// 两两组合形成上下左右四个方向\n//      1------------------> x\n//      |\n//      |\n//      |\n//      |\n//      |\n//      |\n//      |\n//      ↓\n//      y\n\n// dx[0]=0 dy[0]=1 那么代表向下的方向\n// dx[1]=1 dy[1]=0 那么代表向右的方向\n// dx[2]=-1 dy[0]=0 那么代表向左的方向\n// dx[3]=0 dy[1]=-1 那么代表向上的方向\n\n//--------------------------------------------\n\n    static boolean  check(int x, int y) //判断走过的路径的箭靶数是否与目标相同\n    {\n        if(x==n && y==n)\n        {\n            for(int i=1; i<=n; i++)\n            {\n\n                if(col[i]!=0)\n                {\n                    return false;\n                }\n                //如果箭靶上的数目不为0，根据逆推，我们通过当前路径得不到箭靶上的结果\n            }\n            for(int i=1; i<=n; i++)\n            {\n                if(rol[i]!=0)\n                {\n                    return false;\n                }\n                //如果箭靶上的数目不为0，根据逆推，我们通过当前路径得不到箭靶上的结果\n            }\n            for(int i=0; i<resCount; i++)\n            {\n                int x2= resX[i];\n                //x 轴坐标\n                int y2=resY[i];\n                //y 轴坐标\n                int sum=n*(x2-1)+y2-1 ;\n                // 通过计算的到为题目要求的坐标系\n                System.out.print(sum+\" \");\n            }\n            System.out.println();\n            return false;\n            // 成功终止\n        }\n        return true; //继续搜索\n        //关于终止还是继续我们交给判定即可\n    }\n    static boolean pd(int x2,int y2) //边界判断\n    {\n\n        if(flag[x2][y2] )\n            return false;\n            //已被走过，不能再走，超出边界\n        else if(x2<1)\n            return false;\n            //从左侧走出方格\n        else if(x2>n)\n            return false;\n            //从右侧走出方格\n        else if(y2<1)\n            return false;\n            //从上侧走出方格\n        else if(y2>n)\n            return false;\n            //从下侧走出方格\n        else if(col[x2]<=0)\n            return false;\n            //没走到右下角，箭用完了\n        else if(rol[y2]<=0)\n            return false;\n            //没走到右下角，箭用完了\n        else return true;\n        //符合边界条件，可以继续执行搜索\n    }\n\n    static void dfs(int x,int y)\n    {\n\n        if(!check(x,y))\n        {\n            return ;\n            //包含不符合规则的地方，回溯，用于剪枝\n        }\n        else\n        {\n            for(int i=0; i<4; i++)\n            {\n                int xt=dx[i]+x;\n                int yt=dy[i]+y;\n\n                if(!pd(xt,yt))\n                {\n                    continue ;\n                    //不符合要求继续换方向搜索\n                }\n                else\n                {\n                    //因为要进行位置转移，我们给它起个名字，叫作案现场\n                    //比如向下移动\n                    flag[xt][yt]=true;\n                    col[xt]--;\n                    rol[yt]--;\n                    resX[resCount]=xt;\n                    resY[resCount++]=yt;\n                    dfs(xt,yt);\n                    //搜索回溯后，因为没有找到正确答案，所以要回复作案现场，返回到搜索之前\n                    resCount--;\n                    flag[xt][yt]=false;\n                    col[xt]++;\n                    rol[yt]++;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        for(int i=1; i<=n; i++)\n            rol[i]=in.nextInt();\n        for(int i=1; i<=n; i++)\n             col[i]=in.nextInt();\n        flag[1][1]=true;\n        col[1]--;\n        rol[1]--;\n        resX[resCount]=1;\n        resY[resCount++]=1;\n        dfs(1,1);\n    }\n}\n```\n\n### 最大数字 ###\n\n给定一个正整数 *N* 。你可以对 *N* 的任意一位数字执行任意次以下 22 种操 作：\n\n1. 将该位数字加 11 。如果该位数字已经是 99 , 加 11 之后变成 00 。\n2. 将该位数字减 11 。如果该位数字已经是 00 , 减 11 之后变成 99 。\n\n你现在总共可以执行 11 号操作不超过 *A* 次, 22 号操作不超过 *B* 次。 请问你最大可以将 *N* 变成多少?\n\n**解题思路:**\n\n看上去 *N* 的范围貌似很大，达到了 `1e17` 的范围，但其实我们最多只需要考虑这最多 `17` 位数，所以可以想到爆搜得到答案。\n\n一个数的大小是从左到右依次判断，所以我们从最左边开始枚举，我们无需关注后面的数，要利用自己的 `1` 号操作和 `2` 号操作 **保证当前这个数位的数一定要尽可能最大**\n\n然后分别考虑两种操作，首先两种操作不可能混用，因为它们是抵消的效果，所以要么对这个数全使用 `1` 操作，要么 `2` 操作。假设某个数位的值为 `x`,首先考虑 `1` 号操作，使用后可以让该数位变大，出于**贪心**考虑，我们想让它变成 `9`，那么需要进行 `9-x` 次 `1` 号操作，当然可能此时 `1` 号操作并不足以让我们将 `x` 变成 `9`，但我们还是使用剩余的全部的次数将其变大，所以每次考虑 `1` 号操作应该使用的操作数 `t` 应该为 `t=min(n,9-x)`,此时 `x` 将变为 `x+t`，然后进行下一位的判断。\n\n其次我们考虑 `2` 号操作，这个的判断比较简单，它是让某个值减小，唯一能让某个数变大的机会就是将其减到 `0` 后再减就会变成 `9`。那么这样操作需要的次数就是 `x+1`，如果操作次数不够，那我们宁愿不使用，因为这只会让这个数位变得更小。\n\n在深搜 `dfs` 的过程中，参数记录遍历到第几个数位以及此时累计的和，当搜索完所有数位后，将此时的和与答案进行一个取 `max`，最后的值则为答案。\n\nC++ 语言描述：\n\n```c\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nchar c[20];\nLL ans=0;\n//n:1号操作剩余次数  m:2号操作剩余次数\nint n,m;\nvoid dfs(int i,LL v){\n    int x=c[i]-'0';\n    if(c[i]){\n        //应该使用的操作次数\n        int t=min(n,9-x);\n        n-=t;\n        dfs(i+1,v*10+x+t);\n        //回溯\n        n+=t;\n        //考虑操作2是否能够使用\n        if(m>x){\n            m-=x+1;\n            dfs(i+1,v*10+9);\n            //回溯\n            m+=x+1;\n        }\n    }else{\n        //答案取max\n        ans=max(ans,v);\n    }\n}\nint main()\n{\n    scanf(\"%s%d%d\",c,&n,&m);\n    dfs(0,0);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n```\n\nJava 语言描述:\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n    static String t;\n    static int a, b, m;\n    static long ans = 0;\n\n    // i 表示考虑到第i位  v表示当前的值是多少\n    static void dfs(int i, long v) {\n        if (i == m) {\n            ans = Math.max(ans, v);\n            return;\n        }\n        int c = t.charAt(i) - '0';\n        //考虑第一种使用\n        int g = Math.min(a, 9 - c);\n        a -= g;\n        dfs(i + 1, v * 10 + c + g);\n        //回溯\n        a += g;\n        //考虑第二种使用   我一定要减到9  只有b>c 才能减到9\n        if (b > c) {\n            b -= c + 1;\n            dfs(i + 1, v * 10 + 9);\n            //回溯\n            b += c + 1;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        String[] s = br.readLine().trim().split(\" \");\n        t = s[0];\n        m = t.length();\n        a = Integer.parseInt(s[1]);\n        b = Integer.parseInt(s[2]);\n        dfs(0, 0);\n        out.println(ans);\n        out.flush();\n    }\n}\n```\n\nPython 语言描述:\n\n```python\nimport sys\n\nt = \"\"\na = 0\nb = 0\nm = 0\nans = 0\n\ndef dfs(i, v):\n    global ans, a, b, t\n    if i == m:\n        ans = max(ans, v)\n        return\n    c = int(t[i])\n    # 考虑第一种使用\n    g = min(a, 9 - c)\n    a -= g\n    dfs(i + 1, v * 10 + c + g)\n    # 回溯\n    a += g\n    # 考虑第二种使用   我一定要减到9  只有b>c 才能减到9\n    if b > c:\n        b -= c + 1\n        dfs(i + 1, v * 10 + 9)\n        # 回溯\n        b += c + 1\n\ndef main():\n    global ans, a, b, t, m\n    line = sys.stdin.readline().strip()\n    s = line.split()\n    t = s[0]\n    m = len(t)\n    a = int(s[1])\n    b = int(s[2])\n    dfs(0, 0)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n## 实验总结 ##\n\nDFS 是一种非常重要的回溯算法，它是通过递归设计转移状态，再加上边界判断，与结果检查，构成的基本搜索框架。\n\nDFS 最重要的就是设计回溯，所谓回溯就是还原现场，保证在执行另一分支的时候能够确保所有的改变只受当前状态的影响，所以在一条路走不通时就要修改。特殊的修改可以达到特殊的回溯效果，回溯时剪枝，回溯时调整路线，都是可以的。\n\nDFS 是算法学习的基础工具，很重要，必须要学会。\n\n------\n\nshow: step version: 1.0 enable_checker: true\n\n------\n\n# 广度优先搜索 #\n\nBFS，其英文全称是 Breadth First Search，意为广度优先搜索，是所有的搜索手段之一。它是从某个状态开始，将所有节点加入一个先进先出的队列，然后一层一层进行状态转移，并且展开节点。\n\n本章题目难度较大，请大家仔细研读讲解和代码。\n\n## 知识点 ##\n\n1.BFS 算法设计原理与实现方法 2.经典题型精讲\n\n## 广度优先搜索基本概念 ##\n\n作为搜索算法的一种，BFS 相较于 DFS 而言，BFS 是一层一层展开的，那么对于有多个终态时，最先找到的一定是最短的。\n\n## 广度优先搜索算法的设计步骤 ##\n\n按照定义设计：\n\n1. 确定该题目的状态（包括边界）\n2. 找到状态转移方式\n3. 找到问题的出口，计数或者某个状态\n4. 设计搜索\n\n会发现我们前期要找到的参数基本一致，所以在一般情况下 BFS 和 DFS 可以相互转换。\n\n伪代码：\n\n```c\nint check(参数)\n{\n    if(满足条件)\n        return 1;\n    return 0;\n}\nbool pd(参数){\n    相应操作\n}\nvoid bfs()\n{\n    1. 把根节点放入队列尾端\n    2. 每次从队列中取出一个节点\n    3. Check 判断是不是答案，如果是结束算法 return;\n    4. 把当前取出的节点扩展，如果扩展后的节点经Pd()后符合要求，就放入队列，不符合就不放。\n    5. 转到步骤2，循环执行\n}\n\n如果所有节点被扩展完了，没有找到答案就无解。\n```\n\n### 长草 ###\n\n[题目链接](https://www.lanqiao.cn/problems/149/learning/)\n\n难度: 简单\n\n标签: 模拟, BFS, 2020, 省模拟赛\n\n**题目描述:**\n\n小明有一块空地，他将这块空地划分为 *n* 行 *m* 列的小块，每行和每列的长度都为 1。\n\n小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。\n\n这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，\n\n这四小块空地都将变为有草的小块。请告诉小明，*k* 个月后空地上哪些地方有草。\n\n**输入描述:**\n\n输入的第一行包含两个整数 ,*n*,*m*。\n\n接下来 *n* 行，每行包含 *m* 个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 *g*，表示种了草。\n\n接下来包含一个整数 *k*。 其中，2≤,≤1000，1≤≤10002≤*n*,*m*≤1000，1≤*k*≤1000。\n\n**输出描述:**\n\n输出 *n* 行，每行包含 *m* 个字母，表示 *k* 个月后空地的状态。如果为小数点，表示为空地，如果字母为 *g*，表示长了草。\n\n**输入输出样例:**\n\n**示例:**\n\n**输入:**\n\n```txt\n4 5\n.g...\n.....\n..g..\n.....\n2\n```\n\n**输出:**\n\n```txt\ngggg.\ngggg.\nggggg\n.ggg.\n```\n\n**运行限制:**\n\n```txt\n    最大运行时间：1s\n    最大运行内存: 256M\n```\n\n**解题思路:**\n\n这个题目简直就是为了广度优先搜索设置模板题，由于这个题目时输出广度优先搜索 `K` 次扩展后的终态，那我们就不用设置 `Check` 函数。\n\n这里用一个 ×*N*×*M* 的矩阵来表示草地。\n\n1. 算法开始：\n\n   将字母为 `g` 的草地的位置加入队列，然后向下执行\n\n2. 判断边界：\n\n   判断是否已经长了草，判断是否超出边界范围\n\n3. 搜索过程：\n\n   不断从队列取出一个节点，进行上下左右的扩展，执行 `2` 判断边界，符合就放入队列，不符合就跳过。\n\n   执行 K 次扩展，输出草地状态。\n\n4. check(参数)：\n\n   这里不需要进行 `Check`\n\nC++ 语言描述:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 1005;\nstruct PII\n{\n    int first;\n    int second;\n};\n// C++ 有个数据类型叫 pair 上面的就可以定义为 pair<int,int> 用起来比较方便。\nPII tempPair;//临时结点\nchar Map[M][M];\n//---------图的路径搜索常用方向移动表示-------\nint dx[4]= {0,1,-1,0};\nint dy[4]= {1,0,0,-1};\n// 两两组合形成上下左右四个方向\n//      1------------------> x\n//      |\n//      |\n//      |\n//      |\n//      |\n//      |\n//      |\n//      ↓\n//      y\n\n// dx[0]=0 dy[0]=1 那么代表向下的方向\n\n// dx[1]=1 dy[1]=0 那么代表向右的方向\n\n// dx[2]=-1 dy[0]=0 那么代表向左的方向\n\n// dx[3]=0 dy[1]=-1 那么代表向上的方向\n\nint n;// n 行\nint m;// m 列\nint k;// k 次\n\nqueue<PII > q; //广度优先搜索所用的队列\n\nint len;//记录节点数量方便后续k的计算\nbool pd(int x, int y)\n{\n    if(x<1)\n        return 0;\n    // /x 轴坐标 左侧越界\n    else if(x>n)\n        return 0;\n    //x 轴坐标 右侧越界\n    else  if(y<1)\n        return 0;\n    //y 轴坐标 上侧越界\n    else if(y>m)\n        return 0;\n    //y 轴坐标 下侧越界\n    else if(Map[x][y]=='g')\n        return 0;\n    //已经长草了\n    else return 1;\n    // 在范围内，且没长草\n}\n\nvoid BFS()\n{\n    //BFS\n    while(!q.empty()&&k>0)\n    {\n        tempPair = q.front();\n        q.pop();\n        //这两步是取出队首的节点\n\n        int x = tempPair.first;//横坐标\n        int y = tempPair.second;//纵坐标\n\n        for(int i=0; i<4; i++)\n        {\n            int nowx = x+dx[i]; //扩展后的横坐标\n            int nowy = y+dy[i]; //扩展后的纵坐标\n\n            if(pd(nowx,nowy))\n            {\n                q.push({nowx,nowy});\n                Map[nowx][nowy]='g';\n            }\n            //符合要求执行扩展，不符合要求，忽略即可。\n        }\n\n        len--; //没取出一个节点len  -1\n        if(len==0)\n        {\n            //当len =0 时，代表当前层扩展完了，那么就代表第一个月扩展完了\n            k--; // 所以k--\n            len = q.size(); // 当前层扩展完了，那就该扩展下一层了，所以len又被赋值为下一层的节点数目的值\n        }\n    }\n}\nint main()\n{\n    cin>>n>>m;\n    for(int i=1; i<=n; i++)\n    {\n        for(int j=1; j<=m; j++)\n        {\n            cin>>Map[i][j];\n            if(Map[i][j]=='g')\n            {\n                tempPair.first=i;\n                tempPair.second=j;\n               // cout<<i<<\"\"<<j<<endl;\n                q.push(tempPair);//将初始有树的结点加入队列\n            }\n        }\n    }\n\n    len = q.size();//记录第一层的节点数量方便后续k的计算\n    cin>>k;\n    BFS();\n    for(int i=1; i<=n; i++)\n    {\n        for(int j=1; j<=m; j++)\n        {\n            cout<<Map[i][j];\n        }\n\n        cout<<endl;\n    }\n    return 0;\n}\n```\n\nPython 语言描述:\n\n```python\n# 请在此输入您的代码\nfrom queue import Queue\n\ndx = [0, 1, -1, 0]\ndy = [1, 0, 0, -1]\n\n# 两两组合形成上下左右四个方向\n#      1------------------> x\n#      |\n#      |\n#      |\n#      |\n#      |\n#      |\n#      |\n#      ↓\n#      y\n\n# dx[0]=0 dy[0]=1 那么代表向下的方向\n# dx[1]=1 dy[1]=0 那么代表向右的方向\n# dx[2]=-1 dy[0]=0 那么代表向左的方向\n# dx[3]=0 dy[1]=-1 那么代表向上的方向\n\nMap = []\n\nq = Queue()\n\nn = 0\nm = 0\nk = 0\n\nlength = 0\n\ndef pd(x, y):\n    global n, m, Map\n    if x < 0:\n        return False\n    # x 轴坐标左侧越界\n    elif x >= n:\n        return False\n    # x 轴坐标右侧越界\n    elif y < 0:\n        return False\n    # y轴坐标上侧越界\n    elif y >= m:\n        return False\n    # y 轴坐标下侧越界\n    elif Map[x][y] == 'g':\n        return False\n    # 已经长草了\n    else:\n        return True\n    # 在范围内，且没长草\n\n\ndef BFS():\n\n    global k, q, n, m, Map, length\n    while k > 0 & (not q.empty()):\n        tempPair = q.get()\n        x = tempPair[0]  # 横坐标\n        y = tempPair[1]  # 纵坐标\n        nowx=x+1\n        if (pd(nowx, y)):\n            q.put((nowx, y))\n            Map[nowx][y] = 'g'\n\n        nowx=x-1\n        if (pd(nowx, y)):\n            q.put((nowx, y))\n            Map[nowx][y] = 'g'\n\n        nowy=y+1\n        if (pd(x, nowy)):\n            q.put((nowx, nowy))\n            Map[x][nowy] = 'g'\n\n        nowy=y-1\n        if (pd(x, nowy)):\n            q.put((nowx, nowy))\n            Map[x][nowy] = 'g'\n\n        length -= 1\n        if length == 0:\n            k -= 1\n            length = q.qsize()\n\nif __name__ == '__main__':\n\n    n, m = map(int, input().split())\n    Map = [[0 for _ in range(m)] for _ in range(n)]  # Python 动态开数组会减少运行时间\n    for i in range(n):\n        input_ = input()\n        for j in range(m):\n            Map[i][j] = input_[j]\n            if Map[i][j] == 'g':\n                q.put((i, j))\n\n    k = int(input())\n    length = q.qsize()\n    BFS()\n    for i in range(n):\n        str_temp = ''\n        for j in range(m):\n            str_temp += Map[i][j]\n        print(str_temp)\n```\n\n**重点:**\n\nPython 的 Queue 非常耗费时间，强烈建议大家使用 list 进行模拟\n\n下面是用 List 模拟，使用 Queue 耗时 3000 ms , 使用 list 模拟仅消耗 54 ms 所以大家使用 Python 编写代码的时候还是使用 List 尽量避免 Queue 的使用。\n\n```python\n# 请在此输入您的代码\nfrom queue import Queue\n\ndx = [0, 1, -1, 0]\ndy = [1, 0, 0, -1]\n\n# 两两组合形成上下左右四个方向\n#      1------------------> x\n#      |\n#      |\n#      |\n#      |\n#      |\n#      |\n#      |\n#      ↓\n#      y\n\n# dx[0]=0 dy[0]=1 那么代表向下的方向\n# dx[1]=1 dy[1]=0 那么代表向右的方向\n# dx[2]=-1 dy[0]=0 那么代表向左的方向\n# dx[3]=0 dy[1]=-1 那么代表向上的方向\n\nMap = []\n\nq = []\nqfront = 0\nqend = 0\n\nn = 0\nm = 0\nk = 0\n\nlength = 0\n\n\ndef pd(x, y):\n    if x < 0:\n        return False\n    # x 轴坐标左侧越界\n    elif x >= n:\n        return False\n    # x 轴坐标右侧越界\n    elif y < 0:\n        return False\n    # y轴坐标上侧越界\n    elif y >= m:\n        return False\n    # y 轴坐标下侧越界\n    elif Map[x][y] == 'g':\n        return False\n    # 已经长草了\n    else:\n        return True\n    # 在范围内，且没长草\n\n\ndef BFS():\n    global k, q, n, m, Map, length, qend, qfront\n    # print(\"K Length\", k, length)\n    while k > 0 and length > 0:\n        tempPair = q[qfront]\n        qfront += 1\n        x = tempPair[0]  # 横坐标\n        y = tempPair[1]  # 纵坐标\n        for i in range(4):\n\n            nowx = x + dx[i]  # 扩展后的横坐标\n            nowy = y + dy[i]  # 扩展后的纵坐标\n\n            if (pd(nowx, nowy)):\n                q.append((nowx,nowy))\n                qend += 1\n                Map[nowx][nowy] = 'g'\n        length -= 1\n        if length == 0:\n            k -= 1\n            length = qend - qfront\n\n\nif __name__ == '__main__':\n\n    n, m = map(int, input().split())\n    Map = [[0 for _ in range(m)] for _ in range(n)]  # Python 动态开数组会减少运行时间\n\n    for i in range(n):\n        input_ = input()\n        for j in range(m):\n            Map[i][j] = input_[j]\n            if Map[i][j] == 'g':\n                q.append((i,j))\n                qend += 1\n\n    k = int(input())\n    length = qend - qfront\n    BFS()\n    for i in range(n):\n        str_temp = ''\n        for j in range(m):\n            str_temp += Map[i][j]\n        print(str_temp)\n```\n\nJava 语言描述:\n\n```java\nimport java.util.*;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport static java.lang.Math.abs;\n\npublic class Main {\n\n    static final int M = 1005;\n    static class PII\n    {\n        public int first;\n        public int second;\n    };\n\n    static String Map[]=new String[M];\n//---------图的路径搜索常用方向移动表示-------\n    static int dx[]= {0,1,-1,0};\n    static  int dy[]= {1,0,0,-1};\n\n// 两两组合形成上下左右四个方向\n//      1------------------> x\n//      |\n//      |\n//      |\n//      |\n//      |\n//      |\n//      |\n//      ↓\n//      y\n\n// dx[0]=0 dy[0]=1 那么代表向下的方向\n// dx[1]=1 dy[1]=0 那么代表向右的方向\n// dx[2]=-1 dy[0]=0 那么代表向左的方向\n// dx[3]=0 dy[1]=-1 那么代表向上的方向\n\n    static int n;// n 行\n    static int m;// m 列\n    static int k;// k 次\n\n    static Queue<PII > q= new LinkedBlockingQueue<>();\n    //广度优先搜索所用的队列\n\n    static int len;//记录节点数量方便后续k的计算\n    static boolean pd(int x, int y)\n    {\n\n        if(x<1)\n            return false;\n            // /x 轴坐标 左侧越界\n        else if(x>n)\n            return false;\n            //x 轴坐标 右侧越界\n        else  if(y<1)\n            return false;\n            //y 轴坐标 上侧越界\n        else if(y>m)\n            return false;\n            //y 轴坐标 下侧越界\n        else if(Map[x].charAt(y)=='g')\n            return false;\n            //已经长草了\n        else return true;\n        // 在范围内，且没长草\n    }\n\n    static void BFS()\n    {\n        //BFS\n        while(q.size()!=0&&k>0)\n        {\n            PII tempPair= q.peek();\n            q.poll();\n            //这两步是取出队首的节点\n//            System.out.println(q.size());\n            int x = tempPair.first;//横坐标\n            int y = tempPair.second;//纵坐标\n            for(int i=0; i<4; i++)\n            {\n                int nowx = x+dx[i]; //扩展后的横坐标\n                int nowy = y+dy[i]; //扩展后的纵坐标\n                if(pd(nowx,nowy))\n                {\n                    PII tempPair2=new PII();//临时结点\n                    tempPair2.first=nowx;\n                    tempPair2.second=nowy;\n                    q.add(tempPair2);\n                    StringBuilder strBuilder = new StringBuilder(Map[nowx]);\n                    strBuilder.setCharAt(nowy, 'g');\n                    Map[nowx]=strBuilder.toString();\n                }\n                //符合要求执行扩展，不符合要求，忽略即可。\n            }\n            len--; //没取出一个节点len  -1\n            if(len==0)\n            {\n                //当len =0 时，代表当前层扩展完了，那么就代表第一个月扩展完了\n                k--; // 所以k--\n                len = q.size(); // 当前层扩展完了，那就该扩展下一层了，所以len又被赋值为下一层的节点数目的值\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        m = in.nextInt();\n        for(int i=1; i<=n; i++)\n        {\n            Map[i]=new String(\" \" +in.next());\n            for(int j=1; j<=m; j++)\n            {\n                char temChar = Map[i].charAt(j);\n                if(temChar=='g')\n                {\n                    PII tempPair=new PII();//临时结点\n                    tempPair.first=i;\n                    tempPair.second=j;\n                    q.offer(tempPair);//将初始有草的结点加入队列\n                }\n            }\n        }\n\n        len = q.size();//记录第一层的节点数量方便后续k的计算\n        k= in.nextInt();\n        BFS();\n        for(int i=1; i<=n; i++)\n        {\n            System.out.println(Map[i]);\n        }\n\n    }\n}\n```\n\n### 走迷宫 ###\n\n[题目链接](https://www.lanqiao.cn/problems/1216/learning/)\n\n难度: 简单\n\n标签: BFS\n\n**题目描述:**\n\n给定一个 ×*N*×*M* 的网格迷宫 *G*。*G* 的每个格子要么是道路，要么是障碍物（道路用 11 表示，障碍物用 00 表示）。\n\n已知迷宫的入口位置为 (1,1)(*x*1,*y*1)，出口位置为 (2,2)(*x*2,*y*2)。问从入口走到出口，最少要走多少个格子。\n\n**输入:**\n\n输入第 11 行包含两个正整数 ,*N*,*M*，分别表示迷宫的大小。\n\n接下来输入一个 ×*N*×*M* 的矩阵。若 ,=1*G**i*,*j*=1 表示其为道路，否则表示其为障碍物。\n\n最后一行输入四个整数 1,1,2,2*x*1,*y*1,*x*2,*y*2，表示入口的位置和出口的位置。\n\n1≤,≤1021≤*N*,*M*≤102，0≤,≤10≤*G**i*,*j*≤1，1≤1,2≤1≤*x*1,*x*2≤*N*，1≤1,2≤1≤*y*1,*y*2≤*M*。\n\n**输出：**\n\n输出仅一行，包含一个整数表示答案。\n\n若无法从入口到出口，则输出 −1−1。\n\n**输入输出样例：**\n\n输入\n\n```txt\n5 5\n1 0 1 1 0\n1 1 0 1 1\n0 1 0 1 1\n1 1 1 1 1\n1 0 0 0 1\n1 1 5 5\n```\n\n输出\n\n```txt\n8\n```\n\n**运行限制:**\n\n```txt\n最大运行时间：1s\n最大运行内存: 128M\n```\n\n**解题思路:**\n\n1. **算法开始：**\n\n   我们以起点开始做 BFS ，将入口压入栈开始执行 BFS 算法\n\n2. **判断边界：**\n\n   在当前行，当前列的位置上判断是否满足条件，若不满足，跳到第 5 步，即不符合边界条件。 判断条件如下：\n\n   1. [][]*v**i**s*[*x*][*y*] >= 1 标记数组已经被标记，已被走过，不能再走，超出边界\n   2. <1*x*<1 从左侧走出方格\n   3. >*x*>*n* 从右侧走出方格\n   4. <1*y*<1 从上侧走出方格\n   5. >*y*>*n* 从下侧走出方格\n   6. [][]*m**a**p*[*x*][*y*] != 1 没有路不能走\n\n3. **搜索过程：**\n\n   调用 Check 函数。\n\n   如果边界条件满足，就继续调用搜索，找到下一步的位置\n\n   每次找到下一个位置的时候，令其 [][]*V**i**s*[*n**e**x**t**x*][*n**e**x**t**y*] = 当前 +1*V**i**s*+1\n\n   这样既能用 *v**i**s* 数组标记又能使用 *v**i**s* 数组存步数，从 11 开始，即开始节点是 11 ，所以最后要减去 11 。\n\n4. **check(参数)：**\n\n   如果当搜索到 =终点*x*=终点*x*, =终点*y*=终点*y* 时，就找到了终点，此时他的 *V**i**s* 数组就存储了他的步数，但是是从 11 开始的。\n\nC++ 语言描述:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint vis[150][150]; //用于存储是否访问过，并且存储长度\n\nchar G[150][150]; //用于存储题目给出的地图\n\nint n,m,ans=0;\n\nint dx[4] = {0,0,-1,1};\n\nint dy[4] = {1,-1,0,0};\n\n//上下左右移动，不会的看前面的代码\n\nstruct node\n{\n    int x;\n    int y;\n};\n\nnode Start,End;\nbool pd(int x,int y)\n{\n\n\n    if(x<1)\n        return 0;\n    //从左侧走出方格\n\n    else if(x>n)\n        return 0;\n    //从右侧走出方格\n\n    else if(y<1)\n        return 0;\n    //从上侧走出方格\n\n    else if(y>m)\n        return 0;\n    //从下侧走出方格\n\n    else if( vis[x][y]!=0)\n        //已经访问了\n        return 0;\n    else if(G[x][y]!='1') return 0;\n    //不是路不能走\n    else return 1;\n}\n\nbool  check(int x, int y)\n{\n\n    if(x == End.x&& y == End.y)   //找到终点，把距离给他\n    {\n        ans  =  vis[x][ y];\n        return 1;\n    }\n\n    else    return 0;\n\n}\nvoid bfs()\n{\n    queue<node>q;\n\n    node now,next;\n\n    q.push(Start);     //将起点压人队列中\n\n    vis[Start.x][Start.y] = 1;\n\n    while(!q.empty())\n    {\n        now = q.front();\n\n        if(check(now.x,now.y))\n            return ;\n\n        q.pop();     //将队列最前面的弹出。\n\n        for(int i=0; i<4; i++)  //四个方向\n        {\n\n            int nextx = now.x + dx[i];\n            int nexty = now.y + dy[i];\n\n            if(pd(nextx,nexty))  //判断是否符合条件\n            {\n\n                next.x=nextx;\n                next.y=nexty;\n\n                q.push(next);\n\n                vis[nextx][nexty] = vis[now.x][now.y]+1; //步数+1\n            }\n        }\n    }\n}\nint main()\n{\n    cin>>n>>m;\n    //memset(vis,0,sizeof(vis));\n    for(int i=1; i<=n; i++)\n    {\n        for(int j=1; j<=m; j++)\n        {\n            cin>>G[i][j];\n        }\n    }\n\n    cin>>Start.x>>Start.y>>End.x>>End.y;\n\n    ans = 0;\n\n    bfs();\n    cout<<ans-1<<endl;\n\n    return 0;\n}\n```\n\nPython 语言描述:\n\n```python\ndx = [0, 1, -1, 0]\n\ndy = [1, 0, 0, -1]\n\nG = []\n\nVis = []\n\n# --------队列模拟-----------\nq = []                   # |\n                         # |\nqfront = 0               # |\n                         # |\nqend = 0                 # |\n# --------队列模拟-----------\n\n\nn = 0\nm = 0\nans = 0\n\nstartX=0\nstartY=0\n\nendX=0\nendY=0\n\ndef pd(x, y):\n    if x < 1:\n        return False\n\n    # x 轴坐标左侧越界\n\n    elif x > n:\n        return False\n    # x 轴坐标右侧越界\n\n    elif y < 1:\n        return False\n    # y轴坐标上侧越界\n\n    elif y > m:\n        return False\n    # y 轴坐标下侧越界\n\n    elif Vis[x][y]!=0:\n        return False\n    #已经访问了\n    elif G[x][y] != '1':\n        return False\n    # 已经访问了\n    else:\n        return True\n\n    # 在范围内，且没长草\n\ndef check( x,  y):\n\n    global ans\n    if x == endX and y == endY :  #找到终点，把距离给他\n\n        ans  =  Vis[x][y];\n\n        return True;\n\n    else   :\n        return False;\n\ndef BFS():\n\n\n    global qend ,qfront\n\n    q.append((startX,startY))\n\n    qend+=1\n\n    Vis[startX][startY]=1\n\n    while qend-qfront!=0:\n\n        tempPair = q[qfront]\n        qfront+=1\n\n        x = tempPair[0]  # 横坐标\n\n        y = tempPair[1]  # 纵坐标\n        if check(x,y):\n            return\n\n        for i in range(4):\n\n            nowx = x + dx[i]  # 扩展后的横坐标\n\n            nowy = y + dy[i]  # 扩展后的纵坐标\n\n            if (pd(nowx, nowy)):\n\n                q.append((nowx,nowy))\n                qend+=1\n\n                Vis[nowx][nowy] = Vis[x][ y] + 1\n\n\nif __name__ == '__main__':\n\n    n, m = map(int, input().split())\n\n    G = [[0 for _ in range(m+10)] for _ in range(n+10)]  # Python 动态开数组会减少运行时间\n\n    Vis = [[0 for _ in range(m+10)] for _ in range(n+10)]  # Python 动态开数组会减少运行时间\n\n    for i in range(n):\n        input_ = input().split()\n        for j in range(m):\n            G[i+1][j+1] = input_[j]\n\n    startX ,startY , endX ,endY = map(int, input().split())\n\n    BFS()\n\n    print(ans-1)\n```\n\nJava 语言描述:\n\n```java\nimport java.util.*;\nimport java.util.concurrent.LinkedBlockingQueue;\n\nimport static java.lang.Math.abs;\n\npublic class Main {\n\n    static final int M = 1005;\n    static class node {\n        public int x;\n        public int y;\n\n        public node(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    static int n, m, ans = 0;\n    static int vis[][] = new int[150][150]; //用于存储是否访问过，并且存储长度\n    static int G[][] = new int[150][150];  //用于存储题目给出的地图\n    static node Start, End;\n//---------图的路径搜索常用方向移动表示-------\n    static int dx[] = {0, 1, -1, 0};\n    static int dy[] = {1, 0, 0, -1};\n    static Queue<node> q = new LinkedBlockingQueue<>();\n    //广度优先搜索所用的队列\n    static boolean pd(int x, int y) {\n\n        if (x < 1)\n            return false;\n            // /x 轴坐标 左侧越界\n        else if (x > n)\n            return false;\n            //x 轴坐标 右侧越界\n        else if (y < 1)\n            return false;\n            //y 轴坐标 上侧越界\n        else if (y > m)\n            return false;\n            //y 轴坐标 下侧越界\n        else if (vis[x][y] != 0)\n            //已经访问了\n            return false;\n        else if (G[x][y] != 1)\n            //不能走\n            return false;\n        else return true;\n        // 在范围内，且没长草\n    }\n\n    static boolean check(int x, int y) {\n        if (x == End.x && y == End.y)   //找到终点，把距离给他\n        {\n            ans = vis[x][y];\n            return true;\n        } else return false;\n    }\n\n    static void BFS() {\n        q.add(Start);\n        vis[Start.x][Start.y] = 1;\n        node now, next;\n        while (q.size() != 0) {\n            now = q.peek();\n            if (check(now.x, now.y))\n                return;\n            q.poll();\n            //这两步是取出队首的节点\n            for (int i = 0; i < 4; i++)  //四个方向\n            {\n                int nextx = now.x + dx[i];\n                int nexty = now.y + dy[i];\n                if (pd(nextx, nexty))  //判断是否符合条件\n                {\n                    next = new node(nextx, nexty);\n                    q.add(next);\n                    vis[nextx][nexty] = vis[now.x][now.y] + 1; //步数+1\n                }\n            }\n        }\n    }\n    public static void main(String[] args) {\n\n        Scanner in = new Scanner(System.in);\n\n        n = in.nextInt();\n        m = in.nextInt();\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                G[i][j] = in.nextInt();\n            }\n        }\n\n        int startX = in.nextInt();\n        int startY = in.nextInt();\n        int endX = in.nextInt();\n        int endY = in.nextInt();\n\n        Start=new node(startX,startY);\n        End=new node(endX,endY);\n        BFS();\n\n        System.out.println(ans-1);\n    }\n}\n```\n\n### 迷宫 ###\n\n下图给出了一个迷宫的平面图，其中标记为 11 的为障碍，标记为 00 的为可以通行的地方。\n\n```txt\n010000\n000100\n001001\n110000\n```\n\n迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这个它的上、下、左、右四个方向之一。\n\n对于上面的迷宫，从入口开始，可以按 `DRRURRDDDR` 的顺序通过迷宫， 一共 1010 步。其中 、、、*D*、*U*、*L*、*R* 分别表示向下、向上、向左、向右走。 对于下面这个更复杂的迷宫（3030 行 5050 列），请找出一种通过迷宫的方式，其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。\n\n请注意在字典序中 <<<*D*<*L*<*R*<*U*。\n\n```txt\n01010101001011001001010110010110100100001000101010\n00001000100000101010010000100000001001100110100101\n01111011010010001000001101001011100011000000010000\n01000000001010100011010000101000001010101011001011\n00011111000000101000010010100010100000101100000000\n11001000110101000010101100011010011010101011110111\n00011011010101001001001010000001000101001110000000\n10100000101000100110101010111110011000010000111010\n00111000001010100001100010000001000101001100001001\n11000110100001110010001001010101010101010001101000\n00010000100100000101001010101110100010101010000101\n11100100101001001000010000010101010100100100010100\n00000010000000101011001111010001100000101010100011\n10101010011100001000011000010110011110110100001000\n10101010100001101010100101000010100000111011101001\n10000000101100010000101100101101001011100000000100\n10101001000000010100100001000100000100011110101001\n00101001010101101001010100011010101101110000110101\n11001010000100001100000010100101000001000111000010\n00001000110000110101101000000100101001001000011101\n10100101000101000000001110110010110101101010100001\n00101000010000110101010000100010001001000100010101\n10100001000110010001000010101001010101011111010010\n00000100101000000110010100101001000001000000000010\n11010000001001110111001001000011101001011011101000\n00000110100010001000100000001000011101000000110011\n10101000101000100010001111100010101001010000001000\n10000010100101001010110000000100101010001011101000\n00111100001000010000000110111000000001000000001011\n10000001100111010111010001000110111010101101111000\n```\n\n**解题思路:**\n\n本题是一道简单的搜索题，需要注意的是要按照题目给定的字典序进行搜索，最后输出路径。\n\n我们使用 *B**F**S* 搜索记录路径，用 *D**F**S* 打印路径。\n\nC++ 语言描述：\n\n```c\n#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 2000\n\nstring maze[maxn]= {\n                  \"01010101001011001001010110010110100100001000101010\",\n                  \"00001000100000101010010000100000001001100110100101\",\n                  \"01111011010010001000001101001011100011000000010000\",\n                  \"01000000001010100011010000101000001010101011001011\",\n                  \"00011111000000101000010010100010100000101100000000\",\n                  \"11001000110101000010101100011010011010101011110111\",\n                  \"00011011010101001001001010000001000101001110000000\",\n                  \"10100000101000100110101010111110011000010000111010\",\n                  \"00111000001010100001100010000001000101001100001001\",\n                  \"11000110100001110010001001010101010101010001101000\",\n                  \"00010000100100000101001010101110100010101010000101\",\n                  \"11100100101001001000010000010101010100100100010100\",\n                  \"00000010000000101011001111010001100000101010100011\",\n                  \"10101010011100001000011000010110011110110100001000\",\n                  \"10101010100001101010100101000010100000111011101001\",\n                  \"10000000101100010000101100101101001011100000000100\",\n                  \"10101001000000010100100001000100000100011110101001\",\n                  \"00101001010101101001010100011010101101110000110101\",\n                  \"11001010000100001100000010100101000001000111000010\",\n                  \"00001000110000110101101000000100101001001000011101\",\n                  \"10100101000101000000001110110010110101101010100001\",\n                  \"00101000010000110101010000100010001001000100010101\",\n                  \"10100001000110010001000010101001010101011111010010\",\n                  \"00000100101000000110010100101001000001000000000010\",\n                  \"11010000001001110111001001000011101001011011101000\",\n                  \"00000110100010001000100000001000011101000000110011\",\n                  \"10101000101000100010001111100010101001010000001000\",\n                  \"10000010100101001010110000000100101010001011101000\",\n                  \"00111100001000010000000110111000000001000000001011\",\n                  \"10000001100111010111010001000110111010101101111000\"};\nbool vis[maxn][maxn];//标记\nint dir[4][2]={{1,0},{0,-1},{0,1},{-1,0}};//D L R U\n\nbool in(int x,int y)\n{\n    return x<30&&x>=0&&y>=0&&y<50;\n}\n\nstruct node\n{\n    int x,y,d;\n    char pos;//存储D L R U\n};\n\nnode father[maxn][maxn];//当前节点的父节点\nnode now,nex;//指向当前和下一个位置\n\nvoid dfs(int x,int y)//递归打印\n{\n    if(x==0&&y==0)//找到起点开始正向打印路径\n        return;\n    else\n        dfs(father[x][y].x,father[x][y].y);\n\n    cout<<father[x][y].pos;\n}\n\nvoid bfs(int x,int y)\n{\n    queue<node> q;\n\n    now.x=x;\n    now.y=y;\n    now.d=0;\n    q.push(now);\n\n    vis[x][y]=true;\n    while(!q.empty())\n    {\n        now=q.front();\n        q.pop();\n        for(int i=0;i<4;i++)//走下左右上按字典序的四个方向\n        {\n            int tx=now.x+dir[i][0];\n            int ty=now.y+dir[i][1];\n            if(in(tx,ty)&&!vis[tx][ty]&&maze[tx][ty]!='1')//判断是否超出范围，是否用过，是否为1\n            {\n                vis[tx][ty]=true;//标记为用过\n\n                nex.x=tx;\n                nex.y=ty;\n                nex.d=now.d+1;\n                q.push(nex);//压入队列\n\n                father[tx][ty].x=now.x;//存储父节点坐标\n                father[tx][ty].y=now.y;\n                if(i==0)//存储路径\n                    father[tx][ty].pos='D';\n                else if(i==1)\n                    father[tx][ty].pos='L';\n                else if(i==2)\n                    father[tx][ty].pos='R';\n                else if(i==3)\n                    father[tx][ty].pos='U';\n\n\n            }\n        }\n    }\n}\n\nint main()\n{\n\n    bfs(0,0);\n    dfs(29,49);//打印路径\n\n    return 0;\n}\n```\n\nJava 语言描述:\n\n```java\nimport java.util.*;\npublic class Main {\n    private static String[] nn= {\n                  \"01010101001011001001010110010110100100001000101010\",\n                  \"00001000100000101010010000100000001001100110100101\",\n                  \"01111011010010001000001101001011100011000000010000\",\n                  \"01000000001010100011010000101000001010101011001011\",\n                  \"00011111000000101000010010100010100000101100000000\",\n                  \"11001000110101000010101100011010011010101011110111\",\n                  \"00011011010101001001001010000001000101001110000000\",\n                  \"10100000101000100110101010111110011000010000111010\",\n                  \"00111000001010100001100010000001000101001100001001\",\n                  \"11000110100001110010001001010101010101010001101000\",\n                  \"00010000100100000101001010101110100010101010000101\",\n                  \"11100100101001001000010000010101010100100100010100\",\n                  \"00000010000000101011001111010001100000101010100011\",\n                  \"10101010011100001000011000010110011110110100001000\",\n                  \"10101010100001101010100101000010100000111011101001\",\n                  \"10000000101100010000101100101101001011100000000100\",\n                  \"10101001000000010100100001000100000100011110101001\",\n                  \"00101001010101101001010100011010101101110000110101\",\n                  \"11001010000100001100000010100101000001000111000010\",\n                  \"00001000110000110101101000000100101001001000011101\",\n                  \"10100101000101000000001110110010110101101010100001\",\n                  \"00101000010000110101010000100010001001000100010101\",\n                  \"10100001000110010001000010101001010101011111010010\",\n                  \"00000100101000000110010100101001000001000000000010\",\n                  \"11010000001001110111001001000011101001011011101000\",\n                  \"00000110100010001000100000001000011101000000110011\",\n                  \"10101000101000100010001111100010101001010000001000\",\n                  \"10000010100101001010110000000100101010001011101000\",\n                  \"00111100001000010000000110111000000001000000001011\",\n                  \"10000001100111010111010001000110111010101101111000\"};\n    private static char[][] tu=new char[30][50];\n    private static int[][] dis=new int[30][50];\n    private static int[][] step= {{1,0},{0,-1},{0,1},{-1,0}};\n    private static char[] direction= {'D','L','R','U'};\n//    保存经过的每一个点位置信息，采用(x)*m+y的公式表示(x,y);x,y从0开始，位置也是从来开始。m:大于最长边的随便一个数\n//    起点:0;终点:29*50-49\n    private static Queue<Integer> location=new LinkedList<Integer>();\n//    广度优先遍历求每一个位置到终点的距离，并存放在dis中\n//    广度优先遍历寻找所有从终点到起点的路线\n    public static void bfs() {//x,y当前位置;\n        int x,y;//当前位置坐标\n        //不为空，继续循环\n        while(!location.isEmpty()) {\n            int l=location.poll();//获取当前位置的坐标\n            x=l/50;//获取当前位置x\n            y=l%50;//获取当前位置y\n            for(int i=0;i<4;i++) {//探索四个方向\n                int xx=x+step[i][0];\n                int yy=y+step[i][1];\n                if(xx>=0&&xx<30&&yy>=0&&yy<50&&tu[xx][yy]=='0'&&dis[xx][yy]==0) {\n                    dis[xx][yy]=dis[x][y]+1;//当前位置的距离+1等于本次探索位置的距离\n                    location.add(xx*50+yy);\n                    if(xx==0&&yy==0) {\n                        break;\n                    }\n                }\n            }\n\n        }\n    }\n//    深度优先遍历，从起点到终点\n    public static String dfs() {\n        dis[29][49]=0;\n//        起点\n        int x=0;\n        int y=0;\n        String route=\"\";\n        while(x!=29||y!=49) {\n            for(int i=0;i<4;i++) {\n                int xx=x+step[i][0];\n                int yy=y+step[i][1];\n                if(xx>=0&&xx<30&&yy>=0&&yy<50&&tu[xx][yy]=='0') {\n                    if(dis[x][y]==dis[xx][yy]+1) {\n                        x=xx;\n                        y=yy;\n                        route+=direction[i];\n                        break;\n                    }\n                }\n            }\n        }\n        return route;\n    }\n\n    public static void main(String[] args) {\n        long num=0;\n        for(int i=0;i<30;i++) {\n            tu[i]=nn[i].toCharArray();\n        }\n        location.add(29*50+49);\n        bfs();\n        String route=dfs();\n        System.out.println(route);\n    }\n}\n```\n\nPython 语言描述:\n\n```python\nfrom collections import deque\nn,m=30,50\nM=[[int(i) for i in input()]for j in range(n)]\nvis=[[0]*m for i in range(n)]\ngo=[['']*m for i in range(n)]\nq=deque([(0,0)])\nvis[0][0]=1\nwhile q:\n    x,y=q.popleft()\n    if x==n-1 and y==m-1:\n        print(go[-1][-1])\n        break\n    for i,j,k in [[1,0,'D'],[0,-1,'L'],[0,1,'R'],[-1,0,'U']]:\n        a,b=x+i,y+j\n        if 0<=a<n and 0<=b<m and M[a][b]==0 and vis[a][b]==0:\n            vis[a][b]=1\n            q.append((a,b))\n            go[a][b]=go[x][y]+k\n```\n\n## 实验总结 ##\n\nBFS 是广度优先搜索，是将某节点所有的“枝蔓”加入搜索队列，然后去除队列的首部的节点，重复进行该动作，这样就能由开始状态“一圈一圈的查找”。 BFS 拥有一个性质，那么就是先找到的节点，所经过的步骤一定最短。它一般用于寻找在近的状态，也是一个非常基础的算法，希望大家认真学习。\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯冲刺营","3.搜索算法"]},{"title":"递归与递推","url":"/2024/02/22/递归与递推/","content":"\n# 递推法与递归法 #\n\n**递推法：**\n\n递推法是一种在数学和其他领域广泛应用的重要方法，它在计算机科学中被用作一种关键的数值求解算法。\n\n**知识点：**\n\n- 递推算法\n- 递归算法\n\n## 递推算法的特点 ##\n\n递推法的核心在于找到递推关系式。这种方法可以将复杂的计算过程转化为简单的重复步骤，充分利用计算机在运行程序时的时间局部性和空间局部性。\n\n**递推算法的思想：**\n\n1. 首先找到各个相邻数据项之间的递推关系；\n2. 递推关系避开了求通项公式的麻烦，尤其是对于那些难以或无法求解通项公式的题目；\n3. 将复杂问题分解为若干步骤的简单运算；\n4. 一般来说，递推算法可以视为一种特殊的迭代算法。\n\n**递推算法解题的基本思路：**\n\n1. 将复杂计算转换为简单重复运算；\n2. 通过找到递推关系式进行简化运算；\n3. 利用计算机的特性，减少运行时间。\n\n**递推算法的一般步骤：**\n\n1. 根据题目确定数据项，并找到符合要求的递推关系式；\n2. 根据递推关系式设计递推程序；\n3. 根据题目找到递推的终点；\n4. 单次查询可以不进行存储，多次查询都要进行存储；\n5. 按要求输出答案即可。\n\n**递归算法：**\n\n递归算法是一种自顶向下的算法，它通过不断地直接或间接调用自身的函数，通过每次改变变量完成多个过程的重复计算，直到到达边界之后，结束调用。\n\n与递推法相似的是，递归与递推都是将一个复杂过程分解为几个简单重复步骤进行计算。\n\n递归算法的实现的核心是分治策略，即分而治之，将复杂过程分解为规模较小的同类问题，通过解决若干个小问题，进而解决整个复杂问题。\n\n**递归算法的思想：**\n\n1. 将复杂计算过程转换为简单重复子过程；\n2. 找到递归公式，即能够将大问题转化为小问题的公式；\n3. 自上而下计算，在返回完成递归过程。\n\n**递归算法设计的一般步骤：**\n\n1. 根据题目设计递归函数中的运算部分；\n2. 根据题目找到递归公式，题目可能会隐含给出，也可能需要自己进行推导；\n3. 找到递归出口，即递归的终止条件。\n\n递归法和递推法的思路已经给大家讲解得差不多了，接下来我们将结合真实的大赛题目进行讲解。这将有助于我们更好地理解和应用这两种方法。\n\n### 斐波纳契数列 fibonacci 问题 ###\n\n在一定情况下，同一个问题可以使用用递归也可以使用递推解答。一般一个问题的递推关系和递归关系都好求的话就都可以解题。\n\n当然如果题目只有一个关系好求，那就最好采用关系好求的办法。\n\n**题目描述:**\n\n斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”。\n\n指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、…0、1、1、2、3、5、8、13、21、34、…\n\n在数学上，斐波那契数列以如下被以递推的方法定义：(0)=0*F*(0)=0，(1)=1*F*(1)=1，()=(−1)+(−2)*F*(*n*)=*F*(*n*−1)+*F*(*n*−2)（≥2，∈∗*n*≥2，*n*∈*N*∗）\n\n请求出该数列中第 *n* 个数字（*n* 从11开始计数）是多少。\n\n**样例:**\n\n```txt\n输入样例\n\n样例1输入\n6\n\n样例2输入\n4\n\n输出样例\n\n样例1输出\n8\n\n样例2输出\n3\n```\n\n对于上面的样例我们进行了如下计算；\n\n```txt\n[0]=0\n\n[1]=1\n\n[2]=0+1\n\n[3]=1+1=2\n\n[4]=1+2=3\n\n[5]=2+3=5\n\n[6]=5+3=8\n```\n\n**运行限制:**\n\n```txt\n1. 最大运行时间：1s\n2. 最大运行内存：128M\n```\n\n**题目解析：**\n\n- 这个题给出递推式 ()=(−1)+(−2)*F*(*n*)=*F*(*n*−1)+*F*(*n*−2)\n- 转化为可用的递推关系，即()+(+1)=(+2)*F*(*n*)+*F*(*n*+1)=*F*(*n*+2)\n\n这一通过从 =1*n*=1 开始循环即可完成递推，当然也可以使用递归法。\n\n首先我们写找出递归式，()=(−1)+(−2)*F*(*n*)=*F*(*n*−1)+*F*(*n*−2)。\n\n```c\nF(n)= F(n-1) + F(n-2)\n    = F(n-2)+F(n-3)+F(n-3)+F(n-4)\n//重复调用\n```\n\n这样我们找到了递归式，然后我们应该找到递归出口。\n\n我们可以知道 ()=0=0,()=1=1*F*(*n*)=0*n*=0,*F*(*n*)=1*n*=1 这就是递归出口，能让递归停止的条件。\n\n递归算法的通用框架如下：\n\n```cpp\ndo(a,b,c...)\n{\n    //递归终止条件，即出口\n    if(a==? ,b==? ,....) return\n\n    //递归条件\n    if(条件1)\n        do(参数1)\n\n    else(条件2)\n        do(参数2)\n\n}\n\n如本题，各子式间存在计算关系，可以化为：\n\ndo(a)\n{\n    if(a==0) return 0;\n    if(a==1) return 1;\n\n    return do(a-1)+do(a-2);\n}\n```\n\n这道题不是多次询问问题，不需要存储直接计算的复杂度是最低的。\n\n#### 答案解析 ####\n\nC++ 代码：\n\n- 递推算法代码\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\n    int n; //第几个数\n    int x=0; //F(n)\n    int y=1; //F(n+1)\n    int ans; //F(n+2）\n\n    cin>>n;\n\n    if(n==0) ans=0;\n    else if(n==1) ans=1;\n    else {\n        for(int i=2;i<=n;i++)\n        {\n            ans=x+y;\n            x=y;\n            y=ans;\n        }\n    }\n    cout<<ans<<endl;\n\n}\n```\n\n- 递归算法代码\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint fn(int n)\n{\n    //递归出口1\n    if(n==0)\n        return 0;\n\n    //递归出口2\n    else if(n==1 )\n        return 1;\n\n    else\n        return fn(n-1)+fn(n-2); //递归关系式\n}\n\n\nint main()\n{\n\n    int n; //第几个数\n    int ans;\n\n    cin>>n;\n\n    ans=fn(n);\n\n    cout<<ans<<endl;\n\n}\n```\n\n**Python 解题代码**\n\n- 递推算法代码：\n\n```python\nif __name__ == '__main__':\n\n    n =int( input())\n\n    x=0 # F(n)\n    y=1 #F(n+1)\n    ans=0 #F(n+2）\n\n    if n==0 :\n        ans=0\n\n    elif n==1:\n        ans=1\n\n    else:\n        for i in range (n-1):\n\n            ans=x+y\n            x=y\n            y=ans\n\n    print(ans)\n```\n\n- 递归算法代码：\n\n```python\ndef f(n):\n    # 递归出口1\n    if n == 0:\n        return 0\n\n    # 递归出口2\n    elif n == 1:\n        return 1\n\n    else:\n        return f(n - 1) + f(n - 2)  # 递归关系式\n\nif __name__ == '__main__':\n\n    n = int(input())\n    ans = f(n)\n    print(ans)\n```\n\n**Java 解题代码**\n\n递推算法：\n\n```java\nimport java.util.Scanner;\npublic class Main {\n\n    public static void main(String[] args) {\n        int n; //第几个数\n        int x=0; //F(n)\n        int y=1; //F(n+1)\n        int ans = 0; //F(n+2）\n        Scanner in = new Scanner(System.in);\n\n        n = in.nextInt();\n\n        if(n==0) ans=0;\n        else if(n==1) ans=1;\n        else {\n            for(int i=2;i<=n;i++)\n            {\n                ans=x+y;\n                x=y;\n                y=ans;\n            }\n        }\n\n        System.out.println(ans);\n    }\n}\n```\n\n递归算法代码：\n\n```java\nimport java.util.Scanner;\npublic class Main {\n\n    static  int fn(int n)\n    {\n        if(n==0)\n            return 0;\n\n            //递归出口2\n        else if(n==1 )\n            return 1;\n\n        else\n            return fn(n-1)+fn(n-2); //递归关系式\n    }\n\n    public static void main(String[] args) {\n        int n; //第几个数\n\n        int ans = 0;\n        Scanner in = new Scanner(System.in);\n\n        n = in.nextInt();\n\n        ans=fn(n);\n\n        System.out.println(ans);\n    }\n}\n```\n\n### 存储型的递推与递归 ###\n\n我们在开始就讲过题目十分存储和非存储的，上面那个题目就是此询问，如果改为多次询问我们该怎么办，我们会采用存储的方式，存储的方式适用于大部分的的多次查询问题。\n\n我们看一下修改后的题目。\n\n**题目描述：**\n\n斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”。\n\n指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、…0、1、1、2、3、5、8、13、21、34、…\n\n在数学上，斐波那契数列以如下被以递推的方法定义：(0)=0*F*(0)=0，(1)=1*F*(1)=1，()=(−1)+(−2)*F*(*n*)=*F*(*n*−1)+*F*(*n*−2)（≥2，∈∗*n*≥2，*n*∈*N*∗）\n\n我们将进行M次查询，每次输入一个*N*，其中*n*小于3030。\n\n请求出该数列中第*n*个数字（*n*从11开始计数）是多少?\n\n**样例:**\n\n```txt\n输入样例\n\n样例1输入：\n\n6\n4\n2\n7\n8\n8\n10\n\n样例2输入：\n\n8\n13\n23\n14\n17\n24\n16\n10\n11\n\n输出样例\n\n样例1输出：\n\n3\n1\n13\n21\n21\n55\n\n样例2输出：\n\n233\n28657\n377\n1597\n46368\n987\n55\n89\n```\n\n**运行限制:**\n\n```txt\n1. 最大运行时间：1s\n2. 最大运行内存：128M\n```\n\n**题目解析：**\n\n这道题跟上面一道题的算法原理相同，只是增加了多次查询的复杂度，所以仅需修改这一点即可。\n\n再有的是有的同学担心自己的输入输出是在一个屏幕上的，评测的时候会不会出现问题。\n\n![图片描述](./../imgs/%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E6%8E%A8/40a8cde4be1c5946317ab844a61f697f-0.png)\n\n类似这样的情况，这一点是不用担心的，只要不是交互题，评测机的输入与输出是分开的，只有你的输出会用来跟答案比较，所以我们只用关心我们的输出即可。\n\n比如有一道题让你计算 +*x*+*y* 的值，如果你知道每答案，就可以直接输出，都不用进行读入。\n\n然后我们来看一下需要多次询问的题目该怎么解决。\n\n#### 答案解析 ####\n\nC++ 代码：\n\n- 递推算法代码\n\n```cpp\n#include <iostream>\nusing namespace std;\nint F[35];\n\nvoid init()\n{\n    F[0]=0;\n\n    F[1]=1;\n\n    for(int i=2;i<=30;i++)\n    {\n        F[i]=F[i-1]+F[i-2];\n    }\n}\nint main()\n{\n\n    int m; //m次查询\n    int n; //第几个数\n    init();\n\n    cin>>m;\n\n    while(m>0){\n        m-=1;\n        cin>>n;\n        cout<<F[n]<<endl;\n    }\n}\n```\n\n存储答案的递推法，才是最常使用的递推法。\n\n- 递归算法代码\n\n```cpp\n#include <iostream>\nusing namespace std;\nint F[35];\n\nint fn(int n)\n{\n    //递归出口1\n    if(n==0)\n    {\n        F[0]=0;\n        return 0;\n    }\n\n    //递归出口2\n    else if(n==1 )\n    {\n        F[1]=1;\n        return 1;\n    }\n\n    else\n    {\n        F[n]=fn(n-1)+fn(n-2);\n        return F[n]; //递归关系式\n    }\n}\n\nint main()\n{\n    int m; //m次查询\n    int n; //第几个数\n\n    fn(30);\n    cin>>m;\n\n    while(m>0){\n        m-=1;\n        cin>>n;\n        cout<<F[n]<<endl;\n    }\n}\n```\n\n**Python 解题代码**\n\n递推算法代码：\n\n```python\nF = [0]*35\n\ndef init():\n\n    F[0] = 0\n    F[1] = 1\n    for i in range(2, 30):\n        F[i] = F[i-1]+F[i-2]\n\nif __name__ == '__main__':\n\n    m = int(input())\n    init()\n    while m > 0:\n        m -= 1\n        n = int(input())\n        print(F[n])\n    # print(F)\n```\n\n递归算法代码：\n\n```python\nF = [0] * 35\ndef f(n):\n    # 递归出口1\n    if n == 0:\n        F[0] = 0\n        return 0\n    # 递归出口2\n    elif n == 1:\n        F[1] = 1\n        return 1\n    else:\n        F[n] = f(n - 1) + f(n - 2) # 递归关系式\n        return F[n]\n\nif __name__ == '__main__':\n\n    m = int(input())\n    f(30)\n    while m > 0:\n        m -= 1\n        n = int(input())\n        print(F[n])\n    # print(F)\n```\n\n**Java 解题代码**\n\n递推算法：\n\n```java\nimport java.util.Scanner;\npublic class Main {\n\n    static int []F=new int [35];\n\n    static  void init()\n    {\n        F[0]=0;\n        F[1]=1;\n        for(int i=2;i<=30;i++)\n        {\n            F[i]=F[i-1]+F[i-2];\n        }\n    }\n\n    public static void main(String[] args) {\n\n        int m; //m次查询\n        int n; //第几个数\n        init();\n        Scanner in = new Scanner(System.in);\n        m = in.nextInt();\n        while(m>0){\n\n            m-=1;\n\n            n= in.nextInt();\n\n            System.out.println(F[n]);\n        }\n\n    }\n\n}\n```\n\n递归算法代码：\n\n```java\npackage com.company;\nimport java.util.Scanner;\n\npublic class Main {\n\n    static int []F=new int [35];\n\n    static int fn(int n)\n    {\n        //递归出口1\n        if(n==0)\n        {\n\n            F[0]=0;\n            return 0;\n        }\n\n        //递归出口2\n        else if(n==1 )\n        {\n            F[1]=1;\n            return 1;\n        }\n\n        else\n        {\n            F[n]=fn(n-1)+fn(n-2);\n            return F[n]; //递归关系式\n        }\n    }\n    public static void main(String[] args) {\n\n        int m; //m次查询\n        int n; //第几个数\n        fn(30);\n        Scanner in = new Scanner(System.in);\n        m = in.nextInt();\n        while(m>0){\n            m-=1;\n            n= in.nextInt();\n            System.out.println(F[n]);\n        }\n    }\n}\n```\n\n### 数字三角形问题 ###\n\n**题目描述:**\n\n![图片描述](./../imgs/%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E6%8E%A8/06b8663e2aceb6c87e0913d2fe0710f2-0.png)\n\n如图数字三角形。如下所示为一个数字三角形。请编一个程序计算从顶到底的某处的一条路径，使该路径所经过的数字总和最大。只要求输出总和。 　\n\n1. 一步可沿左斜线向下或右斜线向下走；\n2. 三角形行数小于等于 100100；\n3. 三角形中的数字为 0，1，…，990，1，…，99；\n\n测试数据通过键盘逐行输入。\n\n如上例数据应以样例所示格式输入：\n\n**样例:**\n\n```txt\n输入：\n\n5\n7\n3 8\n8 1 0\n2 7 4 4\n4 5 2 6 5\n输出：\n\n30\n```\n\n**运行限制:**\n\n```txt\n1. 最大运行时间：1s\n2. 最大运行内存：128M\n```\n\n**题目分析:**\n\n解决该题目的方式有很多，包括动态规划， 枚举都可以解决这个问题。\n\n我们从递推的思想出发，假设我们从顶层沿着某条路径已经走到了第 *i* 层，正向着 +1*i*+1 层前进， 两条可行路径中我们肯定会选择最大的方向前进，为此我们可以采用递推中的反向递推，即逆推的方式解决，设 [][]*a*[*i*][*j*] 存放从 ,*i*,*j* 出发到达第 *n* 层的最大值。\n\n我们可以写出递推式：\n\n```txt\na[i][j] = max{a[i][j]+a[i+1][j]，a[i][j]+a[i+1][j+1]}\n```\n\n则 逆推到出发点 [1][1]*a*[1][1] 为题目所求答案，即第一层到第 *N* 层的最大值。\n\n#### 答案解析 ####\n\nC++ 代码：\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nint main()\n{\n    int n; //n层\n    int a[101][101]; //路径矩阵\n    cin>>n;\n\n    //输入数字三角形的值\n    for (int i=1; i<=n; i++)\n    {\n        for (int j=1; j<=i; j++)\n        {\n\n        cin>>a[i][j]; //输入原始数据\n\n        }\n    }\n\n    //递推开始\n\n    for (int i=n-1; i>=1; i--)//从最后一层逆推\n    {\n        for (int j=1; j<=i; j++)\n        {\n\n            if (a[i+1][j]>=a[i+1][j+1])\n                a[i][j]+=a[i+1][j];     //路径选择\n\n            else\n                a[i][j]+=a[i+1][j+1];\n        }\n    }\n\n    cout<<a[1][1]<<endl;\n}\n```\n\n**Python 解题代码**\n\n```python\na = [[0] * 101] * 101\n\nif __name__ == '__main__':\n\n  n = int(input())\n\n  # 输入数字三角形的值\n  for i in range(1, n+1):\n      a[i] = input().split()\n      a[i] = list(map(int, a[i]))  # split 分割后都是 字符 这里是转化成数字\n  #\n  # for i in range(1, n + 1):\n  #     print(a[i])\n\n # a = list(map(int, a)) # split 分割后都是 字符 这里是转化成数字\n\n  # 递推开始\n\n  for i in range(n - 1, 0, -1):\n      # 最后一层逆推\n      for j in range(0, i):\n\n          # 路径选择\n          if a[i + 1][j] >= a[i + 1][j + 1]:\n              a[i][j] += a[i + 1][j]\n\n          else:\n              a[i][j] += a[i + 1][j + 1]\n\n  # for i in range(1, n + 1):\n  #     print(a[i])\n\n  print(a[1][0])\n```\n\n**Java 解题代码**\n\n```java\npackage com.company;\nimport java.util.Scanner;\n\npublic class Main {\n\n  static int [][]a=new int [101][101];\n\n  public static void main(String[] args) {\n\n      int n;\n      Scanner in = new Scanner(System.in);\n      n = in.nextInt();\n\n      //输入数字三角形的值\n      for (int i=1; i<=n; i++)\n      {\n          for (int j=1; j<=i; j++)\n          {\n              a[i][j]=in.nextInt(); //输入原始数据\n          }\n      }\n\n      //递推开始\n\n      for (int i=n-1; i>=1; i--)//从最后一层逆推\n      {\n\n          for (int j=1; j<=i; j++)\n          {\n              if (a[i+1][j]>=a[i+1][j+1])\n                  a[i][j]+=a[i+1][j];     //路径选择\n\n              else  a[i][j]+=a[i+1][j+1];\n          }\n      }\n      System.out.println(a[1][1]);\n  }\n}\n```\n\n### 总结 ###\n\n我们这节课讲了递推与递归的知识点，并且也讲了何时采用递归设计程序，何时采用递推设计程序。对于多次询问的题目，也为大家展示了一种解决方法。\n\n对于递推算法，我们覆盖了正推和逆推两种方式。无论是递推和递归的关键在于找到关系式。\n\n希望同学能够独立完成题目进行练习。并且在后面的学习中会多次用到递归与递推设计其他算法。\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯冲刺营","2.递归与递推"]},{"title":"手算与思维题","url":"/2024/02/22/手算与思维题/","content":"\n# 手算与思维题 #\n\n课程伊始，我们先要讲一下蓝桥杯相关的注意事项。\n\n## 比赛流程 ##\n\n### 赛程： ###\n\n- 省赛\n- 决赛\n\n省赛一等奖参加决赛\n\n比赛时长 44 小时\n\n### 竞赛形式： ###\n\n- 个人赛，一人一机，全程机考\n- 答题过程中无法访问互联网\n- 不允许携带任何电子、纸质资料\n\n### 参赛选手机器环境 ###\n\n- X86 兼容机器，内存不小于 1G，硬盘不小于 60G 操作系统：Windows7、Windows8 或 Windows10。\n- C/C++ 开发环境：Dev-cpp 5.4.0 C/C++ API 帮助文档\n- Java 开发环境：JDK 1.8 Eclipse-java-2020-06 API 帮助文档\n- Python 环境：Python 3.8.6 IDLE（Python 自带编辑器）\n\n### 题型 ###\n\n- 结果填空 把答案直接通过网页提交，不要书写多余的内容。填空题每题 55 分。\n- 程序设计 每道题目多个测试数据，20%∼40%20%∼40% 是弱测试数据，其他是强测试数据。 题量大、时间紧张，难题往往不会做或来不及用高效算法编码，此时可以用暴力方法编程得 20%∼40%20%∼40% 的分数。 程序设计题每题 10% 25%10% 25% 分。\n\n### 评分方式 ###\n\n评分：全部使用机器自动评分\n\n**对于结果填空题，题目保证只有唯一解，选手的结果只有和解完全相同才得分，出现格式错误或有多余内容时不得分。**\n\n对于编程大题，评测系统将使用多个评测数据来测试程序。每个评测数据有对应的分数。选手所提交的程序将分别用每个评测数据作为输入来运行。对于某个评测数据，如果选手程序的输出与正确答案是匹配的，则选手获得该评测数据的分数。\n\n## 知识点梳理 ##\n\n（1）思维题（杂题）：不需要算法和数据结构，只需要逻辑、推理的题目，难度可难可易。考察思维能力和编码能力，只能通过大量做题来提高。\n\n（2）BFS 搜索和 DFS 搜索：也就是暴力搜索。这是非常基本的算法，是基础中的基础。\n\n（3）动态规划：线性 DP，以及一些 DP 应用，例如状态压缩 DP、树形 DP 等。\n\n（4）简单数学和简单数论。\n\n（5）简单的字符串处理、输入输出，简单图论。\n\n（6）基本算法：例如排序、排列、二分、倍增、差分、贪心。\n\n（7）基本数据结构：队列、栈、链表、二叉树等。\n\n## 技巧：手算 ##\n\n- 应用场合：填空题\n- 手算的目的：减少做题时间，省下时间做编程题。\n\n手段：\n\n- 不编码，或者只做部分编码\n- 用推理获得答案\n- 用软件工具帮助计算\n\n方法：\n\n- 巧用编辑器\n- 心算手数\n- 巧用 Excel\n- 巧用 Python\n\n### 例题 ###\n\n#### [1. 门牌制作 2020 年第十一届蓝桥杯省赛，填空题](https://www.lanqiao.cn/problems/592/learning/) ####\n\n**问题描述：** 从 11 到 20202020 的所有数字中，共有多少个 22？\n\n- 先编码连续打印出 11 ∼∼ 20202020 这 20202020 个数字\n- 然后粘贴到任何一个编辑器中\n- 选查询或替换功能，查找或替换字符 “22”，共 624624 次，就是答案。\n\n**简单直接，不用思考**\n\n#### [2. 迷宫 2017 年第八届蓝桥杯省赛，填空题](https://www.lanqiao.cn/problems/641/learning/) ####\n\n**问题描述：** 给出一个迷宫，问迷宫内的人有多少能走出来。迷宫如右图所示：每个位置上有一个人，共 100100 人。每个位置有指示牌，*L* 表示向左走，*R* 表示向右走，*U* 表示向上走，*D* 表示向下走。\n\n```c\nUDDLUULRUL\nUURLLLRRRU\nRRUURLDLRD\nRUDDDDUUUU\nURUDLLRRUU\nDURLRLDLRL\nULLURLLRDU\nRDLULLRDDD\nUUDDUDUDLL\nULRDLUURRR\n```\n\n- 正解：DFS 搜索，编码 10 分钟。\n- 技巧：直接用手画图标记 3-5 分钟。\n\n#### [3. 迷宫 2017 年第八届蓝桥杯省赛，填空题](https://www.lanqiao.cn/problems/611/learning/) ####\n\n**问题描述：** 整个 20 世纪（19011901 年 11 月 11 日至 20002000 年 1212 月 3131 日之间），一共有多少个星期一？\n\n**思路：** 用 Excel，在一个格子里输入日期 19011901 年 11 月 11 日，另一个格子输入 20002000 年 1212 月 3131 日，然后两个格子相减得 3652436524 天，除以 77 得 5217.75217.7 周。\n\n再看 19011901 年 11 月 11 日是星期几。\n\n用 Excel 点 19011901 年 11 月 11 日这一格的“设置单元格式-数字-日期-星期三”，点击“确定”，得“星期二”，即 19011901 年 11 月 11 日是星期二，3652436524 是 52175217 周多几天，最后几天没有星期一，说明答案就是 52175217。\n\n也可以直接利用 Excel“单元格格式”对话框得出 20002000 年 1212 月 3131 日刚好是星期天，从星期二至星期天之间没有星期一。\n\n### 巧用 Python ###\n\n**填空题遇到字符、大数字、日期问题，Python 是首选。**\n\n•即使参加 C/C++、Java 组比赛，也要学一些 Python，以方便手算，或用来做对比测试。\n\n•这几种语言的编译器，在比赛机器上都有。\n\n•写 Python 代码既简单又快，代码长度一般比 C/C++、Java 短很多。例如 30 行的 C++代码，用 Python 写只需要 20 行。\n\n[3. 迷宫 2017 年第八届蓝桥杯省赛，填空题](https://www.lanqiao.cn/problems/611/learning/)\n\n**问题描述：** 整个 20 世纪(1901 年 1 月 1 日至 2000 年 12 月 31 日之间)，一共有多少个星期一？\n\n**直接用 Python datetime 库求解，第 4 行可以输出某个日期是星期几。**\n\n```python\nfrom datetime import*\ndt1=datetime(1901,1,1)\ndt2=datetime(2000,12,31)\n\nprint(dt1.weekday())\n# 周一为0，周二为1...\n\ntd=dt2-dt1\n\nprint(td.days//7)\n```\n\n相对应的使用 C++同样可以完成，但是编码复杂：\n\n```c++\n#include <iostream>\nusing namespace std;\nint res;\n//先判断润年\nbool is_r(int n){\n     if((n % 4 == 0 && n % 100 != 0) || n % 400 == 0)\n         return true;\n     return false;\n}\nint main(){\n    for(int i = 1901;i <= 2000;i ++)\n        if(is_r(i)) res += 366;\n        else res += 365;\n    int x = res / 7;\n    cout << x << endl;\n    return 0;\n}\n```\n\n[4. 乘积尾零 2018 年第九届蓝桥杯省赛](https://www.lanqiao.cn/problems/612/learning/)\n\n【问题描述】 给出 100100 个整数（这里省略题目给的 100100 个数），问它们乘积的末尾有多少个零。\n\n最简单题解：\n\n- 直接连乘：几千位的大数\n- 然后统计末尾的 00\n\n![图片描述](./../imgs/%E6%89%8B%E7%AE%97%E4%B8%8E%E6%80%9D%E7%BB%B4%E9%A2%98/236f300ccb9673d4fc3b0c7790de774a-0.png)\n\n但是 C++ 装不下这么大的数字，所以要进行处理：\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int cnt2=0,cnt5=0;\n    for (int i=1;i<=10;i++)   {\n        for (int j=1;j<=10;j++)     {\n            int x;\n            cin>>x;\n            while (x%2==0) cnt2++,x/=2;\n            while (x%5==0) cnt5++,x/=5;\n        }\n    }\n    cout<<min(cnt2,cnt5)<<'\\n';\n    return 0;\n}\n```\n\n发现编码时间变长了，如果填空题且 Java 学的好一点的，可以直接 Python 编程出结果。\n\n## 思维题 ##\n\n- 不需要涉及某种算法的题目。\n- 只要学过编程语言，就能够解答。\n- 主要考核学生的思维、逻辑和编码能力，强调脑筋急转弯的解决方式。\n- 这类题目包括模拟题、构造题、思维题以及找规律题，统称为“思维题（杂题）”。\n- 每年蓝桥杯都会设置这类题目，而且可能有多道，是考试中的重要得分点。\n- 杂题涵盖了各种难度，有些可能相对简单，而另一些可能相对较难。\n\n[5. 付账问题 2018 年第九届蓝桥杯省赛，lanqiaoOJ 题号 174](https://www.lanqiao.cn/problems/174/learning/)\n\n【题目描述】\n\n现在有 *n* 个人出去吃饭，他们总共消费了 *S* 元。其中第 *i* 个人带了 *a**i*元。幸运的是，所有人带的钱的总数是足够付账的，但现在问题来了：每个人分别要出多少钱呢？\n\n为了公平起见，我们希望在总付钱量恰好为 *S* 的前提下，最后每个人付的钱的标准差最小。这里我们约定，每个人支付的钱数可以是任意非负实数，即可以不是 1 分钱的整数倍。你需要输出最小的标准差是多少。\n\n标准差的介绍：标准差是多个数与它们平均数差值的平方平均数，一般用于刻画这些数之间的\"偏差有多大\"。形式化地说，设第 *i* 个人付的钱为 *b**i* 元，那么标准差为 :\n\n1Σ=1(−1Σ=1)2*n*1Σ*i*=1*n*(*b**i*−*n*1Σ*i*=1*n**b**i*)2\n\n**解决思路：**\n\n如果每个人携带的钱足够多，每个人平均支付相同的金额，即 ==avg*b**i*=*n**S*=avg，那么标准差 *X* 为 00。\n\n然而，总会有人的钱不够，这时我们考虑两种情况：\n\n（1）第 *i* 个人携带的钱不足以达到平均数 avgavg，那么他只能支付他所携带的全部钱 *a**i*。\n\n（2）第 *i* 个人携带的钱超过平均数 avgavg，那么他可以支付多一些。\n\n**解决步骤：**\n\n（1）对 *a**i* 进行从小到大的排序；\n\n（2）前一部分人的钱不足以支付平均数，因此他们每个人支付所有携带的钱；\n\n（3）从总支付数中减去前一部分人支付的钱，得到剩余金额 ′*S*′，以及后一部分人的平均支付数 avg′avg′。\n\n（4）后一部分人携带的钱较多，他们可以支付多一些。这部分人又可以分为两类：\n\n- （i）相对富裕但仍然不足以支付 avg′avg′ 的人，他们需要支付所有携带的钱；\n- （ii）非常富裕的人，无论如何摊分，他们都有余额。\n\n由于前面一部分人不足以支付 avgavg，因此后面足够支付 avg′avg′ 的人不能只支付 avgavg。相反，他们应该尽可能地每个人支付相同的金额。\n\n因为有人支付不足，总有人支付过多，由于是标准差（方差的平方根），因此每个人支付的金额差距越小越好。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 5e5;\nlong long a[M];\nint main(){\n    int n;  long long s;\n    scanf(\"%d %lld\",&n,&s);\n\n    for(int i=1;i<=n;i++)  scanf(\"%lld\",&a[i]);\n\n    sort(a+1,a+n+1);       //排序，从小到大\n\n    double avg = 1.0*s/n;  //平均值\n    double sum = 0.0;\n\n    for(int i=1;i<=n;i++){\n        if(a[i]*(n+1-i) < s){\n//需要把钱全拿出的人：\n//（1）钱不够平均数的，（2）钱够平均数，但也不是很多的\n            sum += (a[i]-avg)*(a[i]-avg);\n            s -= a[i];            //更新剩余钱数\n        }\n        else{      \n//不用把钱全拿出的人：非常有钱，不管怎么平均都够\n            double cur_avg = 1.0*s/(n+1-i);    \n//更新平均出钱数\n            sum += (cur_avg-avg)*(cur_avg-avg)*(n+1-i);\n            break;\n        }\n    }\n    printf(\"%.4lf\",sqrt(sum/n));\n    return 0;\n}\nfrom math import *\nn, s = map(int,input().split())\na = list(map(int,input().split()))\na.sort()\navg = s/n\nsum = 0\nfor i in range(n):\n     if a[i]*(n-i) < s:\n          sum += pow(a[i]-avg,2)\n          s -= a[i]\n     else:\n          cur_avg = s/(n-i);      #更新平均出钱数\n          sum += pow(cur_avg-avg,2)*(n-i)\n          break\nprint(\"{:.4f}\".format(sqrt(sum/(n))))\nimport java.io.FileNotFoundException;\nimport java.util.Arrays;\nimport java.util.Scanner;\npublic class Main {\npublic static void main(String args[]) {\n        int n;\n        long S;\n        double ans=0,avg;\n        Scanner input=new Scanner(System.in);\n        n=input.nextInt();\n        S=input.nextLong();\n        long a[]=new long[n];\n        for(int i=0;i<n;i++)        \n            a[i]=input.nextLong();\n        Arrays.sort(a);\n        avg=(double)S/n;\n        for(int i=0;i<n;i++) {\n            if(S<=(n-i)*a[i]) {\n                ans += (n-i)*Math.pow((double)S/(n-i)-avg,2);\n                break;\n            }\n            ans += Math.pow(a[i]-avg,2);\n            S -= a[i];\n        }\n        System.out.printf(\"%.4f\\n\",Math.sqrt(ans/n));\n    }\n}\n```\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯冲刺营","1.手算和思维题"]},{"title":"自上而下树形DP","url":"/2024/02/22/自上而下树形DP/","content":"\n![image-20240222144835991](./../imgs/%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E6%A0%91%E5%BD%A2DP/image-20240222144835991.png)![image-20240222144845577](./../imgs/%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E6%A0%91%E5%BD%A2DP/image-20240222144845577.png)![image-20240222144857347](./../imgs/%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E6%A0%91%E5%BD%A2DP/image-20240222144857347.png)![image-20240222144905501](./../imgs/%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E6%A0%91%E5%BD%A2DP/image-20240222144905501.png)![image-20240222144912860](./../imgs/%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E6%A0%91%E5%BD%A2DP/image-20240222144912860.png)![image-20240222144919160](./../imgs/%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E6%A0%91%E5%BD%A2DP/image-20240222144919160.png)![image-20240222144928213](./../imgs/%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E6%A0%91%E5%BD%A2DP/image-20240222144928213.png)![image-20240222144934794](./../imgs/%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E6%A0%91%E5%BD%A2DP/image-20240222144934794.png)\t**本节内容属于算法提高知识，由专属金牌选手录制，由于视频时长有限，所以视频中例题讲解主要以 C++ 为主讲解，大家可正常学习。算法思维是共通的，例题的其他语言解题代码，我们也在下方提供了，大家可以参考哦～**\n\n- C++\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define maxn 110000\nint n, val[maxn];\nstruct Edge\n{\n    int nex, to;\n}edge[maxn << 1];\nint head[maxn], cnt;\nint f[maxn][2];\nvoid add(int from, int to)\n{\n    edge[++cnt].nex = head[from];\n    head[from] = cnt;\n    edge[cnt].to = to;\n    return ;\n}\nvoid dfs(int u, int fa)\n{\n    for (int i = head[u]; i; i = edge[i].nex)\n    {\n        int v = edge[i].to;\n        if (v != fa)\n            continue;\n        dfs(v, u);\n        f[u][0] += max(f[v][0], f[v][1]);\n        f[u][1] += f[v][0];\n    }\n    return ;\n}\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++ i )\n        scanf(\"%d\", &val[i]), f[i][1] = val[i];\n    for (int i = 1; i < n; ++ i )\n    {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        add(u, v), add(v, u);\n    }\n    dfs(1, 0);\n    printf(\"%d\\n\", max(f[1][0], f[1][1]));\n    return 0;\n}\n```\n\n- Java\n\n```java\nimport java.util.Scanner;\n\npublic class TreeDP {\n    static final int maxn = 110000;\n    static int n;\n    static int[] val = new int[maxn];\n    static Edge[] edges = new Edge[maxn << 1];\n    static int[] head = new int[maxn];\n    static int cnt;\n    static int[][] f = new int[maxn][2];\n\n    static class Edge {\n        int next, to;\n\n        Edge(int next, int to) {\n            this.next = next;\n            this.to = to;\n        }\n    }\n\n    public static void add(int from, int to) {\n        edges[++cnt] = new Edge(head[from], to);\n        head[from] = cnt;\n    }\n\n    public static void dfs(int u, int fa) {\n        for (int i = head[u]; i != 0; i = edges[i].next) {\n            int v = edges[i].to;\n            if (v == fa)\n                continue;\n            dfs(v, u);\n            f[u][0] += Math.max(f[v][0], f[v][1]);\n            f[u][1] += f[v][0];\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        for (int i = 1; i <= n; ++i) {\n            val[i] = sc.nextInt();\n            f[i][1] = val[i];\n        }\n        for (int i = 1; i < n; ++i) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            add(u, v);\n            add(v, u);\n        }\n        dfs(1, 0);\n        System.out.println(Math.max(f[1][0], f[1][1]));\n        sc.close();\n    }\n}\n```\n\n- Python\n\n```python\nfrom collections import defaultdict\n\nn = int(input())\nval = [0] + [int(x) for x in input().split()]\nedges = defaultdict(list)\nf = [[0, val[i]] for i in range(n + 1)]\n\ndef add_edge(from_node, to_node):\n    edges[from_node].append(to_node)\n\ndef dfs(u, fa):\n    for v in edges[u]:\n        if v == fa:\n            continue\n        dfs(v, u)\n        f[u][0] += max(f[v][0], f[v][1])\n        f[u][1] += f[v][0]\n\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    add_edge(u, v)\n    add_edge(v, u)\n\ndfs(1, 0)\nprint(max(f[1][0], f[1][1]))\n```\n\n- C++\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define maxn 110\nint n, v;\nint f[maxn][maxn];\nint w[maxn], v[maxn];\nvector<int> g[maxn];\nstruct Edge\n{\n    int nex, to;\n}edge[maxn << 1];\nint head[maxn], cnt;\nvoid add(int from, int to)\n{\n    edge[++ cnt].nex = head[from];\n    head[from] = cnt;\n    edge[cnt.to] = to;\n    return ;\n}\nvoid dfs(int u, int fa)\n{\n    memset(f[u], -0x3f, sizeof f[u]);\n    if (v[u] <= V)\n        f[u][v[u]] = w[u];\n    for (int i = head[u]; i; i = edge[i].nex)\n    {\n        int v = edge[i].to;\n        if (v == fa)\n            continue;\n        dfs(v, u);\n        vector<int> nf(f[u], f[u] + V + 1);\n        for (int v1 = 0; v1 <= V; v1 ++)\n        {\n            for (int v2 = 0; v1 + v2 <= V; v2 ++ )\n            {\n                nf[v1 + v2] = max(nf[v1 + v2], f[u][v1] + f[v][v2]);\n            }\n        }\n        for (int v = 0; v <= V; v ++ )\n            f[u][v] = nf[v];\n    }\n    return ;\n}\nint main()\n{\n    scanf(\"%d%d\", &n, &v);\n    for (int i = 1; i < n; ++ i )\n    {\n        int u, v;\n        add(u, v), add(v, u);\n    }\n    dfs(1, 0);\n    int ans = 0;\n    for (int i = 0; i <= V; ++ i )\n        ans = max(ans, f[1][i]);\n    cout << ans << endl;\n    return 0;\n}\n```\n\n- Java\n\n```java\nimport java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class TreeDP {\n    static final int maxn = 110;\n    static int n, V;\n    static int[][] f = new int[maxn][maxn];\n    static int[] w = new int[maxn], val = new int[maxn];\n    static List<Integer>[] g = new ArrayList[maxn];\n    static Edge[] edges = new Edge[maxn << 1];\n    static int[] head = new int[maxn];\n    static int cnt;\n\n    static class Edge {\n        int next, to;\n\n        Edge(int next, int to) {\n            this.next = next;\n            this.to = to;\n        }\n    }\n\n    public static void add(int from, int to) {\n        edges[++cnt] = new Edge(head[from], to);\n        head[from] = cnt;\n    }\n\n    public static void dfs(int u, int fa) {\n        Arrays.fill(f[u], Integer.MIN_VALUE);\n        if (val[u] <= V)\n            f[u][val[u]] = w[u];\n        for (int i = head[u]; i != 0; i = edges[i].next) {\n            int v = edges[i].to;\n            if (v == fa)\n                continue;\n            dfs(v, u);\n            int[] nf = Arrays.copyOf(f[u], V + 1);\n            for (int v1 = 0; v1 <= V; v1++) {\n                for (int v2 = 0; v1 + v2 <= V; v2++) {\n                    nf[v1 + v2] = Math.max(nf[v1 + v2], f[u][v1] + f[v][v2]);\n                }\n            }\n            for (int v = 0; v <= V; v++)\n                f[u][v] = nf[v];\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        V = sc.nextInt();\n        for (int i = 1; i <= n; ++i) {\n            w[i] = sc.nextInt(); // Assuming input for weights w is provided\n            val[i] = sc.nextInt(); // Assuming input for values val is provided\n            g[i] = new ArrayList<>();\n        }\n        for (int i = 1; i < n; ++i) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            add(u, v);\n            add(v, u);\n        }\n        dfs(1, 0);\n        int ans = 0;\n        for (int i = 0; i <= V; ++i)\n            ans = Math.max(ans, f[1][i]);\n        System.out.println(ans);\n        sc.close();\n    }\n}\n```\n\n- Python\n\n```python\nfrom collections import defaultdict\nimport sys\n\nn, V = map(int, input().split())\nw = [0] + [int(x) for x in input().split()]\nval = [0] + [int(x) for x in input().split()]\nedges = defaultdict(list)\nf = [[float('-inf') for _ in range(V+1)] for _ in range(n+1)]\n\ndef add_edge(from_node, to_node):\n    edges[from_node].append(to_node)\n\ndef dfs(u, fa):\n    f[u] = [float('-inf')] * (V+1)\n    if val[u] <= V:\n        f[u][val[u]] = w[u]\n    for v in edges[u]:\n        if v == fa:\n            continue\n        dfs(v, u)\n        nf = f[u][:]\n        for v1 in range(V + 1):\n            for v2 in range(V - v1 + 1):\n                nf[v1 + v2] = max(nf[v1 + v2], f[u][v1] + f[v][v2])\n        f[u] = nf\n\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    add_edge(u, v)\n    add_edge(v, u)\n\ndfs(1, 0)\nans = max(f[1])\nprint(ans)\n```\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第四章：动态规划","树形DP"]},{"title":"二维费用背包&分组背包","url":"/2024/02/22/二维费用背包-分组背包/","content":"\n![image-20240222143838988](./../imgs/%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/image-20240222143838988.png)![image-20240222143845529](./../imgs/%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/image-20240222143845529.png)![image-20240222143852832](./../imgs/%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/image-20240222143852832.png)![image-20240222143858208](./../imgs/%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/image-20240222143858208.png)![image-20240222143904508](./../imgs/%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/image-20240222143904508.png)![image-20240222143910382](./../imgs/%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/image-20240222143910382.png)![image-20240222143917764](./../imgs/%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/image-20240222143917764.png)![image-20240222143923600](./../imgs/%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/image-20240222143923600.png)![image-20240222143933109](./../imgs/%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/image-20240222143933109.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第四章：动态规划","背包问题"]},{"title":"单调队列优多重背包","url":"/2024/02/22/单调队列优多重背包/","content":"\n![image-20240222143542527](./../imgs/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/image-20240222143542527.png)![image-20240222143549813](./../imgs/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/image-20240222143549813.png)![image-20240222143556465](./../imgs/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/image-20240222143556465.png)![image-20240222143604684](./../imgs/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/image-20240222143604684.png)![image-20240222143730596](./../imgs/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/image-20240222143730596.png)![image-20240222143737279](./../imgs/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/image-20240222143737279.png) \t![image-20240222143747857](./../imgs/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/image-20240222143747857.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第四章：动态规划","背包问题"]},{"title":"完全背包","url":"/2024/02/22/完全背包/","content":"\n![image-20240222143338159](./../imgs/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/image-20240222143338159.png)![image-20240222143345476](./../imgs/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/image-20240222143345476.png)![image-20240222143352363](./../imgs/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/image-20240222143352363.png)![image-20240222143358926](./../imgs/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/image-20240222143358926.png)![image-20240222143413495](./../imgs/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/image-20240222143413495.png)![image-20240222143422627](./../imgs/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/image-20240222143422627.png)![image-20240222143432747](./../imgs/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/image-20240222143432747.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第四章：动态规划","背包问题"]},{"title":"01背包","url":"/2024/02/22/01背包/","content":"\n![image-20240222143137210](./../imgs/01%E8%83%8C%E5%8C%85/image-20240222143137210.png)![image-20240222143144426](./../imgs/01%E8%83%8C%E5%8C%85/image-20240222143144426.png)![image-20240222143153153](./../imgs/01%E8%83%8C%E5%8C%85/image-20240222143153153.png)![image-20240222143201565](./../imgs/01%E8%83%8C%E5%8C%85/image-20240222143201565.png)![image-20240222143209461](./../imgs/01%E8%83%8C%E5%8C%85/image-20240222143209461.png)![image-20240222143219350](./../imgs/01%E8%83%8C%E5%8C%85/image-20240222143219350.png)![image-20240222143227983](./../imgs/01%E8%83%8C%E5%8C%85/image-20240222143227983.png)![image-20240222143235203](./../imgs/01%E8%83%8C%E5%8C%85/image-20240222143235203.png)![image-20240222143242140](./../imgs/01%E8%83%8C%E5%8C%85/image-20240222143242140.png)![image-20240222143249102](./../imgs/01%E8%83%8C%E5%8C%85/image-20240222143249102.png)![image-20240222143255512](./../imgs/01%E8%83%8C%E5%8C%85/image-20240222143255512.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第四章：动态规划","背包问题"]},{"title":"LCS","url":"/2024/02/22/LCS/","content":"\n![image-20240222142941134](./../imgs/LCS/image-20240222142941134.png)![image-20240222143000232](./../imgs/LCS/image-20240222143000232.png)![image-20240222143016517](./../imgs/LCS/image-20240222143016517.png)![image-20240222143028066](./../imgs/LCS/image-20240222143028066.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第四章：动态规划","动态规划基础"]},{"title":"LIS","url":"/2024/02/22/LIS/","content":"\n![image-20240222142750287](./../imgs/LIS/image-20240222142750287.png)![image-20240222142758466](./../imgs/LIS/image-20240222142758466.png)![image-20240222142805991](./../imgs/LIS/image-20240222142805991.png)![image-20240222142812794](./../imgs/LIS/image-20240222142812794.png)![image-20240222142826815](./../imgs/LIS/image-20240222142826815.png)![image-20240222142841071](./../imgs/LIS/image-20240222142841071.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第四章：动态规划","动态规划基础"]},{"title":"二维DP","url":"/2024/02/22/二维DP/","content":"\n![image-20240222142525119](./../imgs/%E4%BA%8C%E7%BB%B4DP/image-20240222142525119.png)![image-20240222142533229](./../imgs/%E4%BA%8C%E7%BB%B4DP/image-20240222142533229.png)![image-20240222142543691](./../imgs/%E4%BA%8C%E7%BB%B4DP/image-20240222142543691.png)![image-20240222142553990](./../imgs/%E4%BA%8C%E7%BB%B4DP/image-20240222142553990.png)![image-20240222142609895](./../imgs/%E4%BA%8C%E7%BB%B4DP/image-20240222142609895.png)![image-20240222142618973](./../imgs/%E4%BA%8C%E7%BB%B4DP/image-20240222142618973.png)![image-20240222142627876](./../imgs/%E4%BA%8C%E7%BB%B4DP/image-20240222142627876.png)![image-20240222142637123](./../imgs/%E4%BA%8C%E7%BB%B4DP/image-20240222142637123.png)![image-20240222142651991](./../imgs/%E4%BA%8C%E7%BB%B4DP/image-20240222142651991.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第四章：动态规划","动态规划基础"]},{"title":"线性DP","url":"/2024/02/22/线性DP/","content":"\n![image-20240222140917600](./../imgs/%E7%BA%BF%E6%80%A7DP/image-20240222140917600.png)![image-20240222141001854](./../imgs/%E7%BA%BF%E6%80%A7DP/image-20240222141001854.png)![image-20240222141011774](./../imgs/%E7%BA%BF%E6%80%A7DP/image-20240222141011774.png)![image-20240222141300407](./../imgs/%E7%BA%BF%E6%80%A7DP/image-20240222141300407.png)![image-20240222141314991](./../imgs/%E7%BA%BF%E6%80%A7DP/image-20240222141314991.png)![image-20240222141408804](./../imgs/%E7%BA%BF%E6%80%A7DP/image-20240222141408804.png)![image-20240222142036239](./../imgs/%E7%BA%BF%E6%80%A7DP/image-20240222142036239.png)![image-20240222142402147](./../imgs/%E7%BA%BF%E6%80%A7DP/image-20240222142402147.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第四章：动态规划","动态规划基础"]},{"title":"DFS-剪枝","url":"/2024/02/22/DFS-剪枝/","content":"\n![image-20240222113035894](./../imgs/DFS-%E5%89%AA%E6%9E%9D/image-20240222113035894.png)![image-20240222113040668](./../imgs/DFS-%E5%89%AA%E6%9E%9D/image-20240222113040668.png)![image-20240222113044837](./../imgs/DFS-%E5%89%AA%E6%9E%9D/image-20240222113044837.png)![image-20240222113049192](./../imgs/DFS-%E5%89%AA%E6%9E%9D/image-20240222113049192.png)![image-20240222113053459](./../imgs/DFS-%E5%89%AA%E6%9E%9D/image-20240222113053459.png)![image-20240222113057612](./../imgs/DFS-%E5%89%AA%E6%9E%9D/image-20240222113057612.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第三章：搜索"]},{"title":"DFS-回溯","url":"/2024/02/22/DFS-回溯/","content":"\n![image-20240222112858876](./../imgs/DFS-%E5%9B%9E%E6%BA%AF/image-20240222112858876.png)![image-20240222112903690](./../imgs/DFS-%E5%9B%9E%E6%BA%AF/image-20240222112903690.png)![image-20240222112908328](./../imgs/DFS-%E5%9B%9E%E6%BA%AF/image-20240222112908328.png)![image-20240222112913112](./../imgs/DFS-%E5%9B%9E%E6%BA%AF/image-20240222112913112.png)![image-20240222112917174](./../imgs/DFS-%E5%9B%9E%E6%BA%AF/image-20240222112917174.png)![image-20240222112921580](./../imgs/DFS-%E5%9B%9E%E6%BA%AF/image-20240222112921580.png)![image-20240222112925632](./../imgs/DFS-%E5%9B%9E%E6%BA%AF/image-20240222112925632.png)![image-20240222112930367](./../imgs/DFS-%E5%9B%9E%E6%BA%AF/image-20240222112930367.png)![image-20240222112934469](./../imgs/DFS-%E5%9B%9E%E6%BA%AF/image-20240222112934469.png)![image-20240222112938763](./../imgs/DFS-%E5%9B%9E%E6%BA%AF/image-20240222112938763.png)![image-20240222112942470](./../imgs/DFS-%E5%9B%9E%E6%BA%AF/image-20240222112942470.png)![image-20240222112946650](./../imgs/DFS-%E5%9B%9E%E6%BA%AF/image-20240222112946650.png)![image-20240222112951016](./../imgs/DFS-%E5%9B%9E%E6%BA%AF/image-20240222112951016.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第三章：搜索"]},{"title":"DFS-基础","url":"/2024/02/22/DFS-基础/","content":"\n![image-20240222112707429](./../imgs/DFS-%E5%9F%BA%E7%A1%80/image-20240222112707429.png)![image-20240222112712615](./../imgs/DFS-%E5%9F%BA%E7%A1%80/image-20240222112712615.png)![image-20240222112718179](./../imgs/DFS-%E5%9F%BA%E7%A1%80/image-20240222112718179.png)![image-20240222112723680](./../imgs/DFS-%E5%9F%BA%E7%A1%80/image-20240222112723680.png)![image-20240222112729079](./../imgs/DFS-%E5%9F%BA%E7%A1%80/image-20240222112729079.png)![image-20240222112733382](./../imgs/DFS-%E5%9F%BA%E7%A1%80/image-20240222112733382.png)![image-20240222112737718](./../imgs/DFS-%E5%9F%BA%E7%A1%80/image-20240222112737718.png)![image-20240222112741922](./../imgs/DFS-%E5%9F%BA%E7%A1%80/image-20240222112741922.png)![image-20240222112748095](./../imgs/DFS-%E5%9F%BA%E7%A1%80/image-20240222112748095.png)![image-20240222112805799](./../imgs/DFS-%E5%9F%BA%E7%A1%80/image-20240222112805799.png)![image-20240222112810974](./../imgs/DFS-%E5%9F%BA%E7%A1%80/image-20240222112810974.png)![image-20240222112815688](./../imgs/DFS-%E5%9F%BA%E7%A1%80/image-20240222112815688.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第三章：搜索"]},{"title":"位运算","url":"/2024/02/21/位运算/","content":"\n![image-20240221232040286](./../imgs/%E4%BD%8D%E8%BF%90%E7%AE%97/image-20240221232040286.png)![image-20240221232047084](./../imgs/%E4%BD%8D%E8%BF%90%E7%AE%97/image-20240221232047084.png)![image-20240221232051967](./../imgs/%E4%BD%8D%E8%BF%90%E7%AE%97/image-20240221232051967.png)![image-20240221232056347](./../imgs/%E4%BD%8D%E8%BF%90%E7%AE%97/image-20240221232056347.png)![image-20240221232100258](./../imgs/%E4%BD%8D%E8%BF%90%E7%AE%97/image-20240221232100258.png)![image-20240221232104286](./../imgs/%E4%BD%8D%E8%BF%90%E7%AE%97/image-20240221232104286.png)![image-20240221232108474](./../imgs/%E4%BD%8D%E8%BF%90%E7%AE%97/image-20240221232108474.png)![image-20240221232113412](./../imgs/%E4%BD%8D%E8%BF%90%E7%AE%97/image-20240221232113412.png)![image-20240221232117137](./../imgs/%E4%BD%8D%E8%BF%90%E7%AE%97/image-20240221232117137.png)![image-20240221232120744](./../imgs/%E4%BD%8D%E8%BF%90%E7%AE%97/image-20240221232120744.png)![image-20240221232125379](./../imgs/%E4%BD%8D%E8%BF%90%E7%AE%97/image-20240221232125379.png)![image-20240221232129019](./../imgs/%E4%BD%8D%E8%BF%90%E7%AE%97/image-20240221232129019.png)![image-20240221232132460](./../imgs/%E4%BD%8D%E8%BF%90%E7%AE%97/image-20240221232132460.png)![image-20240221232136340](./../imgs/%E4%BD%8D%E8%BF%90%E7%AE%97/image-20240221232136340.png)![image-20240221232139832](./../imgs/%E4%BD%8D%E8%BF%90%E7%AE%97/image-20240221232139832.png)![image-20240221232143331](./../imgs/%E4%BD%8D%E8%BF%90%E7%AE%97/image-20240221232143331.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第二章：基础算法","基础算法"]},{"title":"构造","url":"/2024/02/21/构造/","content":"\n![image-20240221231746186](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231746186.png)![image-20240221231750489](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231750489.png)![image-20240221231754545](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231754545.png)![image-20240221231758895](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231758895.png)![image-20240221231803834](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231803834.png)![image-20240221231807922](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231807922.png)![image-20240221231811968](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231811968.png)![image-20240221231816852](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231816852.png)![image-20240221231820906](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231820906.png)![image-20240221231824987](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231824987.png)![image-20240221231830504](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231830504.png)![image-20240221231834468](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231834468.png)![image-20240221231838497](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231838497.png)![image-20240221231842519](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231842519.png)![image-20240221231847390](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231847390.png)![image-20240221231851420](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231851420.png)![image-20240221231855648](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231855648.png)![image-20240221231859563](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231859563.png)![image-20240221231903384](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231903384.png)![image-20240221231907099](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231907099.png)![image-20240221231911966](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231911966.png)![image-20240221231916184](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231916184.png)![image-20240221231920394](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231920394.png)![image-20240221231924830](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231924830.png)![image-20240221231929084](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231929084.png)![image-20240221231932884](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231932884.png)![image-20240221231936479](./../imgs/%E6%9E%84%E9%80%A0/image-20240221231936479.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第二章：基础算法","基础算法"]},{"title":"倍增","url":"/2024/02/21/倍增/","content":"\n![image-20240221231630731](./../imgs/%E5%80%8D%E5%A2%9E/image-20240221231630731.png)![image-20240221231635708](./../imgs/%E5%80%8D%E5%A2%9E/image-20240221231635708.png)![image-20240221231641094](./../imgs/%E5%80%8D%E5%A2%9E/image-20240221231641094.png)![image-20240221231646300](./../imgs/%E5%80%8D%E5%A2%9E/image-20240221231646300.png)![image-20240221231651943](./../imgs/%E5%80%8D%E5%A2%9E/image-20240221231651943.png)![image-20240221231657609](./../imgs/%E5%80%8D%E5%A2%9E/image-20240221231657609.png)![image-20240221231701871](./../imgs/%E5%80%8D%E5%A2%9E/image-20240221231701871.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第二章：基础算法","基础算法"]},{"title":"二分","url":"/2024/02/21/二分/","content":"\n![image-20240221231437377](./../imgs/%E4%BA%8C%E5%88%86/image-20240221231437377.png)![image-20240221231443219](./../imgs/%E4%BA%8C%E5%88%86/image-20240221231443219.png)![image-20240221231447765](./../imgs/%E4%BA%8C%E5%88%86/image-20240221231447765.png)![image-20240221231452303](./../imgs/%E4%BA%8C%E5%88%86/image-20240221231452303.png)![image-20240221231458092](./../imgs/%E4%BA%8C%E5%88%86/image-20240221231458092.png)![image-20240221231502178](./../imgs/%E4%BA%8C%E5%88%86/image-20240221231502178.png)![image-20240221231506859](./../imgs/%E4%BA%8C%E5%88%86/image-20240221231506859.png)![image-20240221231511234](./../imgs/%E4%BA%8C%E5%88%86/image-20240221231511234.png)![image-20240221231518881](./../imgs/%E4%BA%8C%E5%88%86/image-20240221231518881.png)![image-20240221231523253](./../imgs/%E4%BA%8C%E5%88%86/image-20240221231523253.png)![image-20240221231528135](./../imgs/%E4%BA%8C%E5%88%86/image-20240221231528135.png)![image-20240221231531987](./../imgs/%E4%BA%8C%E5%88%86/image-20240221231531987.png)![image-20240221231536273](./../imgs/%E4%BA%8C%E5%88%86/image-20240221231536273.png)![image-20240221231540455](./../imgs/%E4%BA%8C%E5%88%86/image-20240221231540455.png)![image-20240221231551542](./../imgs/%E4%BA%8C%E5%88%86/image-20240221231551542.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第二章：基础算法","基础算法"]},{"title":"双指针","url":"/2024/02/21/双指针/","content":"\n![image-20240221231249785](./../imgs/%E5%8F%8C%E6%8C%87%E9%92%88/image-20240221231249785.png)![image-20240221231254077](./../imgs/%E5%8F%8C%E6%8C%87%E9%92%88/image-20240221231254077.png)![image-20240221231257699](./../imgs/%E5%8F%8C%E6%8C%87%E9%92%88/image-20240221231257699.png)![image-20240221231301782](./../imgs/%E5%8F%8C%E6%8C%87%E9%92%88/image-20240221231301782.png)![image-20240221231305981](./../imgs/%E5%8F%8C%E6%8C%87%E9%92%88/image-20240221231305981.png)![image-20240221231309946](./../imgs/%E5%8F%8C%E6%8C%87%E9%92%88/image-20240221231309946.png)![image-20240221231314924](./../imgs/%E5%8F%8C%E6%8C%87%E9%92%88/image-20240221231314924.png)![image-20240221231319111](./../imgs/%E5%8F%8C%E6%8C%87%E9%92%88/image-20240221231319111.png)  ![image-20240221231331577](./../imgs/%E5%8F%8C%E6%8C%87%E9%92%88/image-20240221231331577.png)  ![image-20240221231346490](./../imgs/%E5%8F%8C%E6%8C%87%E9%92%88/image-20240221231346490.png)![image-20240221231351321](./../imgs/%E5%8F%8C%E6%8C%87%E9%92%88/image-20240221231351321.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第二章：基础算法","基础算法"]},{"title":"贪心","url":"/2024/02/21/贪心/","content":"\n![image-20240221231105941](./../imgs/%E8%B4%AA%E5%BF%83/image-20240221231105941.png)![image-20240221231111146](./../imgs/%E8%B4%AA%E5%BF%83/image-20240221231111146.png)![image-20240221231115510](./../imgs/%E8%B4%AA%E5%BF%83/image-20240221231115510.png)![image-20240221231119591](./../imgs/%E8%B4%AA%E5%BF%83/image-20240221231119591.png)![image-20240221231124495](./../imgs/%E8%B4%AA%E5%BF%83/image-20240221231124495.png)![image-20240221231128186](./../imgs/%E8%B4%AA%E5%BF%83/image-20240221231128186.png)![image-20240221231131857](./../imgs/%E8%B4%AA%E5%BF%83/image-20240221231131857.png)![image-20240221231135198](./../imgs/%E8%B4%AA%E5%BF%83/image-20240221231135198.png)![image-20240221231141344](./../imgs/%E8%B4%AA%E5%BF%83/image-20240221231141344.png)![image-20240221231145742](./../imgs/%E8%B4%AA%E5%BF%83/image-20240221231145742.png)         ![image-20240221231152759](./../imgs/%E8%B4%AA%E5%BF%83/image-20240221231152759.png)  ![image-20240221231207419](./../imgs/%E8%B4%AA%E5%BF%83/image-20240221231207419.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第二章：基础算法","基础算法"]},{"title":"离散化","url":"/2024/02/21/离散化/","content":"\n![image-20240221231005259](./../imgs/%E7%A6%BB%E6%95%A3%E5%8C%96/image-20240221231005259.png)\n\n![image-20240221231015772](./../imgs/%E7%A6%BB%E6%95%A3%E5%8C%96/image-20240221231015772.png)![image-20240221231020473](./../imgs/%E7%A6%BB%E6%95%A3%E5%8C%96/image-20240221231020473.png)![image-20240221231024651](./../imgs/%E7%A6%BB%E6%95%A3%E5%8C%96/image-20240221231024651.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第二章：基础算法","基础算法"]},{"title":"差分","url":"/2024/02/21/差分/","content":"\n![image-20240221230846735](./../imgs/%E5%B7%AE%E5%88%86/image-20240221230846735.png)![image-20240221230850787](./../imgs/%E5%B7%AE%E5%88%86/image-20240221230850787.png)![image-20240221230853819](./../imgs/%E5%B7%AE%E5%88%86/image-20240221230853819.png)![image-20240221230859239](./../imgs/%E5%B7%AE%E5%88%86/image-20240221230859239.png)![image-20240221230902898](./../imgs/%E5%B7%AE%E5%88%86/image-20240221230902898.png)![image-20240221230906987](./../imgs/%E5%B7%AE%E5%88%86/image-20240221230906987.png)![image-20240221230910327](./../imgs/%E5%B7%AE%E5%88%86/image-20240221230910327.png)![image-20240221230914034](./../imgs/%E5%B7%AE%E5%88%86/image-20240221230914034.png)![image-20240221230917410](./../imgs/%E5%B7%AE%E5%88%86/image-20240221230917410.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第二章：基础算法","基础算法"]},{"title":"前缀和","url":"/2024/02/21/前缀和/","content":"\n![image-20240221230643240](./../imgs/%E5%89%8D%E7%BC%80%E5%92%8C/image-20240221230643240.png)![image-20240221230646984](./../imgs/%E5%89%8D%E7%BC%80%E5%92%8C/image-20240221230646984.png)![image-20240221230650381](./../imgs/%E5%89%8D%E7%BC%80%E5%92%8C/image-20240221230650381.png)![image-20240221230653707](./../imgs/%E5%89%8D%E7%BC%80%E5%92%8C/image-20240221230653707.png)![image-20240221230658009](./../imgs/%E5%89%8D%E7%BC%80%E5%92%8C/image-20240221230658009.png)![image-20240221230701367](./../imgs/%E5%89%8D%E7%BC%80%E5%92%8C/image-20240221230701367.png)![image-20240221230704843](./../imgs/%E5%89%8D%E7%BC%80%E5%92%8C/image-20240221230704843.png)![image-20240221230713537](./../imgs/%E5%89%8D%E7%BC%80%E5%92%8C/image-20240221230713537.png)![image-20240221230717558](./../imgs/%E5%89%8D%E7%BC%80%E5%92%8C/image-20240221230717558.png)![image-20240221230720730](./../imgs/%E5%89%8D%E7%BC%80%E5%92%8C/image-20240221230720730.png)![image-20240221230724012](./../imgs/%E5%89%8D%E7%BC%80%E5%92%8C/image-20240221230724012.png)![image-20240221230735025](./../imgs/%E5%89%8D%E7%BC%80%E5%92%8C/image-20240221230735025.png)![image-20240221230739508](./../imgs/%E5%89%8D%E7%BC%80%E5%92%8C/image-20240221230739508.png)![image-20240221230742844](./../imgs/%E5%89%8D%E7%BC%80%E5%92%8C/image-20240221230742844.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第二章：基础算法","基础算法"]},{"title":"进制转换","url":"/2024/02/21/进制转换/","content":"\n![image-20240221230520575](./../imgs/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/image-20240221230520575.png)![image-20240221230524404](./../imgs/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/image-20240221230524404.png)![image-20240221230527911](./../imgs/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/image-20240221230527911.png)![image-20240221230531369](./../imgs/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/image-20240221230531369.png)![image-20240221230534525](./../imgs/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/image-20240221230534525.png)![image-20240221230538824](./../imgs/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/image-20240221230538824.png)![image-20240221230541976](./../imgs/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/image-20240221230541976.png)![image-20240221230545088](./../imgs/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/image-20240221230545088.png)![image-20240221230548483](./../imgs/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/image-20240221230548483.png)![image-20240221230554787](./../imgs/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/image-20240221230554787.png)![image-20240221230557974](./../imgs/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/image-20240221230557974.png)![image-20240221230601706](./../imgs/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/image-20240221230601706.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第二章：基础算法","基础算法"]},{"title":"递归","url":"/2024/02/21/递归/","content":"\n![image-20240221230319996](./../imgs/%E9%80%92%E5%BD%92/image-20240221230319996.png)![image-20240221230326745](./../imgs/%E9%80%92%E5%BD%92/image-20240221230326745.png)![image-20240221230330609](./../imgs/%E9%80%92%E5%BD%92/image-20240221230330609.png)![image-20240221230334716](./../imgs/%E9%80%92%E5%BD%92/image-20240221230334716.png)![image-20240221230338902](./../imgs/%E9%80%92%E5%BD%92/image-20240221230338902.png)![image-20240221230342790](./../imgs/%E9%80%92%E5%BD%92/image-20240221230342790.png)![image-20240221230346311](./../imgs/%E9%80%92%E5%BD%92/image-20240221230346311.png)![image-20240221230352241](./../imgs/%E9%80%92%E5%BD%92/image-20240221230352241.png)![image-20240221230357000](./../imgs/%E9%80%92%E5%BD%92/image-20240221230357000.png)![image-20240221230401685](./../imgs/%E9%80%92%E5%BD%92/image-20240221230401685.png)![image-20240221230421883](./../imgs/%E9%80%92%E5%BD%92/image-20240221230421883.png)![image-20240221230426028](./../imgs/%E9%80%92%E5%BD%92/image-20240221230426028.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第二章：基础算法","基础算法"]},{"title":"模拟","url":"/2024/02/21/模拟/","content":"\n![image-20240221230203001](./../imgs/%E6%A8%A1%E6%8B%9F/image-20240221230203001.png)![image-20240221230207880](./../imgs/%E6%A8%A1%E6%8B%9F/image-20240221230207880.png)![image-20240221230213716](./../imgs/%E6%A8%A1%E6%8B%9F/image-20240221230213716.png)![image-20240221230217450](./../imgs/%E6%A8%A1%E6%8B%9F/image-20240221230217450.png)![image-20240221230221651](./../imgs/%E6%A8%A1%E6%8B%9F/image-20240221230221651.png)![image-20240221230225216](./../imgs/%E6%A8%A1%E6%8B%9F/image-20240221230225216.png)![image-20240221230231815](./../imgs/%E6%A8%A1%E6%8B%9F/image-20240221230231815.png)![image-20240221230237070](./../imgs/%E6%A8%A1%E6%8B%9F/image-20240221230237070.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第二章：基础算法","基础算法"]},{"title":"枚举","url":"/2024/02/21/枚举/","content":"\n![image-20240221230115927](./../imgs/%E6%9E%9A%E4%B8%BE/image-20240221230115927.png)![image-20240221230120545](./../imgs/%E6%9E%9A%E4%B8%BE/image-20240221230120545.png)![image-20240221230125716](./../imgs/%E6%9E%9A%E4%B8%BE/image-20240221230125716.png)![image-20240221230130289](./../imgs/%E6%9E%9A%E4%B8%BE/image-20240221230130289.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第二章：基础算法","基础算法"]},{"title":"基础算法","url":"/2024/02/21/基础算法/","content":"\n![image-20240221225955641](./../imgs/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20240221225955641.png)![image-20240221230000345](./../imgs/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20240221230000345.png)![image-20240221230004329](./../imgs/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20240221230004329.png)![image-20240221230009161](./../imgs/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20240221230009161.png)![image-20240221230013873](./../imgs/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20240221230013873.png)![image-20240221230017951](./../imgs/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20240221230017951.png)![image-20240221230022719](./../imgs/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20240221230022719.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第二章：基础算法","基础算法"]},{"title":"桶排序","url":"/2024/02/21/桶排序/","content":"\n![image-20240221225325636](./../imgs/%E6%A1%B6%E6%8E%92%E5%BA%8F/image-20240221225325636.png)![image-20240221225330375](./../imgs/%E6%A1%B6%E6%8E%92%E5%BA%8F/image-20240221225330375.png)![image-20240221225334756](./../imgs/%E6%A1%B6%E6%8E%92%E5%BA%8F/image-20240221225334756.png)![image-20240221225338480](./../imgs/%E6%A1%B6%E6%8E%92%E5%BA%8F/image-20240221225338480.png)![image-20240221225341973](./../imgs/%E6%A1%B6%E6%8E%92%E5%BA%8F/image-20240221225341973.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第二章：基础算法","排序"]},{"title":"归并排序","url":"/2024/02/21/归并排序/","content":"\n![image-20240221225209102](./../imgs/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/image-20240221225209102.png)![image-20240221225213139](./../imgs/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/image-20240221225213139.png)![image-20240221225217288](./../imgs/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/image-20240221225217288.png)![image-20240221225225147](./../imgs/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/image-20240221225225147.png)![image-20240221225229209](./../imgs/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/image-20240221225229209.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第二章：基础算法","排序"]},{"title":"快速排序","url":"/2024/02/21/快速排序/","content":"\n![image-20240221225112243](./../imgs/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20240221225112243.png)![image-20240221225121627](./../imgs/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20240221225121627.png)![image-20240221225125664](./../imgs/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20240221225125664.png)![image-20240221225129479](./../imgs/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20240221225129479.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第二章：基础算法","排序"]},{"title":"插入排序","url":"/2024/02/21/插入排序/","content":"\n![image-20240221225024861](./../imgs/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/image-20240221225024861.png)![image-20240221225028438](./../imgs/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/image-20240221225028438.png)![image-20240221225032032](./../imgs/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/image-20240221225032032.png)![image-20240221225036107](./../imgs/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/image-20240221225036107.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第二章：基础算法","排序"]},{"title":"选择排序","url":"/2024/02/21/选择排序/","content":"\n![image-20240221224930479](./../imgs/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/image-20240221224930479.png)![image-20240221224934777](./../imgs/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/image-20240221224934777.png)![image-20240221224938744](./../imgs/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/image-20240221224938744.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第二章：基础算法","排序"]},{"title":"冒泡排序","url":"/2024/02/21/冒泡排序/","content":"\n![image-20240221224844137](./../imgs/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/image-20240221224844137.png)![image-20240221224848717](./../imgs/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/image-20240221224848717.png)![image-20240221224852578](./../imgs/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/image-20240221224852578.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第二章：基础算法","排序"]},{"title":"二分查找","url":"/2024/02/21/二分查找/","content":"\n![image-20240221224457642](./../imgs/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20240221224457642.png)![image-20240221224502553](./../imgs/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20240221224502553.png)![image-20240221224506663](./../imgs/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20240221224506663.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第一章：语言基础","实践应用"]},{"title":"自定义排序","url":"/2024/02/21/自定义排序/","content":"\n![image-20240221224337491](./../imgs/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/image-20240221224337491.png)![image-20240221224346170](./../imgs/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/image-20240221224346170.png)![image-20240221224350625](./../imgs/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/image-20240221224350625.png)![image-20240221224354361](./../imgs/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/image-20240221224354361.png)![image-20240221224358768](./../imgs/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/image-20240221224358768.png)![image-20240221224403413](./../imgs/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/image-20240221224403413.png)![image-20240221224407688](./../imgs/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/image-20240221224407688.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第一章：语言基础","实践应用"]},{"title":"常用库函数","url":"/2024/02/21/常用库函数/","content":"\n![image-20240221224152255](./../imgs/%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0/image-20240221224152255.png)![image-20240221224157569](./../imgs/%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0/image-20240221224157569.png)![image-20240221224205814](./../imgs/%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0/image-20240221224205814.png)![image-20240221224211031](./../imgs/%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0/image-20240221224211031.png)![image-20240221224216505](./../imgs/%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0/image-20240221224216505.png)![image-20240221224220419](./../imgs/%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0/image-20240221224220419.png)![image-20240221224224447](./../imgs/%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0/image-20240221224224447.png)![image-20240221224230648](./../imgs/%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0/image-20240221224230648.png)![image-20240221224237627](./../imgs/%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0/image-20240221224237627.png)![image-20240221224242810](./../imgs/%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0/image-20240221224242810.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第一章：语言基础","类的定义和使用"]},{"title":"类的定义和使用","url":"/2024/02/21/类的定义和使用/","content":"\n![image-20240221224039181](./../imgs/%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/image-20240221224039181.png)![image-20240221224043734](./../imgs/%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/image-20240221224043734.png)![image-20240221224047672](./../imgs/%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/image-20240221224047672.png)![image-20240221224051336](./../imgs/%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/image-20240221224051336.png)![image-20240221224056065](./../imgs/%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/image-20240221224056065.png)![image-20240221224059622](./../imgs/%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/image-20240221224059622.png)![image-20240221224103644](./../imgs/%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/image-20240221224103644.png)![image-20240221224107024](./../imgs/%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/image-20240221224107024.png)![image-20240221224112927](./../imgs/%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/image-20240221224112927.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第一章：语言基础","类的定义和使用"]},{"title":"itertools","url":"/2024/02/21/itertools/","content":"\n![image-20240221223900522](./../imgs/itertools/image-20240221223900522.png)![image-20240221223905143](./../imgs/itertools/image-20240221223905143.png)![image-20240221223908980](./../imgs/itertools/image-20240221223908980.png)![image-20240221223915443](./../imgs/itertools/image-20240221223915443.png)![image-20240221223920453](./../imgs/itertools/image-20240221223920453.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第一章：语言基础","函数"]},{"title":"functool","url":"/2024/02/21/functool/","content":"\n![image-20240221223812753](./../imgs/functool/image-20240221223812753.png)![image-20240221223816838](./../imgs/functool/image-20240221223816838.png)![image-20240221223821443](./../imgs/functool/image-20240221223821443.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第一章：语言基础","函数"]},{"title":"heapq","url":"/2024/02/21/heapq/","content":"\n![image-20240221223705829](./../imgs/heapq/image-20240221223705829.png)![image-20240221223714290](./../imgs/heapq/image-20240221223714290.png)![image-20240221223718197](./../imgs/heapq/image-20240221223718197.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第一章：语言基础","函数"]},{"title":"collections","url":"/2024/02/21/collections/","content":"\n![image-20240221223509574](./../imgs/collections/image-20240221223509574.png)![image-20240221223515065](./../imgs/collections/image-20240221223515065.png)![image-20240221223519280](./../imgs/collections/image-20240221223519280.png)![image-20240221223522902](./../imgs/collections/image-20240221223522902.png)![image-20240221223527976](./../imgs/collections/image-20240221223527976.png)![image-20240221223531621](./../imgs/collections/image-20240221223531621.png)![image-20240221223535228](./../imgs/collections/image-20240221223535228.png)![image-20240221223539036](./../imgs/collections/image-20240221223539036.png)![image-20240221223543552](./../imgs/collections/image-20240221223543552.png)![image-20240221223549009](./../imgs/collections/image-20240221223549009.png)![image-20240221223601504](./../imgs/collections/image-20240221223601504.png)![image-20240221223605696](./../imgs/collections/image-20240221223605696.png)![image-20240221223609819](./../imgs/collections/image-20240221223609819.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第一章：语言基础","函数"]},{"title":"math","url":"/2024/02/21/math/","content":"\n![image-20240221223402991](./../imgs/math/image-20240221223402991.png)![image-20240221223407450](./../imgs/math/image-20240221223407450.png)![image-20240221223412809](./../imgs/math/image-20240221223412809.png)![image-20240221223416965](./../imgs/math/image-20240221223416965.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第一章：语言基础","函数"]},{"title":"函数定义与使用","url":"/2024/02/21/函数定义与使用/","content":"\n![image-20240221223144476](./../imgs/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/image-20240221223144476.png)![image-20240221223149837](./../imgs/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/image-20240221223149837.png)![image-20240221223153955](./../imgs/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/image-20240221223153955.png)![image-20240221223158102](./../imgs/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/image-20240221223158102.png)![image-20240221223206547](./../imgs/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/image-20240221223206547.png)![image-20240221223210243](./../imgs/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/image-20240221223210243.png)![image-20240221223213951](./../imgs/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/image-20240221223213951.png)![image-20240221223217636](./../imgs/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/image-20240221223217636.png)![image-20240221223221164](./../imgs/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/image-20240221223221164.png)![image-20240221223237797](./../imgs/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/image-20240221223237797.png)![image-20240221223242834](./../imgs/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/image-20240221223242834.png)![image-20240221223247214](./../imgs/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/image-20240221223247214.png)![image-20240221223250865](./../imgs/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/image-20240221223250865.png)![image-20240221223255767](./../imgs/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/image-20240221223255767.png)![image-20240221223259483](./../imgs/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/image-20240221223259483.png)![image-20240221223303374](./../imgs/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/image-20240221223303374.png)![image-20240221223307490](./../imgs/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/image-20240221223307490.png)![image-20240221223312710](./../imgs/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/image-20240221223312710.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第一章：语言基础","函数"]},{"title":"日期和时间","url":"/2024/02/21/日期和时间/","content":"\n![image-20240221222711369](./../imgs/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/image-20240221222711369.png)![image-20240221222720228](./../imgs/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/image-20240221222720228.png)![image-20240221222727434](./../imgs/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/image-20240221222727434.png)![image-20240221222731177](./../imgs/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/image-20240221222731177.png)![image-20240221222735426](./../imgs/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/image-20240221222735426.png)![image-20240221222740641](./../imgs/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/image-20240221222740641.png)![image-20240221222744448](./../imgs/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/image-20240221222744448.png)![image-20240221222748410](./../imgs/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/image-20240221222748410.png)![image-20240221222752150](./../imgs/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/image-20240221222752150.png)![image-20240221222755872](./../imgs/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/image-20240221222755872.png)![image-20240221222807738](./../imgs/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/image-20240221222807738.png)![image-20240221222811801](./../imgs/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/image-20240221222811801.png)![image-20240221222816005](./../imgs/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/image-20240221222816005.png)![image-20240221222821439](./../imgs/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/image-20240221222821439.png)![image-20240221222825105](./../imgs/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/image-20240221222825105.png)![image-20240221222828542](./../imgs/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/image-20240221222828542.png)![image-20240221222832686](./../imgs/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/image-20240221222832686.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第一章：语言基础","基础数据结构"]},{"title":"集合","url":"/2024/02/21/集合/","content":"\n![image-20240221222542051](./../imgs/%E9%9B%86%E5%90%88/image-20240221222542051.png)![image-20240221222547184](./../imgs/%E9%9B%86%E5%90%88/image-20240221222547184.png)![image-20240221222554360](./../imgs/%E9%9B%86%E5%90%88/image-20240221222554360.png)![image-20240221222559249](./../imgs/%E9%9B%86%E5%90%88/image-20240221222559249.png)![image-20240221222604316](./../imgs/%E9%9B%86%E5%90%88/image-20240221222604316.png)![image-20240221222609307](./../imgs/%E9%9B%86%E5%90%88/image-20240221222609307.png)![image-20240221222613877](./../imgs/%E9%9B%86%E5%90%88/image-20240221222613877.png)![image-20240221222617689](./../imgs/%E9%9B%86%E5%90%88/image-20240221222617689.png)![image-20240221222622814](./../imgs/%E9%9B%86%E5%90%88/image-20240221222622814.png)![image-20240221222627329](./../imgs/%E9%9B%86%E5%90%88/image-20240221222627329.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第一章：语言基础","基础数据结构"]},{"title":"字典","url":"/2024/02/21/字典/","content":"\n![image-20240221222346041](./../imgs/%E5%AD%97%E5%85%B8/image-20240221222346041.png)![image-20240221222351366](./../imgs/%E5%AD%97%E5%85%B8/image-20240221222351366.png)![image-20240221222355064](./../imgs/%E5%AD%97%E5%85%B8/image-20240221222355064.png)![image-20240221222358745](./../imgs/%E5%AD%97%E5%85%B8/image-20240221222358745.png)![image-20240221222402204](./../imgs/%E5%AD%97%E5%85%B8/image-20240221222402204.png)![image-20240221222405543](./../imgs/%E5%AD%97%E5%85%B8/image-20240221222405543.png)![image-20240221222409359](./../imgs/%E5%AD%97%E5%85%B8/image-20240221222409359.png)![image-20240221222413703](./../imgs/%E5%AD%97%E5%85%B8/image-20240221222413703.png)![image-20240221222418496](./../imgs/%E5%AD%97%E5%85%B8/image-20240221222418496.png)![image-20240221222423129](./../imgs/%E5%AD%97%E5%85%B8/image-20240221222423129.png)![image-20240221222426868](./../imgs/%E5%AD%97%E5%85%B8/image-20240221222426868.png)\t![image-20240221222432037](./../imgs/%E5%AD%97%E5%85%B8/image-20240221222432037.png)![image-20240221222436082](./../imgs/%E5%AD%97%E5%85%B8/image-20240221222436082.png)![image-20240221222439828](./../imgs/%E5%AD%97%E5%85%B8/image-20240221222439828.png)![image-20240221222443437](./../imgs/%E5%AD%97%E5%85%B8/image-20240221222443437.png)![image-20240221222446914](./../imgs/%E5%AD%97%E5%85%B8/image-20240221222446914.png)![image-20240221222451805](./../imgs/%E5%AD%97%E5%85%B8/image-20240221222451805.png)![image-20240221222455280](./../imgs/%E5%AD%97%E5%85%B8/image-20240221222455280.png)![image-20240221222500308](./../imgs/%E5%AD%97%E5%85%B8/image-20240221222500308.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第一章：语言基础","基础数据结构"]},{"title":"字符串","url":"/2024/02/21/字符串/","content":"\n![image-20240221221426266](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221221426266.png)![image-20240221221431505](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221221431505.png)![image-20240221221436593](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221221436593.png)![image-20240221221441127](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221221441127.png)![image-20240221221445585](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221221445585.png)![image-20240221221449788](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221221449788.png)![image-20240221221456357](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221221456357.png)![image-20240221222130526](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221222130526.png)![image-20240221222136639](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221222136639.png)![image-20240221222140218](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221222140218.png)![image-20240221222143801](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221222143801.png)![image-20240221222147579](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221222147579.png)![image-20240221222151562](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221222151562.png)![image-20240221222155712](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221222155712.png)![image-20240221222200185](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221222200185.png)![image-20240221222203657](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221222203657.png)![image-20240221222206992](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221222206992.png)![image-20240221222211491](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221222211491.png)![image-20240221222216243](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221222216243.png)![image-20240221222219995](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221222219995.png)![image-20240221222224286](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221222224286.png)![image-20240221222227854](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221222227854.png)![image-20240221222233158](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221222233158.png)![image-20240221222236617](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221222236617.png)![image-20240221222241092](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221222241092.png)![image-20240221222244639](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221222244639.png)![image-20240221222248227](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221222248227.png)![image-20240221222251528](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221222251528.png)![image-20240221222255831](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221222255831.png)![image-20240221222300550](./../imgs/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20240221222300550.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第一章：语言基础","基础数据结构"]},{"title":"列表和元组","url":"/2024/02/21/列表和元组/","content":"\n![image-20240221220549989](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221220549989.png)![image-20240221220803586](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221220803586.png)![image-20240221220815992](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221220815992.png)![image-20240221220820075](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221220820075.png)![image-20240221220824239](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221220824239.png)![image-20240221220828733](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221220828733.png)![image-20240221220832816](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221220832816.png)![image-20240221220836720](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221220836720.png)![image-20240221220841249](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221220841249.png)![image-20240221220845617](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221220845617.png)![image-20240221220849199](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221220849199.png)![image-20240221220852872](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221220852872.png)![image-20240221220856306](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221220856306.png)![image-20240221220859777](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221220859777.png)![image-20240221220904199](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221220904199.png)![image-20240221220908800](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221220908800.png)![image-20240221220913599](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221220913599.png)![image-20240221220927749](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221220927749.png)![image-20240221221228059](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221221228059.png)![image-20240221221236243](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221221236243.png)![image-20240221221240609](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221221240609.png)![image-20240221221245011](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221221245011.png)![image-20240221221249685](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221221249685.png)![image-20240221221254515](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221221254515.png)![image-20240221221257834](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221221257834.png)![image-20240221221301606](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221221301606.png)![image-20240221221306649](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221221306649.png)![image-20240221221330471](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221221330471.png)![image-20240221221334747](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221221334747.png)![image-20240221221340593](./../imgs/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/image-20240221221340593.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第一章：语言基础","基础数据结构"]},{"title":"循环嵌套","url":"/2024/02/21/循环嵌套/","content":"\n![image-20240221220238457](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220238457.png)![image-20240221220245943](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220245943.png)![image-20240221220250308](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220250308.png)![image-20240221220254228](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220254228.png)![image-20240221220259111](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220259111.png)![image-20240221220303143](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220303143.png)![image-20240221220307403](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220307403.png)![image-20240221220311467](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220311467.png)![image-20240221220326367](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220326367.png)![image-20240221220332012](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220332012.png)![image-20240221220336543](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220336543.png)![image-20240221220340486](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220340486.png)![image-20240221220344459](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220344459.png)![image-20240221220348968](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220348968.png)![image-20240221220353388](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220353388.png)![image-20240221220357488](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220357488.png)![image-20240221220401435](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220401435.png)![image-20240221220405574](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220405574.png)![image-20240221220408987](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220408987.png)![image-20240221220412797](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220412797.png)![image-20240221220416120](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220416120.png)![image-20240221220420419](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220420419.png)![image-20240221220423689](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220423689.png)![image-20240221220427069](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220427069.png)![image-20240221220432954](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220432954.png)![image-20240221220436736](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220436736.png)![image-20240221220440869](./../imgs/%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97/image-20240221220440869.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第一章：语言基础","循环结构"]},{"title":"while语句","url":"/2024/02/21/while语句/","content":"\n![image-20240221220037419](./../imgs/while%E8%AF%AD%E5%8F%A5/image-20240221220037419.png)![image-20240221220042444](./../imgs/while%E8%AF%AD%E5%8F%A5/image-20240221220042444.png)![image-20240221220046800](./../imgs/while%E8%AF%AD%E5%8F%A5/image-20240221220046800.png)![image-20240221220052301](./../imgs/while%E8%AF%AD%E5%8F%A5/image-20240221220052301.png)![image-20240221220057306](./../imgs/while%E8%AF%AD%E5%8F%A5/image-20240221220057306.png)![image-20240221220102132](./../imgs/while%E8%AF%AD%E5%8F%A5/image-20240221220102132.png)![image-20240221220107177](./../imgs/while%E8%AF%AD%E5%8F%A5/image-20240221220107177.png)![image-20240221220111657](./../imgs/while%E8%AF%AD%E5%8F%A5/image-20240221220111657.png)![image-20240221220132922](./../imgs/while%E8%AF%AD%E5%8F%A5/image-20240221220132922.png)![image-20240221220139888](./../imgs/while%E8%AF%AD%E5%8F%A5/image-20240221220139888.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第一章：语言基础","循环结构"]},{"title":"for语句","url":"/2024/02/21/for语句/","content":"\n![image-20240221215544745](./../imgs/for%E8%AF%AD%E5%8F%A5/image-20240221215544745.png)![image-20240221215550340](./../imgs/for%E8%AF%AD%E5%8F%A5/image-20240221215550340.png)![image-20240221215556410](./../imgs/for%E8%AF%AD%E5%8F%A5/image-20240221215556410.png)![image-20240221215600726](./../imgs/for%E8%AF%AD%E5%8F%A5/image-20240221215600726.png)![image-20240221215605214](./../imgs/for%E8%AF%AD%E5%8F%A5/image-20240221215605214.png)![image-20240221215609988](./../imgs/for%E8%AF%AD%E5%8F%A5/image-20240221215609988.png)![image-20240221215616048](./../imgs/for%E8%AF%AD%E5%8F%A5/image-20240221215616048.png)![image-20240221215623189](./../imgs/for%E8%AF%AD%E5%8F%A5/image-20240221215623189.png)![image-20240221215629195](./../imgs/for%E8%AF%AD%E5%8F%A5/image-20240221215629195.png)![image-20240221215634954](./../imgs/for%E8%AF%AD%E5%8F%A5/image-20240221215634954.png)![image-20240221215641036](./../imgs/for%E8%AF%AD%E5%8F%A5/image-20240221215641036.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第一章：语言基础","循环结构"]},{"title":"if语句","url":"/2024/02/21/if语句/","content":"\n![image-20240221215311297](./../imgs/if%E8%AF%AD%E5%8F%A5/image-20240221215311297.png)\n\n![image-20240221215317245](./../imgs/if%E8%AF%AD%E5%8F%A5/image-20240221215317245.png)\n\n![image-20240221215323353](./../imgs/if%E8%AF%AD%E5%8F%A5/image-20240221215323353.png)\n\n![image-20240221215328782](./../imgs/if%E8%AF%AD%E5%8F%A5/image-20240221215328782.png)\n\n![image-20240221215334767](./../imgs/if%E8%AF%AD%E5%8F%A5/image-20240221215334767.png)\n\n![image-20240221215340285](./../imgs/if%E8%AF%AD%E5%8F%A5/image-20240221215340285.png)\n\n![image-20240221215345522](./../imgs/if%E8%AF%AD%E5%8F%A5/image-20240221215345522.png)\n\n![image-20240221215351310](./../imgs/if%E8%AF%AD%E5%8F%A5/image-20240221215351310.png)\n\n![image-20240221215359903](./../imgs/if%E8%AF%AD%E5%8F%A5/image-20240221215359903.png)\n\n![image-20240221215405317](./../imgs/if%E8%AF%AD%E5%8F%A5/image-20240221215405317.png)![image-20240221215411133](./../imgs/if%E8%AF%AD%E5%8F%A5/image-20240221215411133.png)![image-20240221215426225](./../imgs/if%E8%AF%AD%E5%8F%A5/image-20240221215426225.png)![image-20240221215432876](./../imgs/if%E8%AF%AD%E5%8F%A5/image-20240221215432876.png)\n\n![image-20240221215444985](./../imgs/if%E8%AF%AD%E5%8F%A5/image-20240221215444985.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第一章：语言基础","选择结构"]},{"title":"条件表达式和逻辑表达式","url":"/2024/02/21/条件表达式和逻辑表达式/","content":"\n![image-20240221214552432](./../imgs/%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20240221214552432.png)![image-20240221214559882](./../imgs/%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20240221214559882.png)![image-20240221214610783](./../imgs/%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20240221214610783.png)![image-20240221214615485](./../imgs/%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20240221214615485.png)![image-20240221214620619](./../imgs/%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20240221214620619.png)![image-20240221214628337](./../imgs/%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20240221214628337.png)![image-20240221214633449](./../imgs/%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20240221214633449.png)![image-20240221214638568](./../imgs/%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20240221214638568.png)\n\n![image-20240221214945674](./../imgs/%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20240221214945674.png)![image-20240221214951805](./../imgs/%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20240221214951805.png)![image-20240221214959435](./../imgs/%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20240221214959435.png)![image-20240221215009459](./../imgs/%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20240221215009459.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第一章：语言基础","选择结构"]},{"title":"常量、变量与运算符","url":"/2024/02/21/常量、变量与运算符/","content":"\n![image-20240221214110296](./../imgs/%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20240221214110296.png)![image-20240221214126383](./../imgs/%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20240221214126383.png)\n\n![image-20240221214134728](./../imgs/%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20240221214134728.png)\n\n![image-20240221214200076](./../imgs/%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20240221214200076.png)\n\n![image-20240221214210558](./../imgs/%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20240221214210558.png)\n\n![image-20240221214219520](./../imgs/%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20240221214219520.png)\n\n![image-20240221214229793](./../imgs/%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20240221214229793.png)\n\n![image-20240221214237176](./../imgs/%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20240221214237176.png)\n\n![image-20240221214246396](./../imgs/%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20240221214246396.png)![image-20240221214254820](./../imgs/%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20240221214254820.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第一章：语言基础","编程基础"]},{"title":"Python输入输出","url":"/2024/02/21/Python输入输出/","content":"\n![image-20240221213902685](./../imgs/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20240221213902685.png)\n\n![image-20240221213915397](./../imgs/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20240221213915397.png)![image-20240221213925703](./../imgs/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20240221213925703.png)\n\n![image-20240221213937602](./../imgs/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20240221213937602.png)![image-20240221213947577](./../imgs/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20240221213947577.png)![image-20240221213957381](./../imgs/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20240221213957381.png)\n\n![image-20240221214008221](./../imgs/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20240221214008221.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第一章：语言基础","编程基础"]},{"title":"Python开发环境与基础知识","url":"/2024/02/21/Python开发环境与基础知识/","content":"\n![image-20240221212645001](./../imgs/Python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240221212645001.png)\n\n![image-20240221212703666](./../imgs/Python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240221212703666.png)\n\n![image-20240221212715849](./../imgs/Python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240221212715849.png)\n\n![image-20240221212728371](./../imgs/Python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240221212728371.png)\n\n![image-20240221212739932](./../imgs/Python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240221212739932.png)\n\n![image-20240221212759396](./../imgs/Python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240221212759396.png)\n\n![image-20240221212810735](./../imgs/Python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240221212810735.png)\n\n![image-20240221212824944](./../imgs/Python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240221212824944.png)\n\n![image-20240221213119364](./../imgs/Python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240221213119364.png)\n\n![image-20240221213130189](./../imgs/Python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240221213130189.png)\n","tags":["蓝桥杯备赛"],"categories":["蓝桥杯","第一章：语言基础","编程基础"]},{"title":"蓝桥杯知识记录","url":"/2024/02/21/蓝桥杯知识记录/","content":"\n![image-20240221204217791](./../imgs/$%7Bfiilename%7D/image-20240221204217791-1708519354510-1.png)\n\n","tags":["蓝桥杯学习路线"],"categories":["蓝桥杯","A学习路线"]},{"title":"Hello World","url":"/2024/02/20/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]